{"version":3,"file":"static/js/284.37a529b8.chunk.js","mappings":"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","sources":["../../../token-negotiator/src/wallet/Web3WalletProvider.ts"],"sourcesContent":["import { ethers } from 'ethers'\nimport { logger } from '../utils'\nimport { SafeConnectOptions } from './SafeConnectProvider'\nimport { Client } from '../client'\n\ninterface WalletConnectionState {\n\t[index: string]: WalletConnection\n}\n\ninterface WalletConnection {\n\taddress: string\n\tchainId: number | string\n\tproviderType: string\n\tblockchain: string\n\tprovider?: ethers.providers.Web3Provider\n\tethers?: any\n}\n\nexport class Web3WalletProvider {\n\tprivate static LOCAL_STORAGE_KEY = 'tn-wallet-connections'\n\n\tconnections: WalletConnectionState = {}\n\n\tsafeConnectOptions?: SafeConnectOptions\n\tclient: Client\n\n\tconstructor(client: Client, safeConnectOptions?: SafeConnectOptions) {\n\t\tthis.client = client\n\t\tthis.safeConnectOptions = safeConnectOptions\n\t}\n\n\tsaveConnections() {\n\t\tlet savedConnections: WalletConnectionState = {}\n\n\t\tfor (let address in this.connections) {\n\t\t\tlet con = this.connections[address]\n\n\t\t\tsavedConnections[address] = {\n\t\t\t\taddress: con.address,\n\t\t\t\tchainId: con.chainId,\n\t\t\t\tproviderType: con.providerType,\n\t\t\t\tblockchain: con.blockchain,\n\t\t\t\tethers: ethers,\n\t\t\t}\n\t\t}\n\n\t\tlocalStorage.setItem(Web3WalletProvider.LOCAL_STORAGE_KEY, JSON.stringify(savedConnections))\n\t}\n\n\temitSavedConnection(address: string) {\n\t\tif (Object.keys(this.connections).length && address) {\n\t\t\tthis.client.eventSender('connected-wallet', { data: this.connections[address.toLocaleLowerCase()] })\n\t\t\treturn this.connections[address.toLocaleLowerCase()]\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\temitNetworkChange(chainId: string) {\n\t\tif (chainId) {\n\t\t\tthis.client.eventSender('network-change', chainId)\n\n\t\t\treturn chainId\n\t\t}\n\t}\n\n\tdeleteConnections() {\n\t\tthis.connections = {}\n\t\tlocalStorage.removeItem(Web3WalletProvider.LOCAL_STORAGE_KEY)\n\t\tlocalStorage.removeItem('walletconnect')\n\t\t// remove session storage for the case of flow network\n\t\tsessionStorage.removeItem('CURRENT_USER')\n\t}\n\n\tasync loadConnections() {\n\t\tlet data = localStorage.getItem(Web3WalletProvider.LOCAL_STORAGE_KEY)\n\n\t\tif (!data) return\n\n\t\tlet state = JSON.parse(data)\n\n\t\tif (!state) return\n\n\t\tfor (let address in state) {\n\t\t\tlet connection = state[address]\n\n\t\t\ttry {\n\t\t\t\tawait this.connectWith(connection.providerType, true)\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(\"Wallet couldn't connect: \" + e.message)\n\t\t\t\tdelete state[address]\n\t\t\t\tthis.saveConnections()\n\t\t\t\tthis.emitSavedConnection(address)\n\t\t\t}\n\t\t}\n\t}\n\n\tasync connectWith(walletType: string, checkConnectionOnly = false) {\n\t\tif (!walletType) throw new Error('Please provide a Wallet type to connect with.')\n\n\t\tif (this[walletType as keyof Web3WalletProvider]) {\n\t\t\t// @ts-ignore\n\t\t\t// TODO: this address is null for the flow network\n\t\t\t// Actual connected address is get in flowSubscribe function\n\t\t\tconst address = await this[walletType as keyof Web3WalletProvider](checkConnectionOnly)\n\t\t\tlogger(2, 'address', address)\n\n\t\t\tthis.saveConnections()\n\t\t\tthis.emitSavedConnection(address)\n\t\t\treturn address\n\t\t} else {\n\t\t\tthrow new Error('Wallet type not found')\n\t\t}\n\t}\n\n\tasync signMessage(address: string, message: string) {\n\t\tlet provider = this.getWalletProvider(address)\n\n\t\tlet signer = provider.getSigner(address)\n\n\t\treturn await signer.signMessage(message)\n\t}\n\n\tgetWalletProvider(address: string) {\n\t\taddress = address.toLowerCase()\n\n\t\tif (!this.connections[address]?.provider) throw new Error('Wallet provider not found for address')\n\n\t\treturn this.connections[address].provider\n\t}\n\n\tgetConnectedWalletData() {\n\t\treturn Object.values(this.connections)\n\t}\n\n\tregisterNewWalletAddress(\n\t\taddress: string,\n\t\tchainId: number | string,\n\t\tproviderType: string,\n\t\tprovider: any,\n\t\tblockchain = 'evm',\n\t) {\n\t\tthis.connections[address.toLowerCase()] = { address, chainId, providerType, provider, blockchain, ethers }\n\t\treturn address\n\t}\n\n\tprivate async registerProvider(provider: ethers.providers.Web3Provider, providerName: string) {\n\t\tconst accounts = await provider.listAccounts()\n\t\tconst chainId = (await provider.detectNetwork()).chainId\n\n\t\tif (accounts.length === 0) {\n\t\t\tthrow new Error('No accounts found via wallet-connect.')\n\t\t}\n\n\t\tlet curAccount = accounts[0]\n\n\t\tthis.registerNewWalletAddress(curAccount, chainId, providerName, provider)\n\n\t\t// @ts-ignore\n\t\tprovider.provider.on('accountsChanged', (accounts) => {\n\t\t\tif (!accounts || accounts.length === 0) {\n\t\t\t\tthis.client.disconnectWallet()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (curAccount === accounts[0]) return\n\n\t\t\tdelete this.connections[curAccount.toLowerCase()]\n\n\t\t\tcurAccount = accounts[0]\n\n\t\t\tthis.registerNewWalletAddress(curAccount, chainId, providerName, provider)\n\n\t\t\tthis.saveConnections()\n\n\t\t\tthis.emitSavedConnection(curAccount)\n\n\t\t\tthis.client.getTokenStore().clearCachedTokens()\n\t\t\tthis.client.enrichTokenLookupDataOnChainTokens()\n\t\t})\n\n\t\t// @ts-ignore\n\t\tprovider.provider.on('chainChanged', (_chainId: any) => {\n\t\t\tthis.registerNewWalletAddress(accounts[0], _chainId, providerName, provider)\n\n\t\t\tthis.saveConnections()\n\n\t\t\tthis.emitNetworkChange(_chainId)\n\t\t})\n\n\t\t// @ts-ignore\n\t\t// walletconnect\n\t\tprovider.provider.on('disconnect', (reason: any) => {\n\t\t\tif (reason?.message && reason.message.indexOf('MetaMask: Disconnected from chain') > -1) return\n\n\t\t\tthis.client.disconnectWallet()\n\t\t})\n\n\t\treturn accounts[0]\n\t}\n\n\tasync MetaMask(checkConnectionOnly: boolean) {\n\t\tlogger(2, 'connect MetaMask')\n\n\t\tif (typeof window.ethereum !== 'undefined') {\n\t\t\tawait window.ethereum.enable() // fall back may be needed for FF to open Extension Prompt.\n\n\t\t\tconst provider = new ethers.providers.Web3Provider(window.ethereum, 'any')\n\n\t\t\treturn this.registerProvider(provider, 'MetaMask')\n\t\t} else {\n\t\t\tthrow new Error('MetaMask is not available. Please check the extension is supported and active.')\n\t\t}\n\t}\n\n\tasync WalletConnect(checkConnectionOnly: boolean) {\n\t\tlogger(2, 'connect Wallet Connect')\n\n\t\tconst walletConnectProvider = await import('./WalletConnectProvider')\n\n\t\tconst walletConnect = await walletConnectProvider.getWalletConnectProviderInstance(checkConnectionOnly)\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (checkConnectionOnly) {\n\t\t\t\twalletConnect.connector.on('display_uri', (err, payload) => {\n\t\t\t\t\treject(new Error('Connection expired'))\n\t\t\t\t})\n\t\t\t}\n\n\t\t\twalletConnect\n\t\t\t\t.enable()\n\t\t\t\t.then(() => {\n\t\t\t\t\tconst provider = new ethers.providers.Web3Provider(walletConnect, 'any')\n\n\t\t\t\t\tresolve(this.registerProvider(provider, 'WalletConnect'))\n\t\t\t\t})\n\t\t\t\t.catch((e) => reject(e))\n\t\t})\n\t}\n\n\tasync WalletConnectV2(checkConnectionOnly: boolean) {\n\t\tlogger(2, 'connect Wallet Connect V2')\n\n\t\tconst walletConnectProvider = await import('./WalletConnectV2Provider')\n\n\t\tconst universalWalletConnect = await walletConnectProvider.getWalletConnectV2ProviderInstance()\n\n\t\tlet QRCodeModal\n\n\t\tuniversalWalletConnect.on('display_uri', async (uri: string) => {\n\t\t\tconsole.log('EVENT', 'QR Code Modal open')\n\n\t\t\tQRCodeModal = (await import('@walletconnect/qrcode-modal')).default\n\n\t\t\tQRCodeModal.open(uri, () => {\n\t\t\t\tthis.client.getUi().showError('User closed modal')\n\t\t\t})\n\t\t})\n\n\t\t// Subscribe to session delete\n\t\tuniversalWalletConnect.on('session_delete', ({ id, topic }: { id: number; topic: string }) => {\n\t\t\tconsole.log('WC V2 EVENT', 'session_deleted')\n\t\t\t// TODO: There is currently a bug in the universal provider that prevents this handler from being called.\n\t\t\t//  After this is fixed, this should handle the event correctly\n\t\t\t//  https://github.com/WalletConnect/walletconnect-monorepo/issues/1772\n\t\t\tthis.client.disconnectWallet()\n\t\t})\n\n\t\tif (!checkConnectionOnly) {\n\t\t\tlet pairing\n\n\t\t\tawait universalWalletConnect.connect({\n\t\t\t\tnamespaces: {\n\t\t\t\t\teip155: {\n\t\t\t\t\t\tmethods: ['eth_sendTransaction', 'eth_signTransaction', 'eth_sign', 'personal_sign', 'eth_signTypedData'],\n\t\t\t\t\t\tchains: walletConnectProvider.WC_V2_CHAINS,\n\t\t\t\t\t\tevents: ['chainChanged', 'accountsChanged'],\n\t\t\t\t\t\trpcMap: walletConnectProvider.CUSTOM_RPCS_FOR_WC_V2,\n\t\t\t\t\t\t// rpcMap: {\n\t\t\t\t\t\t// \t1: `https://mainnet.infura.io/v3/9f79b2f9274344af90b8d4e244b580ef`\n\t\t\t\t\t\t// }\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tpairingTopic: pairing?.topic,\n\t\t\t})\n\n\t\t\tQRCodeModal.close()\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuniversalWalletConnect\n\t\t\t\t.enable()\n\t\t\t\t.then(() => {\n\t\t\t\t\tconst provider = new ethers.providers.Web3Provider(universalWalletConnect, 'any')\n\n\t\t\t\t\tresolve(this.registerProvider(provider, 'WalletConnectV2'))\n\t\t\t\t})\n\t\t\t\t.catch((e) => {\n\t\t\t\t\treject(e)\n\t\t\t\t})\n\t\t})\n\t}\n\n\tasync Torus(checkConnectionOnly: boolean) {\n\t\tconst TorusProvider = await import('./TorusProvider')\n\n\t\tconst torus = await TorusProvider.getTorusProviderInstance()\n\n\t\tawait torus.init()\n\n\t\tawait torus.login()\n\n\t\tconst provider = new ethers.providers.Web3Provider(torus.provider, 'any')\n\n\t\treturn this.registerProvider(provider, 'Torus')\n\t}\n\n\tasync Phantom() {\n\t\tlogger(2, 'connect Phantom')\n\n\t\tif (typeof window.solana !== 'undefined') {\n\t\t\tconst connection = await window.solana.connect()\n\n\t\t\tconst accountAddress: string = connection.publicKey.toBase58()\n\n\t\t\t// mainnet-beta,\n\t\t\treturn this.registerNewWalletAddress(accountAddress, 'mainnet-beta', 'phantom', window.solana, 'solana')\n\t\t} else {\n\t\t\tthrow new Error('MetaMask is not available. Please check the extension is supported and active.')\n\t\t}\n\t}\n\n\tasync SafeConnect() {\n\t\tlogger(2, 'connect SafeConnect')\n\n\t\tconst provider = await this.getSafeConnectProvider()\n\n\t\tconst address = await provider.initSafeConnect()\n\n\t\tthis.registerNewWalletAddress(address, 1, 'SafeConnect', provider)\n\n\t\treturn address\n\t}\n\n\tasync flowSubscribe(fcl, currentUser) {\n\t\ttry {\n\t\t\tif (currentUser.addr) {\n\t\t\t\tthis.registerNewWalletAddress(currentUser.addr, 1, 'flow', fcl)\n\n\t\t\t\tconst ui = this.client.getUi()\n\n\t\t\t\tif (ui) ui.dismissLoader()\n\n\t\t\t\tthis.client.enrichTokenLookupDataOnChainTokens()\n\t\t\t\tif (ui) ui.updateUI('main')\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error('flow wallet connection error ==>', e)\n\t\t\tthis.client.getUi().showError('Flow wallet connection error.')\n\t\t}\n\t}\n\n\tasync Flow() {\n\t\ttry {\n\t\t\tconst flowProvider = await import('./FlowProvider')\n\t\t\tconst fcl = flowProvider.getFlowProvider()\n\n\t\t\tfcl.currentUser.subscribe((currentUser) => this.flowSubscribe(fcl, currentUser))\n\t\t\tfcl.authenticate()\n\t\t} catch (e) {\n\t\t\tconsole.error('error ==>', e)\n\t\t}\n\t\treturn ''\n\t}\n\n\tsafeConnectAvailable() {\n\t\treturn this.safeConnectOptions !== undefined\n\t}\n\n\tasync getSafeConnectProvider() {\n\t\tconst { SafeConnectProvider } = await import('./SafeConnectProvider')\n\n\t\treturn new SafeConnectProvider(this.client.getUi(), this.safeConnectOptions)\n\t}\n}\n\nexport default Web3WalletProvider\n"],"names":["client","safeConnectOptions","connections","this","Web3WalletProvider","savedConnections","address","con","chainId","providerType","blockchain","ethers","localStorage","setItem","LOCAL_STORAGE_KEY","JSON","stringify","Object","keys","length","eventSender","data","toLocaleLowerCase","removeItem","sessionStorage","getItem","state","parse","connection","connectWith","_d","console","log","e_1","message","saveConnections","emitSavedConnection","walletType","checkConnectionOnly","Error","_a","logger","provider","getWalletProvider","getSigner","signMessage","toLowerCase","values","providerName","listAccounts","accounts","detectNetwork","curAccount","registerNewWalletAddress","on","_this","getTokenStore","clearCachedTokens","enrichTokenLookupDataOnChainTokens","disconnectWallet","_chainId","emitNetworkChange","reason","indexOf","window","ethereum","enable","registerProvider","getWalletConnectProviderInstance","walletConnect","Promise","resolve","reject","connector","err","payload","then","catch","e","walletConnectProvider","getWalletConnectV2ProviderInstance","universalWalletConnect","uri","QRCodeModal","default","open","getUi","showError","connect","namespaces","eip155","methods","chains","WC_V2_CHAINS","events","rpcMap","CUSTOM_RPCS_FOR_WC_V2","pairingTopic","close","getTorusProviderInstance","torus","init","login","solana","accountAddress","publicKey","toBase58","getSafeConnectProvider","initSafeConnect","fcl","currentUser","addr","ui","dismissLoader","updateUI","error","flowProvider","fcl_1","getFlowProvider","subscribe","flowSubscribe","authenticate","e_2","undefined","SafeConnectProvider"],"sourceRoot":""}