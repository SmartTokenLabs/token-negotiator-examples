{"version":3,"file":"static/js/284.8d2e8827.chunk.js","mappings":"+/CAiBA,aASC,WAAYA,EAAgBC,GAL5B,KAAAC,YAAqC,CAAC,EAMrCC,KAAKH,OAASA,EACdG,KAAKF,mBAAqBA,CAC1B,CAyQF,OAvQCG,EAAAA,UAAAA,gBAAAA,WAEC,IAAIC,EAA0C,CAAC,EAE/C,IAAK,IAAIC,KAAWH,KAAKD,YAAY,CACpC,IAAIK,EAAMJ,KAAKD,YAAYI,GAE3BD,EAAiBC,GAAW,CAC3BA,QAASC,EAAID,QACbE,QAASD,EAAIC,QACbC,aAAcF,EAAIE,aAClBC,WAAYH,EAAIG,WAGjB,CAEDC,aAAaC,QAAQR,EAAmBS,kBAAmBC,KAAKC,UAAUV,GAE1E,EAEDD,EAAAA,UAAAA,oBAAAA,SAAoBE,GACnB,OACCU,OAAOC,KAAKd,KAAKD,aAAagB,QAC9BZ,GAEAH,KAAKH,OAAOmB,YAAYC,4BAA4BjB,KAAKD,YAAYI,EAAQe,sBACtElB,KAAKD,YAAYI,EAAQe,sBAEzB,IAER,EAEDjB,EAAAA,UAAAA,kBAAAA,WACCD,KAAKD,YAAc,CAAC,EACpBS,aAAaW,WAAWlB,EAAmBS,mBAC3CF,aAAaW,WAAW,gBACxB,EAEKlB,EAAAA,UAAAA,gBAAN,W,8GAIC,KAFImB,EAAOZ,aAAaa,QAAQpB,EAAmBS,oBAExC,UAIX,KAFIY,EAAQX,KAAKY,MAAMH,IAEX,U,cAEQE,EAAAA,EAAAA,KAAAA,G,yDAEfE,EAAaF,EAAMnB,G,iBAGtB,O,sBAAA,GAAMH,KAAKyB,YAAYD,EAAWlB,cAAc,I,cAAhDoB,EAAAA,O,+BAEAC,QAAQC,IAAI,0BAA4BC,EAAEC,gBACnCR,EAAMnB,GACbH,KAAK+B,kBACL/B,KAAKgC,oBAAoB7B,G,qDAG3B,EAEKF,EAAAA,UAAAA,YAAN,SAAoBgC,EAAoBC,G,YAAA,IAAAA,IAAAA,GAAsB,G,yFAE7D,IAAID,EAAY,MAAM,IAAIE,MAAM,iD,OAE7BnC,KAAKiC,GAGS,GAAMjC,KAAKiC,GAAwCC,IAHjE,M,OAWF,OARM/B,EAAUiC,EAAAA,QAEhBC,EAAAA,EAAAA,IAAO,EAAG,UAAWlC,GAErBH,KAAK+B,kBAEL/B,KAAKgC,oBAAoB7B,GAElB,CAAP,EAAOA,G,OAIP,MAAM,IAAIgC,MAAM,yB,MAIjB,EAEKlC,EAAAA,UAAAA,YAAN,SAAkBE,EAAiB2B,G,gGAM3B,OAJHQ,EAAWtC,KAAKuC,kBAAkBpC,GAI/B,GAFMmC,EAASE,UAAUrC,GAEZsC,YAAYX,I,OAAhC,MAAO,CAAP,EAAOM,EAAAA,Q,MAEP,EAEDnC,EAAAA,UAAAA,kBAAAA,SAAkBE,G,MAIjB,GAFAA,EAAUA,EAAQuC,gBAEY,QAAzB,EAAA1C,KAAKD,YAAYI,UAAQiC,IAAAA,OAAA,EAAAA,EAAEE,UAC/B,MAAM,IAAIH,MAAM,yCAEjB,OAAOnC,KAAKD,YAAYI,GAASmC,QACjC,EAEDrC,EAAAA,UAAAA,uBAAAA,WACC,OAAOY,OAAO8B,OAAO3C,KAAKD,YAC1B,EAEDE,EAAAA,UAAAA,yBAAAA,SAA2BE,EAAiBE,EAAwBC,EAAsBgC,EAAe/B,GAIxG,YAJwG,IAAAA,IAAAA,EAAa,OAErHP,KAAKD,YAAYI,EAAQuC,eAAiB,CAAEvC,QAAO,EAAEE,QAAO,EAAEC,aAAY,EAAEgC,SAAQ,EAAE/B,WAAU,GAEzFJ,CACP,EAEaF,EAAAA,UAAAA,iBAAd,SAA+BqC,EAAyCM,G,2GAEtD,SAAMN,EAASO,gB,OACf,OADXC,EAAWV,EAAAA,OACA,GAAME,EAASS,iB,OAEhC,GAFM1C,EAAW+B,EAAAA,OAAgC/B,QAEzB,IAApByC,EAAS/B,OACZ,MAAM,IAAIoB,MAAM,yCA6BjB,OA1BIa,EAAaF,EAAS,GAE1B9C,KAAKiD,yBAAyBD,EAAY3C,EAASuC,EAAcN,GAGjEA,EAASA,SAASY,GAAG,mBAAmB,SAACJ,GAEpCE,IAAeF,EAAS,KAG5BnB,QAAQC,IAAI,oBAAsBkB,EAAS,WAEpCK,EAAKpD,YAAYiD,EAAWN,eAEnCM,EAAaF,EAAS,GAEtBK,EAAKF,yBAAyBD,EAAY3C,EAASuC,EAAcN,GAEjEa,EAAKpB,kBAELoB,EAAKnB,oBAAoBgB,GAEzBG,EAAKtD,OAAOuD,gBAAgBC,oBAC5BF,EAAKtD,OAAOyD,qCACZ,IAEM,CAAP,EAAOR,EAAS,I,MAChB,EAEK7C,EAAAA,UAAAA,SAAN,SAAgBiC,G,uGAEfG,EAAAA,EAAAA,IAAO,EAAG,oBAEqB,qBAApBkB,OAAOC,SAAd,MAEH,GAAMD,OAAOC,SAASC,U,OAItB,OAJArB,EAAAA,OAEME,EAAW,IAAIoB,EAAAA,EAA8BH,OAAOC,UAEnD,CAAP,EAAOxD,KAAK2D,iBAAiBrB,EAAU,a,OAIvC,MAAM,IAAIH,MAAM,kF,MAIjB,EAEKlC,EAAAA,UAAAA,cAAN,SAAqBiC,G,uGAIU,OAF9BG,EAAAA,EAAAA,IAAO,EAAG,0BAEoB,GAAM,iE,OAEd,SAFQD,EAAAA,OAEoBwB,iCAAiC1B,I,OAEnF,OAFM2B,EAAgBzB,EAAAA,OAEf,CAAP,EAAO,IAAI0B,SAAQ,SAACC,EAASC,GAExB9B,GACH2B,EAAcI,UAAUf,GAAG,eAAe,SAACgB,EAAKC,GAC/CH,EAAO,IAAI7B,MAAM,sBACjB,IAGF0B,EAAcJ,SAASW,MAAK,WAC3B,IAAM9B,EAAW,IAAIoB,EAAAA,EAA8BG,GAEnDE,EAAQZ,EAAKQ,iBAAiBrB,EAAU,iBACxC,IAAE+B,OAAM,SAACC,GAAM,OAAAN,EAAOM,EAAE,GAEzB,K,MAED,EAEKrE,EAAAA,UAAAA,MAAN,SAAaiC,G,kGAEU,SAAM,iE,OAEd,SAFQE,EAAAA,OAEYmC,4B,OAElC,UAFMC,EAAQpC,EAAAA,QAEFqC,Q,OAEZ,OAFArC,EAAAA,OAEA,GAAMoC,EAAME,S,OAIZ,OAJAtC,EAAAA,OAEME,EAAW,IAAIoB,EAAAA,EAA8Bc,EAAMlC,UAElD,CAAP,EAAOtC,KAAK2D,iBAAiBrB,EAAU,U,MAEvC,EAEKrC,EAAAA,UAAAA,QAAN,W,yGAECoC,EAAAA,EAAAA,IAAO,EAAG,mBAEmB,qBAAlBkB,OAAOoB,OAAd,MAEgB,GAAMpB,OAAOoB,OAAOC,W,OAKvC,OALMpD,EAAaY,EAAAA,OAEbyC,EAAyBrD,EAAWsD,UAAUC,WAG7C,CAAP,EAAO/E,KAAKiD,yBAAyB4B,EAAgB,eAAgB,UAAWtB,OAAOoB,OAAQ,W,OAI/F,MAAM,IAAIxC,MAAM,kF,MAIjB,EAEKlC,EAAAA,UAAAA,YAAN,W,kGAIkB,OAFjBoC,EAAAA,EAAAA,IAAO,EAAG,uBAEO,GAAMrC,KAAKgF,0B,OAEZ,UAFV1C,EAAWF,EAAAA,QAEc6C,mB,OAI/B,OAJM9E,EAAUiC,EAAAA,OAEhBpC,KAAKiD,yBAAyB9C,EAAS,EAAG,cAAemC,GAElD,CAAP,EAAOnC,G,MACP,EAEDF,EAAAA,UAAAA,qBAAAA,WACC,YAAmCiF,IAA5BlF,KAAKF,kBACZ,EAEKG,EAAAA,UAAAA,uBAAN,W,0FAE+B,SAAM,yC,OAEpC,MAAO,CAAP,EAAO,IAFAkF,EAAuB/C,EAAAA,OAAqC+C,qBAEpCnF,KAAKH,OAAOuF,QAASpF,KAAKF,qB,MACzD,EAlRcG,EAAAA,kBAAoB,wBAmRpC,CAAC,CArRD,GAuRA,S","sources":["../../../token-negotiator/src/wallet/Web3WalletProvider.ts"],"sourcesContent":["import { ethers } from \"ethers\";\nimport { logger } from \"../utils\";\nimport {SafeConnectOptions} from \"./SafeConnectProvider\";\nimport {Client} from \"../client\";\n\ninterface WalletConnectionState {\n\t[index: string]: WalletConnection\n}\n\ninterface WalletConnection {\n\taddress: string,\n\tchainId: number|string,\n\tproviderType: string,\n\tblockchain: string,\n\tprovider?: ethers.providers.Web3Provider,\n}\n\nexport class Web3WalletProvider {\n\n\tprivate static LOCAL_STORAGE_KEY = \"tn-wallet-connections\";\n\n\tconnections: WalletConnectionState = {};\n\n\tsafeConnectOptions?: SafeConnectOptions;\n\tclient: Client;\n\n\tconstructor(client: Client, safeConnectOptions?: SafeConnectOptions) {\n\t\tthis.client = client;\n\t\tthis.safeConnectOptions = safeConnectOptions;\n\t}\n\n\tsaveConnections(){\n\n\t\tlet savedConnections: WalletConnectionState = {};\n\n\t\tfor (let address in this.connections){\n\t\t\tlet con = this.connections[address];\n\n\t\t\tsavedConnections[address] = {\n\t\t\t\taddress: con.address,\n\t\t\t\tchainId: con.chainId,\n\t\t\t\tproviderType: con.providerType,\n\t\t\t\tblockchain: con.blockchain\n\t\t\t};\n\t\t\t\n\t\t}\n\n\t\tlocalStorage.setItem(Web3WalletProvider.LOCAL_STORAGE_KEY, JSON.stringify(savedConnections));\n\n\t}\n\n\temitSavedConnection(address: string) {\n\t\tif(\n\t\t\tObject.keys(this.connections).length &&\n\t\t\taddress\n\t\t) {\n\t\t\tthis.client.eventSender.emitConnectedWalletInstance(this.connections[address.toLocaleLowerCase()]);\n\t\t\treturn this.connections[address.toLocaleLowerCase()];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tdeleteConnections(){\n\t\tthis.connections = {};\n\t\tlocalStorage.removeItem(Web3WalletProvider.LOCAL_STORAGE_KEY);\n\t\tlocalStorage.removeItem(\"walletconnect\");\n\t}\n\n\tasync loadConnections(){\n\n\t\tlet data = localStorage.getItem(Web3WalletProvider.LOCAL_STORAGE_KEY);\n\n\t\tif (!data) return;\n\n\t\tlet state = JSON.parse(data);\n\n\t\tif (!state) return;\n\n\t\tfor (let address in state){\n\n\t\t\tlet connection = state[address];\n\n\t\t\ttry {\n\t\t\t\tawait this.connectWith(connection.providerType, true);\n\t\t\t} catch(e){\n\t\t\t\tconsole.log(\"Wallet couldn't connect\" + e.message);\n\t\t\t\tdelete state[address];\n\t\t\t\tthis.saveConnections();\n\t\t\t\tthis.emitSavedConnection(address);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync connectWith ( walletType: string, checkConnectionOnly = false ) {\n\n\t\tif(!walletType) throw new Error('Please provide a Wallet type to connect with.');\n\n\t\tif(this[walletType as keyof Web3WalletProvider]) {\n\n\t\t\t// @ts-ignore\n\t\t\tconst address = await this[walletType as keyof Web3WalletProvider](checkConnectionOnly);\n\n\t\t\tlogger(2, 'address', address);\n\n\t\t\tthis.saveConnections();\n\n\t\t\tthis.emitSavedConnection(address);\n\n\t\t\treturn address;\n             \n\t\t} else {\n\n\t\t\tthrow new Error('Wallet type not found');\n\n\t\t}\n\n\t}\n\n\tasync signMessage(address: string, message: string) {\n\n\t\tlet provider = this.getWalletProvider(address);\n\n\t\tlet signer = provider.getSigner(address);\n\n\t\treturn await signer.signMessage(message);\n\n\t}\n\n\tgetWalletProvider(address: string) {\n\n\t\taddress = address.toLowerCase();\n\n\t\tif (!this.connections[address]?.provider)\n\t\t\tthrow new Error(\"Wallet provider not found for address\");\n\n\t\treturn this.connections[address].provider;\n\t}\n\n\tgetConnectedWalletData() {\n\t\treturn Object.values(this.connections);\n\t}\n\n\tregisterNewWalletAddress ( address: string, chainId: number|string, providerType: string, provider: any, blockchain = 'evm' ) {\n\n\t\tthis.connections[address.toLowerCase()] = { address, chainId, providerType, provider, blockchain };\n\n\t\treturn address;\n\t}\n\n\tprivate async registerProvider(provider: ethers.providers.Web3Provider, providerName: string){\n\n\t\tconst accounts = await provider.listAccounts();\n\t\tconst chainId = (await provider.detectNetwork()).chainId;\n\n\t\tif (accounts.length === 0){\n\t\t\tthrow new Error(\"No accounts found via wallet-connect.\");\n\t\t}\n\n\t\tlet curAccount = accounts[0];\n\n\t\tthis.registerNewWalletAddress(curAccount, chainId, providerName, provider);\n\n\t\t// @ts-ignore\n\t\tprovider.provider.on(\"accountsChanged\", (accounts) => {\n\n\t\t\tif (curAccount === accounts[0])\n\t\t\t\treturn;\n\n\t\t\tconsole.log(\"Account changed: \" + accounts[0]);\n\n\t\t\tdelete this.connections[curAccount.toLowerCase()];\n\n\t\t\tcurAccount = accounts[0];\n\n\t\t\tthis.registerNewWalletAddress(curAccount, chainId, providerName, provider);\n\n\t\t\tthis.saveConnections();\n\n\t\t\tthis.emitSavedConnection(curAccount);\n\n\t\t\tthis.client.getTokenStore().clearCachedTokens();\n\t\t\tthis.client.enrichTokenLookupDataOnChainTokens();\n\t\t});\n\n\t\treturn accounts[0];\n\t}\n\n\tasync MetaMask (checkConnectionOnly: boolean) {\n\n\t\tlogger(2, 'connect MetaMask');\n      \n\t\tif (typeof window.ethereum !== 'undefined') {\n\n\t\t\tawait window.ethereum.enable(); // fall back may be needed for FF to open Extension Prompt.\n\n\t\t\tconst provider = new ethers.providers.Web3Provider(window.ethereum);\n\n\t\t\treturn this.registerProvider(provider, \"MetaMask\");\n\n\t\t} else {\n\n\t\t\tthrow new Error(\"MetaMask is not available. Please check the extension is supported and active.\");\n\n\t\t}\n        \n\t}\n\n\tasync WalletConnect (checkConnectionOnly: boolean) {\n\n\t\tlogger(2, 'connect Wallet Connect');\n\n\t\tconst walletConnectProvider = await import(\"./WalletConnectProvider\");\n\n\t\tconst walletConnect = await walletConnectProvider.getWalletConnectProviderInstance(checkConnectionOnly);\n\n\t\treturn new Promise((resolve, reject) => {\n\n\t\t\tif (checkConnectionOnly){\n\t\t\t\twalletConnect.connector.on(\"display_uri\", (err, payload) => {\n\t\t\t\t\treject(new Error(\"Connection expired\"));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\twalletConnect.enable().then(() => {\n\t\t\t\tconst provider = new ethers.providers.Web3Provider(walletConnect);\n\n\t\t\t\tresolve(this.registerProvider(provider, \"WalletConnect\"));\n\t\t\t}).catch((e) => reject(e));\n\n\t\t})\n\n\t}\n\n\tasync Torus (checkConnectionOnly: boolean) {\n\n\t\tconst TorusProvider = await import(\"./TorusProvider\");\n\n\t\tconst torus = await TorusProvider.getTorusProviderInstance();\n        \n\t\tawait torus.init();\n\n\t\tawait torus.login();\n\n\t\tconst provider = new ethers.providers.Web3Provider(torus.provider);\n\n\t\treturn this.registerProvider(provider, \"Torus\");\n\n\t}\n\n\tasync Phantom () {\n\n\t\tlogger(2, 'connect Phantom');\n\n\t\tif (typeof window.solana !== 'undefined') {\n\n\t\t\tconst connection = await window.solana.connect();\n\n\t\t\tconst accountAddress: string = connection.publicKey.toBase58();\n\n\t\t\t// mainnet-beta,\n\t\t\treturn this.registerNewWalletAddress(accountAddress, \"mainnet-beta\", 'phantom', window.solana, 'solana');\n\n\t\t} else {\n\n\t\t\tthrow new Error(\"MetaMask is not available. Please check the extension is supported and active.\");\n\n\t\t}\n\n\t}\n\n\tasync SafeConnect(){\n\n\t\tlogger(2, 'connect SafeConnect');\n\n\t\tconst provider = await this.getSafeConnectProvider();\n\n\t\tconst address = await provider.initSafeConnect();\n\n\t\tthis.registerNewWalletAddress(address, 1, \"SafeConnect\", provider);\n\n\t\treturn address;\n\t}\n\n\tsafeConnectAvailable(){\n\t\treturn this.safeConnectOptions !== undefined;\n\t}\n\n\tasync getSafeConnectProvider(){\n\n\t\tconst {SafeConnectProvider} = await import(\"./SafeConnectProvider\");\n\n\t\treturn new SafeConnectProvider(this.client.getUi(), this.safeConnectOptions);\n\t}\n}\n\nexport default Web3WalletProvider;\n"],"names":["client","safeConnectOptions","connections","this","Web3WalletProvider","savedConnections","address","con","chainId","providerType","blockchain","localStorage","setItem","LOCAL_STORAGE_KEY","JSON","stringify","Object","keys","length","eventSender","emitConnectedWalletInstance","toLocaleLowerCase","removeItem","data","getItem","state","parse","connection","connectWith","_c","console","log","e_1","message","saveConnections","emitSavedConnection","walletType","checkConnectionOnly","Error","_a","logger","provider","getWalletProvider","getSigner","signMessage","toLowerCase","values","providerName","listAccounts","accounts","detectNetwork","curAccount","registerNewWalletAddress","on","_this","getTokenStore","clearCachedTokens","enrichTokenLookupDataOnChainTokens","window","ethereum","enable","ethers","registerProvider","getWalletConnectProviderInstance","walletConnect","Promise","resolve","reject","connector","err","payload","then","catch","e","getTorusProviderInstance","torus","init","login","solana","connect","accountAddress","publicKey","toBase58","getSafeConnectProvider","initSafeConnect","undefined","SafeConnectProvider","getUi"],"sourceRoot":""}