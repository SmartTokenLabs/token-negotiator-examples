"use strict";

(self.webpackChunktoken_overlay_website = self.webpackChunktoken_overlay_website || []).push([ [ 308 ], {
  8403: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Web3WalletProvider\": () => (/* binding */ Web3WalletProvider),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1023);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(241);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6677);\n/* provided dependency */ var console = __webpack_require__(5108);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass Web3WalletProvider {\n    constructor(client, walletOptions, safeConnectOptions) {\n        this.client = client;\n        this.walletOptions = walletOptions;\n        this.safeConnectOptions = safeConnectOptions;\n        this.connections = {};\n    }\n    saveConnections() {\n        let savedConnections = {};\n        for (let address in this.connections) {\n            let con = this.connections[address];\n            savedConnections[address] = {\n                address: con.address,\n                chainId: con.chainId,\n                providerType: con.providerType,\n                blockchain: con.blockchain,\n            };\n        }\n        localStorage.setItem(Web3WalletProvider.LOCAL_STORAGE_KEY, JSON.stringify(savedConnections));\n    }\n    emitSavedConnection(address) {\n        if (Object.keys(this.connections).length && address) {\n            this.client.eventSender('connected-wallet', this.connections[address.toLocaleLowerCase()]);\n            return this.connections[address.toLocaleLowerCase()];\n        }\n        else {\n            return null;\n        }\n    }\n    emitNetworkChange(chainId) {\n        if (chainId) {\n            this.client.eventSender('network-change', chainId);\n            return chainId;\n        }\n    }\n    deleteConnections() {\n        this.connections = {};\n        localStorage.removeItem(Web3WalletProvider.LOCAL_STORAGE_KEY);\n        localStorage.removeItem('walletconnect');\n        sessionStorage.removeItem('CURRENT_USER');\n    }\n    loadConnections() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let data = localStorage.getItem(Web3WalletProvider.LOCAL_STORAGE_KEY);\n            if (!data)\n                return;\n            let state = JSON.parse(data);\n            if (!state)\n                return;\n            for (let address in state) {\n                let connection = state[address];\n                try {\n                    yield this.connectWith(connection.providerType, true);\n                }\n                catch (e) {\n                    console.log(\"Wallet couldn't connect: \" + e.message);\n                    delete state[address];\n                    this.saveConnections();\n                    this.emitSavedConnection(address);\n                }\n            }\n        });\n    }\n    connectWith(walletType, checkConnectionOnly = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!walletType)\n                throw new Error('Please provide a Wallet type to connect with.');\n            if (this[walletType]) {\n                const address = yield this[walletType](checkConnectionOnly);\n                (0,_utils__WEBPACK_IMPORTED_MODULE_0__/* .logger */ .kg)(2, 'address', address);\n                this.saveConnections();\n                this.emitSavedConnection(address);\n                return address;\n            }\n            else {\n                throw new Error('Wallet type not found');\n            }\n        });\n    }\n    signMessage(address, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let provider = this.getWalletProvider(address);\n            let signer = provider.getSigner(address);\n            return yield signer.signMessage(message);\n        });\n    }\n    getWalletProvider(address) {\n        var _a;\n        address = address.toLowerCase();\n        if (!((_a = this.connections[address]) === null || _a === void 0 ? void 0 : _a.provider))\n            throw new Error('Wallet provider not found for address');\n        return this.connections[address].provider;\n    }\n    getConnectedWalletData() {\n        return Object.values(this.connections);\n    }\n    registerNewWalletAddress(address, chainId, providerType, provider, blockchain = 'evm') {\n        this.connections[address.toLowerCase()] = { address, chainId, providerType, provider, blockchain, ethers: ethers__WEBPACK_IMPORTED_MODULE_1__ };\n        return address;\n    }\n    registerProvider(provider, providerName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accounts = yield provider.listAccounts();\n            const chainId = (yield provider.detectNetwork()).chainId;\n            if (accounts.length === 0) {\n                throw new Error('No accounts found via wallet-connect.');\n            }\n            let curAccount = accounts[0];\n            this.registerNewWalletAddress(curAccount, chainId, providerName, provider);\n            provider.provider.on('accountsChanged', (accounts) => {\n                if (!accounts || accounts.length === 0) {\n                    this.client.disconnectWallet();\n                    return;\n                }\n                if (curAccount === accounts[0])\n                    return;\n                delete this.connections[curAccount.toLowerCase()];\n                curAccount = accounts[0];\n                this.registerNewWalletAddress(curAccount, chainId, providerName, provider);\n                this.saveConnections();\n                this.emitSavedConnection(curAccount);\n                this.client.getTokenStore().clearCachedTokens();\n                this.client.enrichTokenLookupDataOnChainTokens();\n            });\n            provider.provider.on('chainChanged', (_chainId) => {\n                this.registerNewWalletAddress(accounts[0], _chainId, providerName, provider);\n                this.saveConnections();\n                this.emitNetworkChange(_chainId);\n            });\n            provider.provider.on('disconnect', (reason) => {\n                if ((reason === null || reason === void 0 ? void 0 : reason.message) && reason.message.indexOf('MetaMask: Disconnected from chain') > -1)\n                    return;\n                this.client.disconnectWallet();\n            });\n            return accounts[0];\n        });\n    }\n    MetaMask(checkConnectionOnly) {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_0__/* .logger */ .kg)(2, 'connect MetaMask');\n            if (typeof window.ethereum !== 'undefined') {\n                yield window.ethereum.enable();\n                const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__/* .Web3Provider */ .Q(window.ethereum, 'any');\n                return this.registerProvider(provider, 'MetaMask');\n            }\n            else {\n                throw new Error('MetaMask is not available. Please check the extension is supported and active.');\n            }\n        });\n    }\n    WalletConnect(checkConnectionOnly) {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_0__/* .logger */ .kg)(2, 'connect Wallet Connect');\n            const walletConnectProvider = yield Promise.all(/* import() */[__webpack_require__.e(418), __webpack_require__.e(444), __webpack_require__.e(883)]).then(__webpack_require__.bind(__webpack_require__, 5444));\n            const walletConnect = yield walletConnectProvider.getWalletConnectProviderInstance(checkConnectionOnly);\n            return new Promise((resolve, reject) => {\n                if (checkConnectionOnly) {\n                    walletConnect.connector.on('display_uri', (err, payload) => {\n                        reject(new Error('Connection expired'));\n                    });\n                }\n                walletConnect\n                    .enable()\n                    .then(() => {\n                    const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__/* .Web3Provider */ .Q(walletConnect, 'any');\n                    resolve(this.registerProvider(provider, 'WalletConnect'));\n                })\n                    .catch((e) => reject(e));\n            });\n        });\n    }\n    WalletConnectV2(checkConnectionOnly) {\n        var _a, _b, _c, _d, _e, _f;\n        return __awaiter(this, void 0, void 0, function* () {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_0__/* .logger */ .kg)(2, 'connect Wallet Connect V2');\n            const walletConnectProvider = yield Promise.all(/* import() */[__webpack_require__.e(418), __webpack_require__.e(403)]).then(__webpack_require__.bind(__webpack_require__, 6418));\n            const universalWalletConnect = yield walletConnectProvider.getWalletConnectV2ProviderInstance();\n            let QRCodeModal;\n            universalWalletConnect.on('display_uri', (uri) => __awaiter(this, void 0, void 0, function* () {\n                console.log('EVENT', 'QR Code Modal open');\n                QRCodeModal = (yield __webpack_require__.e(/* import() */ 337).then(__webpack_require__.t.bind(__webpack_require__, 4337, 23))).default;\n                QRCodeModal.open(uri, () => {\n                    this.client.getUi().showError('User closed modal');\n                });\n            }));\n            universalWalletConnect.on('session_delete', ({ id, topic }) => {\n                console.log('WC V2 EVENT', 'session_deleted');\n                this.client.disconnectWallet();\n            });\n            if (!checkConnectionOnly) {\n                let pairing;\n                yield universalWalletConnect.connect({\n                    namespaces: {\n                        eip155: {\n                            methods: ['eth_sendTransaction', 'eth_signTransaction', 'eth_sign', 'personal_sign', 'eth_signTypedData'],\n                            chains: (_c = (_b = (_a = this.walletOptions) === null || _a === void 0 ? void 0 : _a.walletConnectV2) === null || _b === void 0 ? void 0 : _b.chains) !== null && _c !== void 0 ? _c : walletConnectProvider.WC_V2_DEFAULT_CHAINS,\n                            events: ['chainChanged', 'accountsChanged'],\n                            rpcMap: (_f = (_e = (_d = this.walletOptions) === null || _d === void 0 ? void 0 : _d.walletConnectV2) === null || _e === void 0 ? void 0 : _e.rpcMap) !== null && _f !== void 0 ? _f : walletConnectProvider.WC_DEFAULT_RPC_MAP,\n                        },\n                    },\n                    pairingTopic: pairing === null || pairing === void 0 ? void 0 : pairing.topic,\n                });\n                QRCodeModal.close();\n            }\n            return new Promise((resolve, reject) => {\n                universalWalletConnect\n                    .enable()\n                    .then(() => {\n                    const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__/* .Web3Provider */ .Q(universalWalletConnect, 'any');\n                    resolve(this.registerProvider(provider, 'WalletConnectV2'));\n                })\n                    .catch((e) => {\n                    reject(e);\n                });\n            });\n        });\n    }\n    Torus(checkConnectionOnly) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const TorusProvider = yield __webpack_require__.e(/* import() */ 681).then(__webpack_require__.bind(__webpack_require__, 4681));\n            const torus = yield TorusProvider.getTorusProviderInstance();\n            yield torus.init();\n            yield torus.login();\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__/* .Web3Provider */ .Q(torus.provider, 'any');\n            return this.registerProvider(provider, 'Torus');\n        });\n    }\n    Phantom(checkConnectionOnly) {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_0__/* .logger */ .kg)(2, 'connect Phantom');\n            if (typeof window.solana !== 'undefined') {\n                const connection = yield window.solana.connect();\n                const accountAddress = connection.publicKey.toBase58();\n                return this.registerNewWalletAddress(accountAddress, 'mainnet-beta', 'phantom', window.solana, 'solana');\n            }\n            else {\n                throw new Error('Phantom is not available. Please check the extension is supported and active.');\n            }\n        });\n    }\n    SafeConnect(checkConnectionOnly) {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_0__/* .logger */ .kg)(2, 'connect SafeConnect');\n            const provider = yield this.getSafeConnectProvider();\n            const address = yield provider.initSafeConnect();\n            this.registerNewWalletAddress(address, 1, 'SafeConnect', provider);\n            return address;\n        });\n    }\n    Flow(checkConnectionOnly) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const flowProvider = yield __webpack_require__.e(/* import() */ 623).then(__webpack_require__.bind(__webpack_require__, 9623));\n            const fcl = flowProvider.getFlowProvider();\n            yield fcl.currentUser.authenticate();\n            let currentUser = yield fcl.currentUser.snapshot();\n            if (!currentUser.addr)\n                throw new Error('Failed to connect Flow wallet');\n            this.registerNewWalletAddress(currentUser.addr, 1, 'flow', fcl);\n            return currentUser.addr;\n        });\n    }\n    safeConnectAvailable() {\n        return this.safeConnectOptions !== undefined;\n    }\n    getSafeConnectProvider() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { SafeConnectProvider } = yield Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 7393));\n            return new SafeConnectProvider(this.client.getUi(), this.safeConnectOptions);\n        });\n    }\n}\nWeb3WalletProvider.LOCAL_STORAGE_KEY = 'tn-wallet-connections';\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Web3WalletProvider);\n//# sourceMappingURL=Web3WalletProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUdBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0IsUUFBUSx5RkFBK0I7QUFDakY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsa0JBQWtCLEVBQUM7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2tlbi1vdmVybGF5LXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvQHRva2Vuc2NyaXB0L3Rva2VuLW5lZ290aWF0b3IvZGlzdC93YWxsZXQvV2ViM1dhbGxldFByb3ZpZGVyLmpzPzUzNzkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMnO1xuZXhwb3J0IGNsYXNzIFdlYjNXYWxsZXRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50LCB3YWxsZXRPcHRpb25zLCBzYWZlQ29ubmVjdE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMud2FsbGV0T3B0aW9ucyA9IHdhbGxldE9wdGlvbnM7XG4gICAgICAgIHRoaXMuc2FmZUNvbm5lY3RPcHRpb25zID0gc2FmZUNvbm5lY3RPcHRpb25zO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zID0ge307XG4gICAgfVxuICAgIHNhdmVDb25uZWN0aW9ucygpIHtcbiAgICAgICAgbGV0IHNhdmVkQ29ubmVjdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgYWRkcmVzcyBpbiB0aGlzLmNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBsZXQgY29uID0gdGhpcy5jb25uZWN0aW9uc1thZGRyZXNzXTtcbiAgICAgICAgICAgIHNhdmVkQ29ubmVjdGlvbnNbYWRkcmVzc10gPSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogY29uLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogY29uLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJUeXBlOiBjb24ucHJvdmlkZXJUeXBlLFxuICAgICAgICAgICAgICAgIGJsb2NrY2hhaW46IGNvbi5ibG9ja2NoYWluLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShXZWIzV2FsbGV0UHJvdmlkZXIuTE9DQUxfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHNhdmVkQ29ubmVjdGlvbnMpKTtcbiAgICB9XG4gICAgZW1pdFNhdmVkQ29ubmVjdGlvbihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmNvbm5lY3Rpb25zKS5sZW5ndGggJiYgYWRkcmVzcykge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuZXZlbnRTZW5kZXIoJ2Nvbm5lY3RlZC13YWxsZXQnLCB0aGlzLmNvbm5lY3Rpb25zW2FkZHJlc3MudG9Mb2NhbGVMb3dlckNhc2UoKV0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbnNbYWRkcmVzcy50b0xvY2FsZUxvd2VyQ2FzZSgpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXROZXR3b3JrQ2hhbmdlKGNoYWluSWQpIHtcbiAgICAgICAgaWYgKGNoYWluSWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50LmV2ZW50U2VuZGVyKCduZXR3b3JrLWNoYW5nZScsIGNoYWluSWQpO1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlQ29ubmVjdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMgPSB7fTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oV2ViM1dhbGxldFByb3ZpZGVyLkxPQ0FMX1NUT1JBR0VfS0VZKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3dhbGxldGNvbm5lY3QnKTtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSgnQ1VSUkVOVF9VU0VSJyk7XG4gICAgfVxuICAgIGxvYWRDb25uZWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oV2ViM1dhbGxldFByb3ZpZGVyLkxPQ0FMX1NUT1JBR0VfS0VZKTtcbiAgICAgICAgICAgIGlmICghZGF0YSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBmb3IgKGxldCBhZGRyZXNzIGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb24gPSBzdGF0ZVthZGRyZXNzXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3RXaXRoKGNvbm5lY3Rpb24ucHJvdmlkZXJUeXBlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXYWxsZXQgY291bGRuJ3QgY29ubmVjdDogXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGVbYWRkcmVzc107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2F2ZUNvbm5lY3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFNhdmVkQ29ubmVjdGlvbihhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0V2l0aCh3YWxsZXRUeXBlLCBjaGVja0Nvbm5lY3Rpb25Pbmx5ID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghd2FsbGV0VHlwZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgV2FsbGV0IHR5cGUgdG8gY29ubmVjdCB3aXRoLicpO1xuICAgICAgICAgICAgaWYgKHRoaXNbd2FsbGV0VHlwZV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpc1t3YWxsZXRUeXBlXShjaGVja0Nvbm5lY3Rpb25Pbmx5KTtcbiAgICAgICAgICAgICAgICBsb2dnZXIoMiwgJ2FkZHJlc3MnLCBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVDb25uZWN0aW9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFNhdmVkQ29ubmVjdGlvbihhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IHR5cGUgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduTWVzc2FnZShhZGRyZXNzLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgcHJvdmlkZXIgPSB0aGlzLmdldFdhbGxldFByb3ZpZGVyKGFkZHJlc3MpO1xuICAgICAgICAgICAgbGV0IHNpZ25lciA9IHByb3ZpZGVyLmdldFNpZ25lcihhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBzaWduZXIuc2lnbk1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRXYWxsZXRQcm92aWRlcihhZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCEoKF9hID0gdGhpcy5jb25uZWN0aW9uc1thZGRyZXNzXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3ZpZGVyKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IHByb3ZpZGVyIG5vdCBmb3VuZCBmb3IgYWRkcmVzcycpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uc1thZGRyZXNzXS5wcm92aWRlcjtcbiAgICB9XG4gICAgZ2V0Q29ubmVjdGVkV2FsbGV0RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5jb25uZWN0aW9ucyk7XG4gICAgfVxuICAgIHJlZ2lzdGVyTmV3V2FsbGV0QWRkcmVzcyhhZGRyZXNzLCBjaGFpbklkLCBwcm92aWRlclR5cGUsIHByb3ZpZGVyLCBibG9ja2NoYWluID0gJ2V2bScpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uc1thZGRyZXNzLnRvTG93ZXJDYXNlKCldID0geyBhZGRyZXNzLCBjaGFpbklkLCBwcm92aWRlclR5cGUsIHByb3ZpZGVyLCBibG9ja2NoYWluLCBldGhlcnMgfTtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfVxuICAgIHJlZ2lzdGVyUHJvdmlkZXIocHJvdmlkZXIsIHByb3ZpZGVyTmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSB5aWVsZCBwcm92aWRlci5saXN0QWNjb3VudHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSAoeWllbGQgcHJvdmlkZXIuZGV0ZWN0TmV0d29yaygpKS5jaGFpbklkO1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjb3VudHMgZm91bmQgdmlhIHdhbGxldC1jb25uZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGN1ckFjY291bnQgPSBhY2NvdW50c1swXTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJOZXdXYWxsZXRBZGRyZXNzKGN1ckFjY291bnQsIGNoYWluSWQsIHByb3ZpZGVyTmFtZSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgcHJvdmlkZXIucHJvdmlkZXIub24oJ2FjY291bnRzQ2hhbmdlZCcsIChhY2NvdW50cykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudHMgfHwgYWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50LmRpc2Nvbm5lY3RXYWxsZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VyQWNjb3VudCA9PT0gYWNjb3VudHNbMF0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jb25uZWN0aW9uc1tjdXJBY2NvdW50LnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgICAgIGN1ckFjY291bnQgPSBhY2NvdW50c1swXTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyTmV3V2FsbGV0QWRkcmVzcyhjdXJBY2NvdW50LCBjaGFpbklkLCBwcm92aWRlck5hbWUsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVDb25uZWN0aW9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFNhdmVkQ29ubmVjdGlvbihjdXJBY2NvdW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5nZXRUb2tlblN0b3JlKCkuY2xlYXJDYWNoZWRUb2tlbnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5lbnJpY2hUb2tlbkxvb2t1cERhdGFPbkNoYWluVG9rZW5zKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3ZpZGVyLnByb3ZpZGVyLm9uKCdjaGFpbkNoYW5nZWQnLCAoX2NoYWluSWQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyTmV3V2FsbGV0QWRkcmVzcyhhY2NvdW50c1swXSwgX2NoYWluSWQsIHByb3ZpZGVyTmFtZSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2F2ZUNvbm5lY3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0TmV0d29ya0NoYW5nZShfY2hhaW5JZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3ZpZGVyLnByb3ZpZGVyLm9uKCdkaXNjb25uZWN0JywgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgocmVhc29uID09PSBudWxsIHx8IHJlYXNvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVhc29uLm1lc3NhZ2UpICYmIHJlYXNvbi5tZXNzYWdlLmluZGV4T2YoJ01ldGFNYXNrOiBEaXNjb25uZWN0ZWQgZnJvbSBjaGFpbicpID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5kaXNjb25uZWN0V2FsbGV0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50c1swXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE1ldGFNYXNrKGNoZWNrQ29ubmVjdGlvbk9ubHkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxvZ2dlcigyLCAnY29ubmVjdCBNZXRhTWFzaycpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuZXRoZXJldW0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgd2luZG93LmV0aGVyZXVtLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5wcm92aWRlcnMuV2ViM1Byb3ZpZGVyKHdpbmRvdy5ldGhlcmV1bSwgJ2FueScpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyUHJvdmlkZXIocHJvdmlkZXIsICdNZXRhTWFzaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgY2hlY2sgdGhlIGV4dGVuc2lvbiBpcyBzdXBwb3J0ZWQgYW5kIGFjdGl2ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFdhbGxldENvbm5lY3QoY2hlY2tDb25uZWN0aW9uT25seSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbG9nZ2VyKDIsICdjb25uZWN0IFdhbGxldCBDb25uZWN0Jyk7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRDb25uZWN0UHJvdmlkZXIgPSB5aWVsZCBpbXBvcnQoJy4vV2FsbGV0Q29ubmVjdFByb3ZpZGVyJyk7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRDb25uZWN0ID0geWllbGQgd2FsbGV0Q29ubmVjdFByb3ZpZGVyLmdldFdhbGxldENvbm5lY3RQcm92aWRlckluc3RhbmNlKGNoZWNrQ29ubmVjdGlvbk9ubHkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tDb25uZWN0aW9uT25seSkge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRDb25uZWN0LmNvbm5lY3Rvci5vbignZGlzcGxheV91cmknLCAoZXJyLCBwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDb25uZWN0aW9uIGV4cGlyZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YWxsZXRDb25uZWN0XG4gICAgICAgICAgICAgICAgICAgIC5lbmFibGUoKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5wcm92aWRlcnMuV2ViM1Byb3ZpZGVyKHdhbGxldENvbm5lY3QsICdhbnknKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlZ2lzdGVyUHJvdmlkZXIocHJvdmlkZXIsICdXYWxsZXRDb25uZWN0JykpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4gcmVqZWN0KGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgV2FsbGV0Q29ubmVjdFYyKGNoZWNrQ29ubmVjdGlvbk9ubHkpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsb2dnZXIoMiwgJ2Nvbm5lY3QgV2FsbGV0IENvbm5lY3QgVjInKTtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldENvbm5lY3RQcm92aWRlciA9IHlpZWxkIGltcG9ydCgnLi9XYWxsZXRDb25uZWN0VjJQcm92aWRlcicpO1xuICAgICAgICAgICAgY29uc3QgdW5pdmVyc2FsV2FsbGV0Q29ubmVjdCA9IHlpZWxkIHdhbGxldENvbm5lY3RQcm92aWRlci5nZXRXYWxsZXRDb25uZWN0VjJQcm92aWRlckluc3RhbmNlKCk7XG4gICAgICAgICAgICBsZXQgUVJDb2RlTW9kYWw7XG4gICAgICAgICAgICB1bml2ZXJzYWxXYWxsZXRDb25uZWN0Lm9uKCdkaXNwbGF5X3VyaScsICh1cmkpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRVZFTlQnLCAnUVIgQ29kZSBNb2RhbCBvcGVuJyk7XG4gICAgICAgICAgICAgICAgUVJDb2RlTW9kYWwgPSAoeWllbGQgaW1wb3J0KCdAd2FsbGV0Y29ubmVjdC9xcmNvZGUtbW9kYWwnKSkuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICBRUkNvZGVNb2RhbC5vcGVuKHVyaSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5nZXRVaSgpLnNob3dFcnJvcignVXNlciBjbG9zZWQgbW9kYWwnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHVuaXZlcnNhbFdhbGxldENvbm5lY3Qub24oJ3Nlc3Npb25fZGVsZXRlJywgKHsgaWQsIHRvcGljIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV0MgVjIgRVZFTlQnLCAnc2Vzc2lvbl9kZWxldGVkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuZGlzY29ubmVjdFdhbGxldCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWNoZWNrQ29ubmVjdGlvbk9ubHkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFpcmluZztcbiAgICAgICAgICAgICAgICB5aWVsZCB1bml2ZXJzYWxXYWxsZXRDb25uZWN0LmNvbm5lY3Qoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlaXAxNTU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzOiBbJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLCAnZXRoX3NpZ25UcmFuc2FjdGlvbicsICdldGhfc2lnbicsICdwZXJzb25hbF9zaWduJywgJ2V0aF9zaWduVHlwZWREYXRhJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5zOiAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLndhbGxldE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53YWxsZXRDb25uZWN0VjIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jaGFpbnMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHdhbGxldENvbm5lY3RQcm92aWRlci5XQ19WMl9ERUZBVUxUX0NIQUlOUyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHM6IFsnY2hhaW5DaGFuZ2VkJywgJ2FjY291bnRzQ2hhbmdlZCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJwY01hcDogKF9mID0gKF9lID0gKF9kID0gdGhpcy53YWxsZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Qud2FsbGV0Q29ubmVjdFYyKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucnBjTWFwKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB3YWxsZXRDb25uZWN0UHJvdmlkZXIuV0NfREVGQVVMVF9SUENfTUFQLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFpcmluZ1RvcGljOiBwYWlyaW5nID09PSBudWxsIHx8IHBhaXJpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhaXJpbmcudG9waWMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgUVJDb2RlTW9kYWwuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdW5pdmVyc2FsV2FsbGV0Q29ubmVjdFxuICAgICAgICAgICAgICAgICAgICAuZW5hYmxlKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMucHJvdmlkZXJzLldlYjNQcm92aWRlcih1bml2ZXJzYWxXYWxsZXRDb25uZWN0LCAnYW55Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZWdpc3RlclByb3ZpZGVyKHByb3ZpZGVyLCAnV2FsbGV0Q29ubmVjdFYyJykpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFRvcnVzKGNoZWNrQ29ubmVjdGlvbk9ubHkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IFRvcnVzUHJvdmlkZXIgPSB5aWVsZCBpbXBvcnQoJy4vVG9ydXNQcm92aWRlcicpO1xuICAgICAgICAgICAgY29uc3QgdG9ydXMgPSB5aWVsZCBUb3J1c1Byb3ZpZGVyLmdldFRvcnVzUHJvdmlkZXJJbnN0YW5jZSgpO1xuICAgICAgICAgICAgeWllbGQgdG9ydXMuaW5pdCgpO1xuICAgICAgICAgICAgeWllbGQgdG9ydXMubG9naW4oKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5wcm92aWRlcnMuV2ViM1Byb3ZpZGVyKHRvcnVzLnByb3ZpZGVyLCAnYW55Jyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclByb3ZpZGVyKHByb3ZpZGVyLCAnVG9ydXMnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFBoYW50b20oY2hlY2tDb25uZWN0aW9uT25seSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbG9nZ2VyKDIsICdjb25uZWN0IFBoYW50b20nKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LnNvbGFuYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgd2luZG93LnNvbGFuYS5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudEFkZHJlc3MgPSBjb25uZWN0aW9uLnB1YmxpY0tleS50b0Jhc2U1OCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyTmV3V2FsbGV0QWRkcmVzcyhhY2NvdW50QWRkcmVzcywgJ21haW5uZXQtYmV0YScsICdwaGFudG9tJywgd2luZG93LnNvbGFuYSwgJ3NvbGFuYScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaGFudG9tIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBjaGVjayB0aGUgZXh0ZW5zaW9uIGlzIHN1cHBvcnRlZCBhbmQgYWN0aXZlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgU2FmZUNvbm5lY3QoY2hlY2tDb25uZWN0aW9uT25seSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbG9nZ2VyKDIsICdjb25uZWN0IFNhZmVDb25uZWN0Jyk7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuZ2V0U2FmZUNvbm5lY3RQcm92aWRlcigpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHByb3ZpZGVyLmluaXRTYWZlQ29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck5ld1dhbGxldEFkZHJlc3MoYWRkcmVzcywgMSwgJ1NhZmVDb25uZWN0JywgcHJvdmlkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBGbG93KGNoZWNrQ29ubmVjdGlvbk9ubHkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsb3dQcm92aWRlciA9IHlpZWxkIGltcG9ydCgnLi9GbG93UHJvdmlkZXInKTtcbiAgICAgICAgICAgIGNvbnN0IGZjbCA9IGZsb3dQcm92aWRlci5nZXRGbG93UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHlpZWxkIGZjbC5jdXJyZW50VXNlci5hdXRoZW50aWNhdGUoKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50VXNlciA9IHlpZWxkIGZjbC5jdXJyZW50VXNlci5zbmFwc2hvdCgpO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50VXNlci5hZGRyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbm5lY3QgRmxvdyB3YWxsZXQnKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJOZXdXYWxsZXRBZGRyZXNzKGN1cnJlbnRVc2VyLmFkZHIsIDEsICdmbG93JywgZmNsKTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50VXNlci5hZGRyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2FmZUNvbm5lY3RBdmFpbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVDb25uZWN0T3B0aW9ucyAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRTYWZlQ29ubmVjdFByb3ZpZGVyKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBTYWZlQ29ubmVjdFByb3ZpZGVyIH0gPSB5aWVsZCBpbXBvcnQoJy4vU2FmZUNvbm5lY3RQcm92aWRlcicpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTYWZlQ29ubmVjdFByb3ZpZGVyKHRoaXMuY2xpZW50LmdldFVpKCksIHRoaXMuc2FmZUNvbm5lY3RPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuV2ViM1dhbGxldFByb3ZpZGVyLkxPQ0FMX1NUT1JBR0VfS0VZID0gJ3RuLXdhbGxldC1jb25uZWN0aW9ucyc7XG5leHBvcnQgZGVmYXVsdCBXZWIzV2FsbGV0UHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWIzV2FsbGV0UHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8403\n");
  }
} ]);