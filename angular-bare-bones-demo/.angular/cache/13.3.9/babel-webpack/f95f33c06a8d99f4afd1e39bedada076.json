{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nimport { Buffer } from \"buffer\";\nvar displayDebugLevel;\nvar testsDisplayDebugLevel;\n\nif (process && process.env && process.env.DISPLAY_DEBUG_LEVEL) {\n  displayDebugLevel = parseInt(process.env.DISPLAY_DEBUG_LEVEL);\n} else if (window && window.DISPLAY_DEBUG_LEVEL) {\n  displayDebugLevel = parseInt(window.DISPLAY_DEBUG_LEVEL);\n}\n\nexport function logger(level) {\n  var args = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n\n  if (!displayDebugLevel || level > displayDebugLevel) return;\n  console.log.apply(console, __spreadArray([], __read(args), false));\n}\nexport var requiredParams = function (item, msg) {\n  if (!item) throw new Error(msg);\n};\nexport function uint8toBuffer(uint8) {\n  if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(uint8);\n  } else {\n    return uint8;\n  }\n}\nexport var compareObjects = function (o1, o2) {\n  var e_1, _a;\n\n  var keys1 = Object.keys(o1);\n  var keys2 = Object.keys(o2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  try {\n    for (var keys1_1 = __values(keys1), keys1_1_1 = keys1_1.next(); !keys1_1_1.done; keys1_1_1 = keys1_1.next()) {\n      var key = keys1_1_1.value;\n\n      if (typeof o2[key] === \"object\") {\n        if (JSON.stringify(o1[key]) !== JSON.stringify(o2[key])) {\n          return false;\n        }\n      } else if (o1[key] !== o2[key]) {\n        return false;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (keys1_1_1 && !keys1_1_1.done && (_a = keys1_1.return)) _a.call(keys1_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return true;\n};\nexport var base64ToUint8array = function (base64str) {\n  base64str = base64str.split('-').join('+').split('_').join('/').split('.').join('=');\n  return Uint8Array.from(Buffer.from(base64str, 'base64'));\n};\nexport var attachPostMessageListener = function (listener) {\n  if (window.addEventListener) {\n    window.addEventListener(\"message\", listener, false);\n  } else {\n    window.attachEvent(\"onmessage\", listener);\n  }\n};\nexport var removePostMessageListener = function (listener) {\n  if (window.removeEventListener) {\n    window.removeEventListener(\"message\", listener);\n  } else {\n    window.detachEvent(\"onmessage\", listener);\n  }\n}; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module"}