{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nimport { logger } from \"../utils\";\n\nvar TokenStore = function () {\n  function TokenStore(autoEnableTokens) {\n    this.currentIssuers = {};\n    this.tokens = {};\n    this.tokenLookup = {};\n    this.selectedTokens = {};\n    this.autoEnableTokens = autoEnableTokens;\n  }\n\n  TokenStore.prototype.updateIssuers = function (issuers) {\n    if (Object.keys(this.currentIssuers).length > 0) {\n      this.selectedTokens = {};\n    }\n\n    this.prePopulateTokenLookupStore(issuers);\n  };\n\n  TokenStore.prototype.hasOnChainTokens = function () {\n    for (var i in this.currentIssuers) {\n      if (this.currentIssuers[i]) return true;\n    }\n\n    return false;\n  };\n\n  TokenStore.prototype.getCurrentIssuers = function (onChainFilter) {\n    var current = {};\n\n    for (var collectionId in this.currentIssuers) {\n      if (onChainFilter === undefined || onChainFilter === this.currentIssuers[collectionId]) current[collectionId] = this.tokenLookup[collectionId];\n    }\n\n    return current;\n  };\n\n  TokenStore.prototype.getCurrentTokens = function (onChainFilter) {\n    var current = {};\n\n    for (var collectionId in this.currentIssuers) {\n      if (onChainFilter === undefined || onChainFilter === this.currentIssuers[collectionId]) current[collectionId] = this.tokens[collectionId];\n    }\n\n    return current;\n  };\n\n  TokenStore.prototype.hasUnloadedTokens = function () {\n    var e_1, _a;\n\n    try {\n      for (var _b = __values(Object.values(this.getCurrentTokens())), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var tokens = _c.value;\n        if (tokens.length === 0) return true;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return false;\n  };\n\n  TokenStore.prototype.getIssuerTokens = function (issuer) {\n    if (this.tokens[issuer]) return this.tokens[issuer];\n    return null;\n  };\n\n  TokenStore.prototype.setTokens = function (issuer, tokens) {\n    this.tokens[issuer] = tokens;\n    if (this.autoEnableTokens) this.selectedTokens[issuer] = {\n      tokens: tokens\n    };\n  };\n\n  TokenStore.prototype.getSelectedTokens = function () {\n    return this.selectedTokens;\n  };\n\n  TokenStore.prototype.setSelectedTokens = function (selectedTokens) {\n    this.selectedTokens = selectedTokens;\n  };\n\n  TokenStore.prototype.prePopulateTokenLookupStore = function (issuers) {\n    var _this = this;\n\n    var collectionIds = {};\n    issuers.forEach(function (issuer, i) {\n      if (!issuer.collectionID) return;\n      if (issuer.onChain === undefined) issuer.onChain = true;\n      issuer.collectionID = _this.formatCollectionID(issuer.collectionID);\n\n      if (collectionIds[issuer.collectionID] !== undefined) {\n        logger(1, \"duplicate collectionID key \".concat(issuer.collectionID, \", use unique keys per collection.\"));\n        return;\n      }\n\n      if (\"chain\" in issuer) issuer.chain = _this.formatCollectionChain(issuer.chain);\n\n      if (_this.tokens[issuer.collectionID] !== undefined) {\n        if (_this.autoEnableTokens && _this.tokens[issuer.collectionID].length) _this.selectedTokens[issuer.collectionID] = {\n          tokens: _this.tokens[issuer.collectionID]\n        };\n      } else {\n        _this.tokens[issuer.collectionID] = [];\n      }\n\n      if (!_this.tokenLookup[issuer.collectionID]) _this.updateTokenLookupStore(issuer.collectionID, issuer);\n      collectionIds[issuer.collectionID] = issuer.onChain;\n    });\n    this.currentIssuers = collectionIds;\n  };\n\n  TokenStore.prototype.updateTokenLookupStore = function (tokenKey, data) {\n    this.tokenLookup[tokenKey] = __assign(__assign({}, this.tokenLookup[tokenKey]), data);\n  };\n\n  TokenStore.prototype.formatCollectionChain = function (chain) {\n    return chain.toLowerCase();\n  };\n\n  TokenStore.prototype.formatCollectionID = function (collectionID) {\n    var formatedCollectionID = collectionID;\n\n    if (/[A-Z]+/g.test(collectionID) || /\\s+/g.test(collectionID)) {\n      formatedCollectionID = collectionID.replace(/\\s+/g, \"-\").toLowerCase();\n      logger(1, \"Token Negotiator: Spaces or capital letters found in collectionID definition \".concat(collectionID, \", this has been re-formatted to \").concat(formatedCollectionID));\n      collectionID = formatedCollectionID;\n    }\n\n    return collectionID;\n  };\n\n  return TokenStore;\n}();\n\nexport { TokenStore }; //# sourceMappingURL=tokenStore.js.map","map":null,"metadata":{},"sourceType":"module"}