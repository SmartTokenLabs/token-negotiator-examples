{"ast":null,"code":"import _asyncToGenerator from \"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { parsePersonalSign, parseTransactionData, convertArrayBufferToHex, convertHexToArrayBuffer, getClientMeta, payloadId, uuid, formatRpcError, parseWalletConnectUri, convertNumberToHex, isJsonRpcResponseSuccess, isJsonRpcResponseError, isSilentPayload, getLocal, signingMethods, mobileLinkChoiceKey, isMobile, removeLocal } from \"@walletconnect/utils\";\nimport SocketTransport from \"@walletconnect/socket-transport\";\nimport { ERROR_SESSION_CONNECTED, ERROR_SESSION_DISCONNECTED, ERROR_SESSION_REJECTED, ERROR_MISSING_JSON_RPC, ERROR_MISSING_RESULT, ERROR_MISSING_ERROR, ERROR_MISSING_METHOD, ERROR_MISSING_ID, ERROR_INVALID_RESPONSE, ERROR_INVALID_URI, ERROR_MISSING_REQUIRED, ERROR_QRCODE_MODAL_NOT_PROVIDED, ERROR_QRCODE_MODAL_USER_CLOSED } from \"./errors\";\nimport EventManager from \"./events\";\nimport SessionStorage from \"./storage\";\nimport { getBridgeUrl } from \"./url\";\n\nclass Connector {\n  constructor(opts) {\n    this.protocol = \"wc\";\n    this.version = 1;\n    this._bridge = \"\";\n    this._key = null;\n    this._clientId = \"\";\n    this._clientMeta = null;\n    this._peerId = \"\";\n    this._peerMeta = null;\n    this._handshakeId = 0;\n    this._handshakeTopic = \"\";\n    this._connected = false;\n    this._accounts = [];\n    this._chainId = 0;\n    this._networkId = 0;\n    this._rpcUrl = \"\";\n    this._eventManager = new EventManager();\n    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;\n    this._cryptoLib = opts.cryptoLib;\n    this._sessionStorage = opts.sessionStorage || new SessionStorage(opts.connectorOpts.storageId);\n    this._qrcodeModal = opts.connectorOpts.qrcodeModal;\n    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;\n    this._signingMethods = [...signingMethods, ...(opts.connectorOpts.signingMethods || [])];\n\n    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {\n      throw new Error(ERROR_MISSING_REQUIRED);\n    }\n\n    if (opts.connectorOpts.bridge) {\n      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);\n    }\n\n    if (opts.connectorOpts.uri) {\n      this.uri = opts.connectorOpts.uri;\n    }\n\n    const session = opts.connectorOpts.session || this._getStorageSession();\n\n    if (session) {\n      this.session = session;\n    }\n\n    if (this.handshakeId) {\n      this._subscribeToSessionResponse(this.handshakeId, \"Session request rejected\");\n    }\n\n    this._transport = opts.transport || new SocketTransport({\n      protocol: this.protocol,\n      version: this.version,\n      url: this.bridge,\n      subscriptions: [this.clientId]\n    });\n\n    this._subscribeToInternalEvents();\n\n    this._initTransport();\n\n    if (opts.connectorOpts.uri) {\n      this._subscribeToSessionRequest();\n    }\n\n    if (opts.pushServerOpts) {\n      this._registerPushServer(opts.pushServerOpts);\n    }\n  }\n\n  set bridge(value) {\n    if (!value) {\n      return;\n    }\n\n    this._bridge = value;\n  }\n\n  get bridge() {\n    return this._bridge;\n  }\n\n  set key(value) {\n    if (!value) {\n      return;\n    }\n\n    const key = convertHexToArrayBuffer(value);\n    this._key = key;\n  }\n\n  get key() {\n    if (this._key) {\n      const key = convertArrayBufferToHex(this._key, true);\n      return key;\n    }\n\n    return \"\";\n  }\n\n  set clientId(value) {\n    if (!value) {\n      return;\n    }\n\n    this._clientId = value;\n  }\n\n  get clientId() {\n    let clientId = this._clientId;\n\n    if (!clientId) {\n      clientId = this._clientId = uuid();\n    }\n\n    return this._clientId;\n  }\n\n  set peerId(value) {\n    if (!value) {\n      return;\n    }\n\n    this._peerId = value;\n  }\n\n  get peerId() {\n    return this._peerId;\n  }\n\n  set clientMeta(value) {}\n\n  get clientMeta() {\n    let clientMeta = this._clientMeta;\n\n    if (!clientMeta) {\n      clientMeta = this._clientMeta = getClientMeta();\n    }\n\n    return clientMeta;\n  }\n\n  set peerMeta(value) {\n    this._peerMeta = value;\n  }\n\n  get peerMeta() {\n    const peerMeta = this._peerMeta;\n    return peerMeta;\n  }\n\n  set handshakeTopic(value) {\n    if (!value) {\n      return;\n    }\n\n    this._handshakeTopic = value;\n  }\n\n  get handshakeTopic() {\n    return this._handshakeTopic;\n  }\n\n  set handshakeId(value) {\n    if (!value) {\n      return;\n    }\n\n    this._handshakeId = value;\n  }\n\n  get handshakeId() {\n    return this._handshakeId;\n  }\n\n  get uri() {\n    const _uri = this._formatUri();\n\n    return _uri;\n  }\n\n  set uri(value) {\n    if (!value) {\n      return;\n    }\n\n    const {\n      handshakeTopic,\n      bridge,\n      key\n    } = this._parseUri(value);\n\n    this.handshakeTopic = handshakeTopic;\n    this.bridge = bridge;\n    this.key = key;\n  }\n\n  set chainId(value) {\n    this._chainId = value;\n  }\n\n  get chainId() {\n    const chainId = this._chainId;\n    return chainId;\n  }\n\n  set networkId(value) {\n    this._networkId = value;\n  }\n\n  get networkId() {\n    const networkId = this._networkId;\n    return networkId;\n  }\n\n  set accounts(value) {\n    this._accounts = value;\n  }\n\n  get accounts() {\n    const accounts = this._accounts;\n    return accounts;\n  }\n\n  set rpcUrl(value) {\n    this._rpcUrl = value;\n  }\n\n  get rpcUrl() {\n    const rpcUrl = this._rpcUrl;\n    return rpcUrl;\n  }\n\n  set connected(value) {}\n\n  get connected() {\n    return this._connected;\n  }\n\n  set pending(value) {}\n\n  get pending() {\n    return !!this._handshakeTopic;\n  }\n\n  get session() {\n    return {\n      connected: this.connected,\n      accounts: this.accounts,\n      chainId: this.chainId,\n      bridge: this.bridge,\n      key: this.key,\n      clientId: this.clientId,\n      clientMeta: this.clientMeta,\n      peerId: this.peerId,\n      peerMeta: this.peerMeta,\n      handshakeId: this.handshakeId,\n      handshakeTopic: this.handshakeTopic\n    };\n  }\n\n  set session(value) {\n    if (!value) {\n      return;\n    }\n\n    this._connected = value.connected;\n    this.accounts = value.accounts;\n    this.chainId = value.chainId;\n    this.bridge = value.bridge;\n    this.key = value.key;\n    this.clientId = value.clientId;\n    this.clientMeta = value.clientMeta;\n    this.peerId = value.peerId;\n    this.peerMeta = value.peerMeta;\n    this.handshakeId = value.handshakeId;\n    this.handshakeTopic = value.handshakeTopic;\n  }\n\n  on(event, callback) {\n    const eventEmitter = {\n      event,\n      callback\n    };\n\n    this._eventManager.subscribe(eventEmitter);\n  }\n\n  off(event) {\n    this._eventManager.unsubscribe(event);\n  }\n\n  createInstantRequest(instantRequest) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this._key = yield _this._generateKey();\n\n      const request = _this._formatRequest({\n        method: \"wc_instantRequest\",\n        params: [{\n          peerId: _this.clientId,\n          peerMeta: _this.clientMeta,\n          request: _this._formatRequest(instantRequest)\n        }]\n      });\n\n      _this.handshakeId = request.id;\n      _this.handshakeTopic = uuid();\n\n      _this._eventManager.trigger({\n        event: \"display_uri\",\n        params: [_this.uri]\n      });\n\n      _this.on(\"modal_closed\", () => {\n        throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);\n      });\n\n      const endInstantRequest = () => {\n        _this.killSession();\n      };\n\n      try {\n        const result = yield _this._sendCallRequest(request);\n\n        if (result) {\n          endInstantRequest();\n        }\n\n        return result;\n      } catch (error) {\n        endInstantRequest();\n        throw error;\n      }\n    })();\n  }\n\n  connect(opts) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2._qrcodeModal) {\n        throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);\n      }\n\n      if (_this2.connected) {\n        return {\n          chainId: _this2.chainId,\n          accounts: _this2.accounts\n        };\n      }\n\n      yield _this2.createSession(opts);\n      return new Promise( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (resolve, reject) {\n          _this2.on(\"modal_closed\", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));\n\n          _this2.on(\"connect\", (error, payload) => {\n            if (error) {\n              return reject(error);\n            }\n\n            resolve(payload.params[0]);\n          });\n        });\n\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  createSession(opts) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this3._connected) {\n        throw new Error(ERROR_SESSION_CONNECTED);\n      }\n\n      if (_this3.pending) {\n        return;\n      }\n\n      _this3._key = yield _this3._generateKey();\n\n      const request = _this3._formatRequest({\n        method: \"wc_sessionRequest\",\n        params: [{\n          peerId: _this3.clientId,\n          peerMeta: _this3.clientMeta,\n          chainId: opts && opts.chainId ? opts.chainId : null\n        }]\n      });\n\n      _this3.handshakeId = request.id;\n      _this3.handshakeTopic = uuid();\n\n      _this3._sendSessionRequest(request, \"Session update rejected\", {\n        topic: _this3.handshakeTopic\n      });\n\n      _this3._eventManager.trigger({\n        event: \"display_uri\",\n        params: [_this3.uri]\n      });\n    })();\n  }\n\n  approveSession(sessionStatus) {\n    if (this._connected) {\n      throw new Error(ERROR_SESSION_CONNECTED);\n    }\n\n    this.chainId = sessionStatus.chainId;\n    this.accounts = sessionStatus.accounts;\n    this.networkId = sessionStatus.networkId || 0;\n    this.rpcUrl = sessionStatus.rpcUrl || \"\";\n    const sessionParams = {\n      approved: true,\n      chainId: this.chainId,\n      networkId: this.networkId,\n      accounts: this.accounts,\n      rpcUrl: this.rpcUrl,\n      peerId: this.clientId,\n      peerMeta: this.clientMeta\n    };\n    const response = {\n      id: this.handshakeId,\n      jsonrpc: \"2.0\",\n      result: sessionParams\n    };\n\n    this._sendResponse(response);\n\n    this._connected = true;\n\n    this._setStorageSession();\n\n    this._eventManager.trigger({\n      event: \"connect\",\n      params: [{\n        peerId: this.peerId,\n        peerMeta: this.peerMeta,\n        chainId: this.chainId,\n        accounts: this.accounts\n      }]\n    });\n  }\n\n  rejectSession(sessionError) {\n    if (this._connected) {\n      throw new Error(ERROR_SESSION_CONNECTED);\n    }\n\n    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;\n\n    const response = this._formatResponse({\n      id: this.handshakeId,\n      error: {\n        message\n      }\n    });\n\n    this._sendResponse(response);\n\n    this._connected = false;\n\n    this._eventManager.trigger({\n      event: \"disconnect\",\n      params: [{\n        message\n      }]\n    });\n\n    this._removeStorageSession();\n  }\n\n  updateSession(sessionStatus) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n\n    this.chainId = sessionStatus.chainId;\n    this.accounts = sessionStatus.accounts;\n    this.networkId = sessionStatus.networkId || 0;\n    this.rpcUrl = sessionStatus.rpcUrl || \"\";\n    const sessionParams = {\n      approved: true,\n      chainId: this.chainId,\n      networkId: this.networkId,\n      accounts: this.accounts,\n      rpcUrl: this.rpcUrl\n    };\n\n    const request = this._formatRequest({\n      method: \"wc_sessionUpdate\",\n      params: [sessionParams]\n    });\n\n    this._sendSessionRequest(request, \"Session update rejected\");\n\n    this._eventManager.trigger({\n      event: \"session_update\",\n      params: [{\n        chainId: this.chainId,\n        accounts: this.accounts\n      }]\n    });\n\n    this._manageStorageSession();\n  }\n\n  killSession(sessionError) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const message = sessionError ? sessionError.message : \"Session Disconnected\";\n      const sessionParams = {\n        approved: false,\n        chainId: null,\n        networkId: null,\n        accounts: null\n      };\n\n      const request = _this4._formatRequest({\n        method: \"wc_sessionUpdate\",\n        params: [sessionParams]\n      });\n\n      yield _this4._sendRequest(request);\n\n      _this4._handleSessionDisconnect(message);\n    })();\n  }\n\n  sendTransaction(tx) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this5._connected) {\n        throw new Error(ERROR_SESSION_DISCONNECTED);\n      }\n\n      const parsedTx = parseTransactionData(tx);\n\n      const request = _this5._formatRequest({\n        method: \"eth_sendTransaction\",\n        params: [parsedTx]\n      });\n\n      const result = yield _this5._sendCallRequest(request);\n      return result;\n    })();\n  }\n\n  signTransaction(tx) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this6._connected) {\n        throw new Error(ERROR_SESSION_DISCONNECTED);\n      }\n\n      const parsedTx = parseTransactionData(tx);\n\n      const request = _this6._formatRequest({\n        method: \"eth_signTransaction\",\n        params: [parsedTx]\n      });\n\n      const result = yield _this6._sendCallRequest(request);\n      return result;\n    })();\n  }\n\n  signMessage(params) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this7._connected) {\n        throw new Error(ERROR_SESSION_DISCONNECTED);\n      }\n\n      const request = _this7._formatRequest({\n        method: \"eth_sign\",\n        params\n      });\n\n      const result = yield _this7._sendCallRequest(request);\n      return result;\n    })();\n  }\n\n  signPersonalMessage(params) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this8._connected) {\n        throw new Error(ERROR_SESSION_DISCONNECTED);\n      }\n\n      params = parsePersonalSign(params);\n\n      const request = _this8._formatRequest({\n        method: \"personal_sign\",\n        params\n      });\n\n      const result = yield _this8._sendCallRequest(request);\n      return result;\n    })();\n  }\n\n  signTypedData(params) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this9._connected) {\n        throw new Error(ERROR_SESSION_DISCONNECTED);\n      }\n\n      const request = _this9._formatRequest({\n        method: \"eth_signTypedData\",\n        params\n      });\n\n      const result = yield _this9._sendCallRequest(request);\n      return result;\n    })();\n  }\n\n  updateChain(chainParams) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this10._connected) {\n        throw new Error(\"Session currently disconnected\");\n      }\n\n      const request = _this10._formatRequest({\n        method: \"wallet_updateChain\",\n        params: [chainParams]\n      });\n\n      const result = yield _this10._sendCallRequest(request);\n      return result;\n    })();\n  }\n\n  unsafeSend(request, options) {\n    this._sendRequest(request, options);\n\n    this._eventManager.trigger({\n      event: \"call_request_sent\",\n      params: [{\n        request,\n        options\n      }]\n    });\n\n    return new Promise((resolve, reject) => {\n      this._subscribeToResponse(request.id, (error, payload) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        if (!payload) {\n          throw new Error(ERROR_MISSING_JSON_RPC);\n        }\n\n        resolve(payload);\n      });\n    });\n  }\n\n  sendCustomRequest(request, options) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this11._connected) {\n        throw new Error(ERROR_SESSION_DISCONNECTED);\n      }\n\n      switch (request.method) {\n        case \"eth_accounts\":\n          return _this11.accounts;\n\n        case \"eth_chainId\":\n          return convertNumberToHex(_this11.chainId);\n\n        case \"eth_sendTransaction\":\n        case \"eth_signTransaction\":\n          if (request.params) {\n            request.params[0] = parseTransactionData(request.params[0]);\n          }\n\n          break;\n\n        case \"personal_sign\":\n          if (request.params) {\n            request.params = parsePersonalSign(request.params);\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      const formattedRequest = _this11._formatRequest(request);\n\n      const result = yield _this11._sendCallRequest(formattedRequest, options);\n      return result;\n    })();\n  }\n\n  approveRequest(response) {\n    if (isJsonRpcResponseSuccess(response)) {\n      const formattedResponse = this._formatResponse(response);\n\n      this._sendResponse(formattedResponse);\n    } else {\n      throw new Error(ERROR_MISSING_RESULT);\n    }\n  }\n\n  rejectRequest(response) {\n    if (isJsonRpcResponseError(response)) {\n      const formattedResponse = this._formatResponse(response);\n\n      this._sendResponse(formattedResponse);\n    } else {\n      throw new Error(ERROR_MISSING_ERROR);\n    }\n  }\n\n  transportClose() {\n    this._transport.close();\n  }\n\n  _sendRequest(request, options) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const callRequest = _this12._formatRequest(request);\n\n      const encryptionPayload = yield _this12._encrypt(callRequest);\n      const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== \"undefined\" ? options.topic : _this12.peerId;\n      const payload = JSON.stringify(encryptionPayload);\n      const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== \"undefined\" ? !options.forcePushNotification : isSilentPayload(callRequest);\n\n      _this12._transport.send(payload, topic, silent);\n    })();\n  }\n\n  _sendResponse(response) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      const encryptionPayload = yield _this13._encrypt(response);\n      const topic = _this13.peerId;\n      const payload = JSON.stringify(encryptionPayload);\n      const silent = true;\n\n      _this13._transport.send(payload, topic, silent);\n    })();\n  }\n\n  _sendSessionRequest(request, errorMsg, options) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      _this14._sendRequest(request, options);\n\n      _this14._subscribeToSessionResponse(request.id, errorMsg);\n    })();\n  }\n\n  _sendCallRequest(request, options) {\n    this._sendRequest(request, options);\n\n    this._eventManager.trigger({\n      event: \"call_request_sent\",\n      params: [{\n        request,\n        options\n      }]\n    });\n\n    return this._subscribeToCallResponse(request.id);\n  }\n\n  _formatRequest(request) {\n    if (typeof request.method === \"undefined\") {\n      throw new Error(ERROR_MISSING_METHOD);\n    }\n\n    const formattedRequest = {\n      id: typeof request.id === \"undefined\" ? payloadId() : request.id,\n      jsonrpc: \"2.0\",\n      method: request.method,\n      params: typeof request.params === \"undefined\" ? [] : request.params\n    };\n    return formattedRequest;\n  }\n\n  _formatResponse(response) {\n    if (typeof response.id === \"undefined\") {\n      throw new Error(ERROR_MISSING_ID);\n    }\n\n    const baseResponse = {\n      id: response.id,\n      jsonrpc: \"2.0\"\n    };\n\n    if (isJsonRpcResponseError(response)) {\n      const error = formatRpcError(response.error);\n      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), {\n        error\n      });\n      return errorResponse;\n    } else if (isJsonRpcResponseSuccess(response)) {\n      const successResponse = Object.assign(Object.assign({}, baseResponse), response);\n      return successResponse;\n    }\n\n    throw new Error(ERROR_INVALID_RESPONSE);\n  }\n\n  _handleSessionDisconnect(errorMsg) {\n    const message = errorMsg || \"Session Disconnected\";\n\n    if (!this._connected) {\n      if (this._qrcodeModal) {\n        this._qrcodeModal.close();\n      }\n\n      removeLocal(mobileLinkChoiceKey);\n    }\n\n    if (this._connected) {\n      this._connected = false;\n    }\n\n    if (this._handshakeId) {\n      this._handshakeId = 0;\n    }\n\n    if (this._handshakeTopic) {\n      this._handshakeTopic = \"\";\n    }\n\n    if (this._peerId) {\n      this._peerId = \"\";\n    }\n\n    this._eventManager.trigger({\n      event: \"disconnect\",\n      params: [{\n        message\n      }]\n    });\n\n    this._removeStorageSession();\n\n    this.transportClose();\n  }\n\n  _handleSessionResponse(errorMsg, sessionParams) {\n    if (sessionParams) {\n      if (sessionParams.approved) {\n        if (!this._connected) {\n          this._connected = true;\n\n          if (sessionParams.chainId) {\n            this.chainId = sessionParams.chainId;\n          }\n\n          if (sessionParams.accounts) {\n            this.accounts = sessionParams.accounts;\n          }\n\n          if (sessionParams.peerId && !this.peerId) {\n            this.peerId = sessionParams.peerId;\n          }\n\n          if (sessionParams.peerMeta && !this.peerMeta) {\n            this.peerMeta = sessionParams.peerMeta;\n          }\n\n          this._eventManager.trigger({\n            event: \"connect\",\n            params: [{\n              peerId: this.peerId,\n              peerMeta: this.peerMeta,\n              chainId: this.chainId,\n              accounts: this.accounts\n            }]\n          });\n        } else {\n          if (sessionParams.chainId) {\n            this.chainId = sessionParams.chainId;\n          }\n\n          if (sessionParams.accounts) {\n            this.accounts = sessionParams.accounts;\n          }\n\n          this._eventManager.trigger({\n            event: \"session_update\",\n            params: [{\n              chainId: this.chainId,\n              accounts: this.accounts\n            }]\n          });\n        }\n\n        this._manageStorageSession();\n      } else {\n        this._handleSessionDisconnect(errorMsg);\n      }\n    } else {\n      this._handleSessionDisconnect(errorMsg);\n    }\n  }\n\n  _handleIncomingMessages(socketMessage) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      const activeTopics = [_this15.clientId, _this15.handshakeTopic];\n\n      if (!activeTopics.includes(socketMessage.topic)) {\n        return;\n      }\n\n      let encryptionPayload;\n\n      try {\n        encryptionPayload = JSON.parse(socketMessage.payload);\n      } catch (error) {\n        return;\n      }\n\n      const payload = yield _this15._decrypt(encryptionPayload);\n\n      if (payload) {\n        _this15._eventManager.trigger(payload);\n      }\n    })();\n  }\n\n  _subscribeToSessionRequest() {\n    this._transport.subscribe(this.handshakeTopic);\n  }\n\n  _subscribeToResponse(id, callback) {\n    this.on(`response:${id}`, callback);\n  }\n\n  _subscribeToSessionResponse(id, errorMsg) {\n    this._subscribeToResponse(id, (error, payload) => {\n      if (error) {\n        this._handleSessionResponse(error.message);\n\n        return;\n      }\n\n      if (isJsonRpcResponseSuccess(payload)) {\n        this._handleSessionResponse(errorMsg, payload.result);\n      } else if (payload.error && payload.error.message) {\n        this._handleSessionResponse(payload.error.message);\n      } else {\n        this._handleSessionResponse(errorMsg);\n      }\n    });\n  }\n\n  _subscribeToCallResponse(id) {\n    return new Promise((resolve, reject) => {\n      this._subscribeToResponse(id, (error, payload) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        if (isJsonRpcResponseSuccess(payload)) {\n          resolve(payload.result);\n        } else if (payload.error && payload.error.message) {\n          reject(payload.error);\n        } else {\n          reject(new Error(ERROR_INVALID_RESPONSE));\n        }\n      });\n    });\n  }\n\n  _subscribeToInternalEvents() {\n    this.on(\"display_uri\", () => {\n      if (this._qrcodeModal) {\n        this._qrcodeModal.open(this.uri, () => {\n          this._eventManager.trigger({\n            event: \"modal_closed\",\n            params: []\n          });\n        }, this._qrcodeModalOptions);\n      }\n    });\n    this.on(\"connect\", () => {\n      if (this._qrcodeModal) {\n        this._qrcodeModal.close();\n      }\n    });\n    this.on(\"call_request_sent\", (error, payload) => {\n      const {\n        request\n      } = payload.params[0];\n\n      if (isMobile() && this._signingMethods.includes(request.method)) {\n        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);\n\n        if (mobileLinkUrl) {\n          window.location.href = mobileLinkUrl.href;\n        }\n      }\n    });\n    this.on(\"wc_sessionRequest\", (error, payload) => {\n      if (error) {\n        this._eventManager.trigger({\n          event: \"error\",\n          params: [{\n            code: \"SESSION_REQUEST_ERROR\",\n            message: error.toString()\n          }]\n        });\n      }\n\n      this.handshakeId = payload.id;\n      this.peerId = payload.params[0].peerId;\n      this.peerMeta = payload.params[0].peerMeta;\n      const internalPayload = Object.assign(Object.assign({}, payload), {\n        method: \"session_request\"\n      });\n\n      this._eventManager.trigger(internalPayload);\n    });\n    this.on(\"wc_sessionUpdate\", (error, payload) => {\n      if (error) {\n        this._handleSessionResponse(error.message);\n      }\n\n      this._handleSessionResponse(\"Session disconnected\", payload.params[0]);\n    });\n  }\n\n  _initTransport() {\n    this._transport.on(\"message\", socketMessage => this._handleIncomingMessages(socketMessage));\n\n    this._transport.on(\"open\", () => this._eventManager.trigger({\n      event: \"transport_open\",\n      params: []\n    }));\n\n    this._transport.on(\"close\", () => this._eventManager.trigger({\n      event: \"transport_close\",\n      params: []\n    }));\n\n    this._transport.on(\"error\", () => this._eventManager.trigger({\n      event: \"transport_error\",\n      params: [\"Websocket connection failed\"]\n    }));\n\n    this._transport.open();\n  }\n\n  _formatUri() {\n    const protocol = this.protocol;\n    const handshakeTopic = this.handshakeTopic;\n    const version = this.version;\n    const bridge = encodeURIComponent(this.bridge);\n    const key = this.key;\n    const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;\n    return uri;\n  }\n\n  _parseUri(uri) {\n    const result = parseWalletConnectUri(uri);\n\n    if (result.protocol === this.protocol) {\n      if (!result.handshakeTopic) {\n        throw Error(\"Invalid or missing handshakeTopic parameter value\");\n      }\n\n      const handshakeTopic = result.handshakeTopic;\n\n      if (!result.bridge) {\n        throw Error(\"Invalid or missing bridge url parameter value\");\n      }\n\n      const bridge = decodeURIComponent(result.bridge);\n\n      if (!result.key) {\n        throw Error(\"Invalid or missing key parameter value\");\n      }\n\n      const key = result.key;\n      return {\n        handshakeTopic,\n        bridge,\n        key\n      };\n    } else {\n      throw new Error(ERROR_INVALID_URI);\n    }\n  }\n\n  _generateKey() {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this16._cryptoLib) {\n        const result = yield _this16._cryptoLib.generateKey();\n        return result;\n      }\n\n      return null;\n    })();\n  }\n\n  _encrypt(data) {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = _this17._key;\n\n      if (_this17._cryptoLib && key) {\n        const result = yield _this17._cryptoLib.encrypt(data, key);\n        return result;\n      }\n\n      return null;\n    })();\n  }\n\n  _decrypt(payload) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = _this18._key;\n\n      if (_this18._cryptoLib && key) {\n        const result = yield _this18._cryptoLib.decrypt(payload, key);\n        return result;\n      }\n\n      return null;\n    })();\n  }\n\n  _getStorageSession() {\n    let result = null;\n\n    if (this._sessionStorage) {\n      result = this._sessionStorage.getSession();\n    }\n\n    return result;\n  }\n\n  _setStorageSession() {\n    if (this._sessionStorage) {\n      this._sessionStorage.setSession(this.session);\n    }\n  }\n\n  _removeStorageSession() {\n    if (this._sessionStorage) {\n      this._sessionStorage.removeSession();\n    }\n  }\n\n  _manageStorageSession() {\n    if (this._connected) {\n      this._setStorageSession();\n    } else {\n      this._removeStorageSession();\n    }\n  }\n\n  _registerPushServer(pushServerOpts) {\n    if (!pushServerOpts.url || typeof pushServerOpts.url !== \"string\") {\n      throw Error(\"Invalid or missing pushServerOpts.url parameter value\");\n    }\n\n    if (!pushServerOpts.type || typeof pushServerOpts.type !== \"string\") {\n      throw Error(\"Invalid or missing pushServerOpts.type parameter value\");\n    }\n\n    if (!pushServerOpts.token || typeof pushServerOpts.token !== \"string\") {\n      throw Error(\"Invalid or missing pushServerOpts.token parameter value\");\n    }\n\n    const pushSubscription = {\n      bridge: this.bridge,\n      topic: this.clientId,\n      type: pushServerOpts.type,\n      token: pushServerOpts.token,\n      peerName: \"\",\n      language: pushServerOpts.language || \"\"\n    };\n    this.on(\"connect\", /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (error, payload) {\n        if (error) {\n          throw error;\n        }\n\n        if (pushServerOpts.peerMeta) {\n          const peerName = payload.params[0].peerMeta.name;\n          pushSubscription.peerName = peerName;\n        }\n\n        try {\n          const response = yield fetch(`${pushServerOpts.url}/new`, {\n            method: \"POST\",\n            headers: {\n              Accept: \"application/json\",\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(pushSubscription)\n          });\n          const json = yield response.json();\n\n          if (!json.success) {\n            throw Error(\"Failed to register in Push Server\");\n          }\n        } catch (error) {\n          throw Error(\"Failed to register in Push Server\");\n        }\n      });\n\n      return function (_x3, _x4) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n  }\n\n}\n\nexport default Connector; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module"}