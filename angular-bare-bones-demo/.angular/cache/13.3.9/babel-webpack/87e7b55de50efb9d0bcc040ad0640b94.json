{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EthereumAddressAttestation = void 0;\n\nconst AbstractLinkedAttestation_1 = require(\"./AbstractLinkedAttestation\");\n\nconst SignedLinkedAttestation_1 = require(\"../asn1/shemas/SignedLinkedAttestation\");\n\nconst EthereumAddressAttestation_1 = require(\"../asn1/shemas/EthereumAddressAttestation\");\n\nconst EpochTimeValidity_1 = require(\"../asn1/shemas/EpochTimeValidity\");\n\nconst utils_1 = require(\"../libs/utils\");\n\nclass EthereumAddressAttestation extends AbstractLinkedAttestation_1.AbstractLinkedAttestation {\n  constructor() {\n    super(...arguments);\n    this.TYPE = \"ethereumAddress\";\n  }\n\n  create(holdingPubKey, attestedAddress, attestorKeys, validity, context, validFrom) {\n    this.linkedAttestation = new SignedLinkedAttestation_1.SignedLinkedAttestation();\n    this.linkedAttestation.attestation = new SignedLinkedAttestation_1.LinkedAttestation();\n    this.linkedAttestation.attestation.ethereumAddress = new EthereumAddressAttestation_1.EthereumAddressAttestation();\n    this.linkedAttestation.attestation.ethereumAddress.subjectPublicKey = holdingPubKey;\n    if (!validFrom) validFrom = Math.round(Date.now() / 1000);\n    const expiry = validFrom + validity;\n    this.linkedAttestation.attestation.ethereumAddress.validity = new EpochTimeValidity_1.EpochTimeValidity();\n    this.linkedAttestation.attestation.ethereumAddress.validity.notBefore = validFrom;\n    this.linkedAttestation.attestation.ethereumAddress.validity.notAfter = expiry;\n    this.linkedAttestation.attestation.ethereumAddress.ethereumAddress = (0, utils_1.hexStringToUint8)(attestedAddress);\n    if (context) this.linkedAttestation.attestation.ethereumAddress.context = context;\n    this.sign(attestorKeys);\n  }\n\n}\n\nexports.EthereumAddressAttestation = EthereumAddressAttestation; //# sourceMappingURL=EthereumAddressAttestation.js.map","map":null,"metadata":{},"sourceType":"script"}