{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst inherits = require('util').inherits;\n\nconst ethUtil = require('ethereumjs-util');\n\nconst EthBlockTracker = require('eth-block-tracker');\n\nconst map = require('async/map');\n\nconst eachSeries = require('async/eachSeries');\n\nconst Stoplight = require('./util/stoplight.js');\n\nconst cacheUtils = require('./util/rpc-cache-utils.js');\n\nconst createPayload = require('./util/create-payload.js');\n\nconst noop = function () {};\n\nmodule.exports = Web3ProviderEngine;\ninherits(Web3ProviderEngine, EventEmitter);\n\nfunction Web3ProviderEngine(opts) {\n  const self = this;\n  EventEmitter.call(self);\n  self.setMaxListeners(30); // parse options\n\n  opts = opts || {}; // block polling\n\n  const directProvider = {\n    sendAsync: self._handleAsync.bind(self)\n  };\n  const blockTrackerProvider = opts.blockTrackerProvider || directProvider;\n  self._blockTracker = opts.blockTracker || new EthBlockTracker({\n    provider: blockTrackerProvider,\n    pollingInterval: opts.pollingInterval || 4000,\n    setSkipCacheFlag: true\n  }); // set initialization blocker\n\n  self._ready = new Stoplight(); // local state\n\n  self.currentBlock = null;\n  self._providers = [];\n} // public\n\n\nWeb3ProviderEngine.prototype.start = function (cb = noop) {\n  const self = this; // trigger start\n\n  self._ready.go(); // on new block, request block body and emit as events\n\n\n  self._blockTracker.on('latest', blockNumber => {\n    // get block body\n    self._getBlockByNumberWithRetry(blockNumber, (err, block) => {\n      if (err) {\n        this.emit('error', err);\n        return;\n      }\n\n      if (!block) {\n        console.log(block);\n        this.emit('error', new Error(\"Could not find block\"));\n        return;\n      }\n\n      const bufferBlock = toBufferBlock(block); // set current + emit \"block\" event\n\n      self._setCurrentBlock(bufferBlock); // emit other events\n\n\n      self.emit('rawBlock', block);\n      self.emit('latest', block);\n    });\n  }); // forward other events\n\n\n  self._blockTracker.on('sync', self.emit.bind(self, 'sync'));\n\n  self._blockTracker.on('error', self.emit.bind(self, 'error')); // update state\n\n\n  self._running = true; // signal that we started\n\n  self.emit('start');\n};\n\nWeb3ProviderEngine.prototype.stop = function () {\n  const self = this; // stop block polling by removing event listeners\n\n  self._blockTracker.removeAllListeners(); // update state\n\n\n  self._running = false; // signal that we stopped\n\n  self.emit('stop');\n};\n\nWeb3ProviderEngine.prototype.isRunning = function () {\n  const self = this;\n  return self._running;\n};\n\nWeb3ProviderEngine.prototype.addProvider = function (source, index) {\n  const self = this;\n\n  if (typeof index === 'number') {\n    self._providers.splice(index, 0, source);\n  } else {\n    self._providers.push(source);\n  }\n\n  source.setEngine(this);\n};\n\nWeb3ProviderEngine.prototype.removeProvider = function (source) {\n  const self = this;\n\n  const index = self._providers.indexOf(source);\n\n  if (index < 0) throw new Error('Provider not found.');\n\n  self._providers.splice(index, 1);\n};\n\nWeb3ProviderEngine.prototype.send = function (payload) {\n  throw new Error('Web3ProviderEngine does not support synchronous requests.');\n};\n\nWeb3ProviderEngine.prototype.sendAsync = function (payload, cb) {\n  const self = this;\n\n  self._ready.await(function () {\n    if (Array.isArray(payload)) {\n      // handle batch\n      map(payload, self._handleAsync.bind(self), cb);\n    } else {\n      // handle single\n      self._handleAsync(payload, cb);\n    }\n  });\n}; // private\n\n\nWeb3ProviderEngine.prototype._getBlockByNumberWithRetry = function (blockNumber, cb) {\n  const self = this;\n  let retriesRemaining = 5;\n  attemptRequest();\n  return;\n\n  function attemptRequest() {\n    self._getBlockByNumber(blockNumber, afterRequest);\n  }\n\n  function afterRequest(err, block) {\n    // anomalous error occurred\n    if (err) return cb(err); // block not ready yet\n\n    if (!block) {\n      if (retriesRemaining > 0) {\n        // wait 1s then try again\n        retriesRemaining--;\n        setTimeout(function () {\n          attemptRequest();\n        }, 1000);\n        return;\n      } else {\n        // give up, return a null block\n        cb(null, null);\n        return;\n      }\n    } // otherwise return result\n\n\n    cb(null, block);\n    return;\n  }\n};\n\nWeb3ProviderEngine.prototype._getBlockByNumber = function (blockNumber, cb) {\n  const req = createPayload({\n    method: 'eth_getBlockByNumber',\n    params: [blockNumber, false],\n    skipCache: true\n  });\n\n  this._handleAsync(req, (err, res) => {\n    if (err) return cb(err);\n    return cb(null, res.result);\n  });\n};\n\nWeb3ProviderEngine.prototype._handleAsync = function (payload, finished) {\n  var self = this;\n  var currentProvider = -1;\n  var result = null;\n  var error = null;\n  var stack = [];\n  next();\n\n  function next(after) {\n    currentProvider += 1;\n    stack.unshift(after); // Bubbled down as far as we could go, and the request wasn't\n    // handled. Return an error.\n\n    if (currentProvider >= self._providers.length) {\n      end(new Error('Request for method \"' + payload.method + '\" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'));\n    } else {\n      try {\n        var provider = self._providers[currentProvider];\n        provider.handleRequest(payload, next, end);\n      } catch (e) {\n        end(e);\n      }\n    }\n  }\n\n  function end(_error, _result) {\n    error = _error;\n    result = _result;\n    eachSeries(stack, function (fn, callback) {\n      if (fn) {\n        fn(error, result, callback);\n      } else {\n        callback();\n      }\n    }, function () {\n      var resultObj = {\n        id: payload.id,\n        jsonrpc: payload.jsonrpc,\n        result: result\n      };\n\n      if (error != null) {\n        resultObj.error = {\n          message: error.stack || error.message || error,\n          code: -32000\n        }; // respond with both error formats\n\n        finished(error, resultObj);\n      } else {\n        finished(null, resultObj);\n      }\n    });\n  }\n}; //\n// from remote-data\n//\n\n\nWeb3ProviderEngine.prototype._setCurrentBlock = function (block) {\n  const self = this;\n  self.currentBlock = block;\n  self.emit('block', block);\n}; // util\n\n\nfunction toBufferBlock(jsonBlock) {\n  return {\n    number: ethUtil.toBuffer(jsonBlock.number),\n    hash: ethUtil.toBuffer(jsonBlock.hash),\n    parentHash: ethUtil.toBuffer(jsonBlock.parentHash),\n    nonce: ethUtil.toBuffer(jsonBlock.nonce),\n    mixHash: ethUtil.toBuffer(jsonBlock.mixHash),\n    sha3Uncles: ethUtil.toBuffer(jsonBlock.sha3Uncles),\n    logsBloom: ethUtil.toBuffer(jsonBlock.logsBloom),\n    transactionsRoot: ethUtil.toBuffer(jsonBlock.transactionsRoot),\n    stateRoot: ethUtil.toBuffer(jsonBlock.stateRoot),\n    receiptsRoot: ethUtil.toBuffer(jsonBlock.receiptRoot || jsonBlock.receiptsRoot),\n    miner: ethUtil.toBuffer(jsonBlock.miner),\n    difficulty: ethUtil.toBuffer(jsonBlock.difficulty),\n    totalDifficulty: ethUtil.toBuffer(jsonBlock.totalDifficulty),\n    size: ethUtil.toBuffer(jsonBlock.size),\n    extraData: ethUtil.toBuffer(jsonBlock.extraData),\n    gasLimit: ethUtil.toBuffer(jsonBlock.gasLimit),\n    gasUsed: ethUtil.toBuffer(jsonBlock.gasUsed),\n    timestamp: ethUtil.toBuffer(jsonBlock.timestamp),\n    transactions: jsonBlock.transactions\n  };\n}","map":null,"metadata":{},"sourceType":"script"}