{"ast":null,"code":"import * as asn1js from \"asn1js\";\nimport * as converters from \"./converters\";\nimport { AsnPropTypes, AsnTypeTypes } from \"./enums\";\nimport { isConvertible, isArrayEqual } from \"./helper\";\nimport { schemaStorage } from \"./storage\";\nexport class AsnSerializer {\n  static serialize(obj) {\n    if (obj instanceof asn1js.BaseBlock) {\n      return obj.toBER(false);\n    }\n\n    return this.toASN(obj).toBER(false);\n  }\n\n  static toASN(obj) {\n    if (obj && typeof obj === \"object\" && isConvertible(obj)) {\n      return obj.toASN();\n    }\n\n    if (!(obj && typeof obj === \"object\")) {\n      throw new TypeError(\"Parameter 1 should be type of Object.\");\n    }\n\n    const target = obj.constructor;\n    const schema = schemaStorage.get(target);\n    schemaStorage.cache(target);\n    let asn1Value = [];\n\n    if (schema.itemType) {\n      if (!Array.isArray(obj)) {\n        throw new TypeError(\"Parameter 1 should be type of Array.\");\n      }\n\n      if (typeof schema.itemType === \"number\") {\n        const converter = converters.defaultConverter(schema.itemType);\n\n        if (!converter) {\n          throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n        }\n\n        asn1Value = obj.map(o => converter.toASN(o));\n      } else {\n        asn1Value = obj.map(o => this.toAsnItem({\n          type: schema.itemType\n        }, \"[]\", target, o));\n      }\n    } else {\n      for (const key in schema.items) {\n        const schemaItem = schema.items[key];\n        const objProp = obj[key];\n\n        if (objProp === undefined || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === \"object\" && typeof objProp === \"object\" && isArrayEqual(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {\n          continue;\n        }\n\n        const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);\n\n        if (typeof schemaItem.context === \"number\") {\n          if (schemaItem.implicit) {\n            if (!schemaItem.repeated && (typeof schemaItem.type === \"number\" || isConvertible(schemaItem.type))) {\n              const value = {};\n              value.valueHex = asn1Item instanceof asn1js.Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();\n              asn1Value.push(new asn1js.Primitive({\n                optional: schemaItem.optional,\n                idBlock: {\n                  tagClass: 3,\n                  tagNumber: schemaItem.context\n                },\n                ...value\n              }));\n            } else {\n              asn1Value.push(new asn1js.Constructed({\n                optional: schemaItem.optional,\n                idBlock: {\n                  tagClass: 3,\n                  tagNumber: schemaItem.context\n                },\n                value: asn1Item.valueBlock.value\n              }));\n            }\n          } else {\n            asn1Value.push(new asn1js.Constructed({\n              optional: schemaItem.optional,\n              idBlock: {\n                tagClass: 3,\n                tagNumber: schemaItem.context\n              },\n              value: [asn1Item]\n            }));\n          }\n        } else if (schemaItem.repeated) {\n          asn1Value = asn1Value.concat(asn1Item);\n        } else {\n          asn1Value.push(asn1Item);\n        }\n      }\n    }\n\n    let asnSchema;\n\n    switch (schema.type) {\n      case AsnTypeTypes.Sequence:\n        asnSchema = new asn1js.Sequence({\n          value: asn1Value\n        });\n        break;\n\n      case AsnTypeTypes.Set:\n        asnSchema = new asn1js.Set({\n          value: asn1Value\n        });\n        break;\n\n      case AsnTypeTypes.Choice:\n        if (!asn1Value[0]) {\n          throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);\n        }\n\n        asnSchema = asn1Value[0];\n        break;\n    }\n\n    return asnSchema;\n  }\n\n  static toAsnItem(schemaItem, key, target, objProp) {\n    let asn1Item;\n\n    if (typeof schemaItem.type === \"number\") {\n      const converter = schemaItem.converter;\n\n      if (!converter) {\n        throw new Error(`Property '${key}' doesn't have converter for type ${AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);\n      }\n\n      if (schemaItem.repeated) {\n        if (!Array.isArray(objProp)) {\n          throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n        }\n\n        const items = Array.from(objProp, element => converter.toASN(element));\n        const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n        asn1Item = new Container({\n          value: items\n        });\n      } else {\n        asn1Item = converter.toASN(objProp);\n      }\n    } else {\n      if (schemaItem.repeated) {\n        if (!Array.isArray(objProp)) {\n          throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n        }\n\n        const items = Array.from(objProp, element => this.toASN(element));\n        const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n        asn1Item = new Container({\n          value: items\n        });\n      } else {\n        asn1Item = this.toASN(objProp);\n      }\n    }\n\n    return asn1Item;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}