{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { OutletAction, OutletResponseAction, Messaging } from \"./messaging\";\nimport { Ui } from \"./ui\";\nimport { logger, requiredParams } from \"../utils\";\nimport { getNftCollection, getNftTokens } from \"../utils/token/nftProvider\";\nimport \"./../vendor/keyShape\";\nimport { Authenticator } from \"@tokenscript/attestation\";\nimport { TokenStore } from \"./tokenStore\";\nimport { SignedUNChallenge } from \"./auth/signedUNChallenge\";\nimport { TicketZKProof } from \"./auth/ticketZKProof\";\nimport { isUserAgentSupported } from '../utils/support/isSupported';\nimport { SelectWallet } from \"./views/select-wallet\";\nimport { SelectIssuers } from \"./views/select-issuers\";\nif (typeof window !== \"undefined\") window.tn = {\n  version: \"2.0.0\"\n};\nvar NOT_SUPPORTED_ERROR = \"This browser is not supported. Please try using Chrome, Edge, FireFox or Safari.\";\nvar defaultConfig = {\n  type: \"active\",\n  issuers: [],\n  uiOptions: {\n    uiType: \"popup\",\n    containerElement: \".overlay-tn\",\n    openingHeading: \"Validate your token ownership for access\",\n    issuerHeading: \"Detected tokens\",\n    autoPopup: true\n  },\n  autoLoadTokens: true,\n  autoEnableTokens: true,\n  messagingForceTab: false,\n  unSupportedUserAgent: {\n    authentication: {\n      config: {\n        metaMaskAndroid: true,\n        alphaWalletAndroid: true,\n        mewAndroid: true,\n        imTokenAndroid: true\n      },\n      errorMessage: NOT_SUPPORTED_ERROR\n    },\n    full: {\n      config: {\n        iE: true,\n        iE9: true\n      },\n      errorMessage: NOT_SUPPORTED_ERROR\n    }\n  }\n};\nexport var ClientError = /*#__PURE__*/(() => {\n  (function (ClientError) {\n    ClientError[\"POPUP_BLOCKED\"] = \"POPUP_BLOCKED\";\n    ClientError[\"USER_ABORT\"] = \"USER_ABORT\";\n  })(ClientError || (ClientError = {}));\n\n  return ClientError;\n})();\nexport var ClientErrorMessage = /*#__PURE__*/(() => {\n  (function (ClientErrorMessage) {\n    ClientErrorMessage[\"POPUP_BLOCKED\"] = \"Please add an exception to your popup blocker before continuing.\";\n    ClientErrorMessage[\"USER_ABORT\"] = \"The user aborted the process.\";\n  })(ClientErrorMessage || (ClientErrorMessage = {}));\n\n  return ClientErrorMessage;\n})();\n\nvar Client = function () {\n  function Client(config) {\n    var _this = this;\n\n    var _a;\n\n    this.clientCallBackEvents = {};\n    this.uiUpdateCallbacks = {};\n    this.cancelAutoload = true;\n    this.eventSender = {\n      emitAllTokensToClient: function (tokens) {\n        _this.on(\"tokens\", null, tokens);\n      },\n      emitSelectedTokensToClient: function (tokens) {\n        _this.on(\"tokens-selected\", null, {\n          selectedTokens: tokens\n        });\n      },\n      emitProofToClient: function (data, issuer, error) {\n        if (error === void 0) {\n          error = \"\";\n        }\n\n        _this.on(\"token-proof\", null, {\n          data: data,\n          issuer: issuer,\n          error: error\n        });\n      },\n      emitErrorToClient: function (error, issuer) {\n        if (issuer === void 0) {\n          issuer = \"none\";\n        }\n\n        _this.on(\"error\", null, {\n          error: error,\n          issuer: issuer\n        });\n      }\n    };\n    this.config = this.mergeConfig(defaultConfig, config);\n    this.negotiateAlreadyFired = false;\n    this.tokenStore = new TokenStore(this.config.autoEnableTokens);\n    if (((_a = this.config.issuers) === null || _a === void 0 ? void 0 : _a.length) > 0) this.tokenStore.updateIssuers(this.config.issuers);\n    this.messaging = new Messaging();\n  }\n\n  Client.getKey = function (file) {\n    return Authenticator.decodePublicKey(file);\n  };\n\n  Client.prototype.mergeConfig = function (defaultConfig, config) {\n    var _a;\n\n    for (var key in config) {\n      if (config[key] && config[key].constructor === Object) {\n        defaultConfig[key] = this.mergeConfig((_a = defaultConfig[key]) !== null && _a !== void 0 ? _a : {}, config[key]);\n      } else {\n        defaultConfig[key] = config[key];\n      }\n    }\n\n    return defaultConfig;\n  };\n\n  Client.prototype.getTokenStore = function () {\n    return this.tokenStore;\n  };\n\n  Client.prototype.getUi = function () {\n    return this.ui;\n  };\n\n  Client.prototype.triggerUiUpdateCallback = function (type, data) {\n    if (this.uiUpdateCallbacks[type]) this.uiUpdateCallbacks[type](data);\n  };\n\n  Client.prototype.registerUiUpdateCallback = function (type, callback) {\n    this.uiUpdateCallbacks[type] = callback;\n  };\n\n  Client.prototype.safeConnectAvailable = function () {\n    return this.config.safeConnectOptions !== undefined;\n  };\n\n  Client.prototype.getWalletProvider = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var Web3WalletProvider;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!this.web3WalletProvider) return [3, 2];\n            return [4, import(\"./../wallet/Web3WalletProvider\")];\n\n          case 1:\n            Web3WalletProvider = _a.sent().Web3WalletProvider;\n            this.web3WalletProvider = new Web3WalletProvider(this, this.config.safeConnectOptions);\n            _a.label = 2;\n\n          case 2:\n            return [2, this.web3WalletProvider];\n        }\n      });\n    });\n  };\n\n  Client.prototype.negotiatorConnectToWallet = function (walletType) {\n    return __awaiter(this, void 0, void 0, function () {\n      var walletProvider, walletAddress;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4, this.getWalletProvider()];\n\n          case 1:\n            walletProvider = _a.sent();\n            return [4, walletProvider.connectWith(walletType)];\n\n          case 2:\n            walletAddress = _a.sent();\n            logger(2, \"wallet address found: \" + walletAddress);\n            return [2, walletAddress];\n        }\n      });\n    });\n  };\n\n  Client.prototype.enrichTokenLookupDataOnChainTokens = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var issuers, _a, _b, _i, issuer, tokenData, lookupData, e_1;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            this.issuersLoaded = false;\n            this.triggerUiUpdateCallback(0);\n            issuers = this.tokenStore.getCurrentIssuers(true);\n            _a = [];\n\n            for (_b in issuers) _a.push(_b);\n\n            _i = 0;\n            _c.label = 1;\n\n          case 1:\n            if (!(_i < _a.length)) return [3, 6];\n            issuer = _a[_i];\n            tokenData = issuers[issuer];\n            if (tokenData.title) return [3, 5];\n            _c.label = 2;\n\n          case 2:\n            _c.trys.push([2, 4,, 5]);\n\n            return [4, getNftCollection(tokenData)];\n\n          case 3:\n            lookupData = _c.sent();\n\n            if (lookupData) {\n              lookupData.onChain = true;\n              this.tokenStore.updateTokenLookupStore(issuer, lookupData);\n            }\n\n            return [3, 5];\n\n          case 4:\n            e_1 = _c.sent();\n            logger(2, \"Failed to load contract data for \" + issuer + \": \" + e_1.message);\n            return [3, 5];\n\n          case 5:\n            _i++;\n            return [3, 1];\n\n          case 6:\n            this.issuersLoaded = true;\n            this.triggerUiUpdateCallback(1);\n            return [2];\n        }\n      });\n    });\n  };\n\n  Client.prototype.checkUserAgentSupport = function (type) {\n    var _this = this;\n\n    var _a, _b;\n\n    if (!isUserAgentSupported((_b = (_a = this.config.unSupportedUserAgent) === null || _a === void 0 ? void 0 : _a[type]) === null || _b === void 0 ? void 0 : _b.config)) {\n      var err_1 = this.config.unSupportedUserAgent[type].errorMessage;\n\n      if (this.config.type === 'active') {\n        this.ui = new Ui(this.config.uiOptions, this);\n        this.ui.initialize();\n        this.ui.openOverlay();\n        setTimeout(function () {\n          _this.ui.showError(err_1, false);\n\n          _this.ui.viewContainer.style.display = 'none';\n        }, 1000);\n      }\n\n      throw new Error(err_1);\n    }\n  };\n\n  Client.prototype.negotiate = function (issuers, openPopup) {\n    if (openPopup === void 0) {\n      openPopup = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.checkUserAgentSupport(\"full\");\n            if (issuers) this.tokenStore.updateIssuers(issuers);\n            requiredParams(Object.keys(this.tokenStore.getCurrentIssuers()).length, \"issuers are missing.\");\n            if (!(this.config.type === \"active\")) return [3, 2];\n            this.issuersLoaded = false;\n            this.activeNegotiationStrategy(openPopup);\n            return [4, this.enrichTokenLookupDataOnChainTokens()];\n\n          case 1:\n            _a.sent();\n\n            return [3, 5];\n\n          case 2:\n            return [4, this.enrichTokenLookupDataOnChainTokens()];\n\n          case 3:\n            _a.sent();\n\n            return [4, this.passiveNegotiationStrategy()];\n\n          case 4:\n            _a.sent();\n\n            _a.label = 5;\n\n          case 5:\n            return [2];\n        }\n      });\n    });\n  };\n\n  Client.prototype.activeNegotiationStrategy = function (openPopup) {\n    var autoOpenPopup;\n\n    if (this.ui) {\n      autoOpenPopup = this.tokenStore.hasUnloadedTokens();\n    } else {\n      this.ui = new Ui(this.config.uiOptions, this);\n      this.ui.initialize();\n      autoOpenPopup = true;\n    }\n\n    if (this.config.autoEnableTokens && Object.keys(this.tokenStore.getSelectedTokens()).length) this.eventSender.emitSelectedTokensToClient(this.tokenStore.getSelectedTokens());\n    if (openPopup || this.config.uiOptions.autoPopup === true && autoOpenPopup) this.ui.openOverlay();\n  };\n\n  Client.prototype.tokenAutoLoad = function (onLoading, onComplete) {\n    return __awaiter(this, void 0, void 0, function () {\n      var count, _a, _b, _i, issuerKey, tokens, tokens_1, e_2;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (this.config.autoLoadTokens === false) return [2];\n            this.cancelAutoload = false;\n            count = 1;\n            _a = [];\n\n            for (_b in this.tokenStore.getCurrentIssuers()) _a.push(_b);\n\n            _i = 0;\n            _c.label = 1;\n\n          case 1:\n            if (!(_i < _a.length)) return [3, 7];\n            issuerKey = _a[_i];\n            tokens = this.tokenStore.getIssuerTokens(issuerKey);\n            if ((tokens === null || tokens === void 0 ? void 0 : tokens.length) > 0) return [3, 6];\n            onLoading(issuerKey);\n            _c.label = 2;\n\n          case 2:\n            _c.trys.push([2, 4,, 5]);\n\n            return [4, this.connectTokenIssuer(issuerKey)];\n\n          case 3:\n            tokens_1 = _c.sent();\n            onComplete(issuerKey, tokens_1);\n            return [3, 5];\n\n          case 4:\n            e_2 = _c.sent();\n            e_2.message = \"Failed to load \" + issuerKey + \": \" + e_2.message;\n            logger(2, e_2.message);\n            this.eventSender.emitErrorToClient(e_2, issuerKey);\n            onComplete(issuerKey, null);\n            return [3, 5];\n\n          case 5:\n            count++;\n            if (this.cancelAutoload || this.config.autoLoadTokens !== true && count > this.config.autoLoadTokens) return [3, 7];\n            _c.label = 6;\n\n          case 6:\n            _i++;\n            return [3, 1];\n\n          case 7:\n            return [2];\n        }\n      });\n    });\n  };\n\n  Client.prototype.cancelTokenAutoload = function () {\n    this.cancelAutoload = true;\n  };\n\n  Client.prototype.setPassiveNegotiationWebTokens = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var issuers, _a, _b, _i, issuer, res, issuerConfig, err_2;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            issuers = this.tokenStore.getCurrentIssuers(false);\n            _a = [];\n\n            for (_b in issuers) _a.push(_b);\n\n            _i = 0;\n            _c.label = 1;\n\n          case 1:\n            if (!(_i < _a.length)) return [3, 7];\n            issuer = _a[_i];\n            res = void 0;\n            issuerConfig = this.tokenStore.getCurrentIssuers()[issuer];\n            _c.label = 2;\n\n          case 2:\n            _c.trys.push([2, 4,, 5]);\n\n            return [4, this.messaging.sendMessage({\n              action: OutletAction.GET_ISSUER_TOKENS,\n              origin: issuerConfig.tokenOrigin,\n              data: {\n                issuer: issuer,\n                filter: issuerConfig.filters\n              }\n            }, this.config.messagingForceTab)];\n\n          case 3:\n            res = _c.sent();\n            return [3, 5];\n\n          case 4:\n            err_2 = _c.sent();\n            logger(2, err_2);\n            console.log(\"popup error\");\n            this.eventSender.emitErrorToClient(err_2, issuer);\n            return [3, 6];\n\n          case 5:\n            logger(2, \"tokens:\");\n            logger(2, res.data.tokens);\n            this.tokenStore.setTokens(issuer, res.data.tokens);\n            _c.label = 6;\n\n          case 6:\n            _i++;\n            return [3, 1];\n\n          case 7:\n            return [2];\n        }\n      });\n    });\n  };\n\n  Client.prototype.setPassiveNegotiationOnChainTokens = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var issuers, walletProvider, _a, _b, _i, issuerKey, issuer, tokens, e_3;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            issuers = this.tokenStore.getCurrentIssuers(true);\n            return [4, this.getWalletProvider()];\n\n          case 1:\n            walletProvider = _c.sent();\n            _a = [];\n\n            for (_b in issuers) _a.push(_b);\n\n            _i = 0;\n            _c.label = 2;\n\n          case 2:\n            if (!(_i < _a.length)) return [3, 7];\n            issuerKey = _a[_i];\n            issuer = issuers[issuerKey];\n            _c.label = 3;\n\n          case 3:\n            _c.trys.push([3, 5,, 6]);\n\n            return [4, getNftTokens(issuer, walletProvider.getConnectedWalletData()[0].address)];\n\n          case 4:\n            tokens = _c.sent();\n            this.tokenStore.setTokens(issuerKey, tokens);\n            return [3, 6];\n\n          case 5:\n            e_3 = _c.sent();\n            logger(2, err);\n            this.eventSender.emitErrorToClient(err, issuerKey);\n            return [3, 6];\n\n          case 6:\n            _i++;\n            return [3, 2];\n\n          case 7:\n            return [2];\n        }\n      });\n    });\n  };\n\n  Client.prototype.passiveNegotiationStrategy = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokens, issuer;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4, this.setPassiveNegotiationWebTokens()];\n\n          case 1:\n            _a.sent();\n\n            return [4, this.setPassiveNegotiationOnChainTokens()];\n\n          case 2:\n            _a.sent();\n\n            tokens = this.tokenStore.getCurrentTokens();\n            logger(2, \"Emit tokens\");\n            logger(2, tokens);\n\n            for (issuer in tokens) {\n              tokens[issuer] = {\n                tokens: tokens[issuer]\n              };\n            }\n\n            this.eventSender.emitAllTokensToClient(tokens);\n            if (this.messaging.core.iframeStorageSupport === false && Object.keys(this.tokenStore.getCurrentTokens(false)).length === 0) logger(2, \"iFrame storage support not detected: Enable popups via your browser to access off-chain tokens with this negotiation type.\");\n            return [2];\n        }\n      });\n    });\n  };\n\n  Client.prototype.connectTokenIssuer = function (issuer) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var config, tokens, walletProvider, walletAddress, res;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            config = this.tokenStore.getCurrentIssuers()[issuer];\n            if (!config) throw new Error(\"Undefined token issuer\");\n            if (!(config.onChain === true)) return [3, 3];\n            return [4, this.getWalletProvider()];\n\n          case 1:\n            walletProvider = _b.sent();\n            walletAddress = (_a = walletProvider.getConnectedWalletData()[0]) === null || _a === void 0 ? void 0 : _a.address;\n            requiredParams(issuer, \"issuer is required.\");\n            requiredParams(walletAddress, \"wallet address is missing.\");\n            return [4, getNftTokens(config, walletAddress)];\n\n          case 2:\n            tokens = _b.sent();\n            this.tokenStore.setTokens(issuer, tokens);\n            return [3, 5];\n\n          case 3:\n            return [4, this.messaging.sendMessage({\n              action: OutletAction.GET_ISSUER_TOKENS,\n              origin: config.tokenOrigin,\n              data: {\n                issuer: issuer,\n                filter: config.filters\n              }\n            }, this.config.messagingForceTab, this.ui)];\n\n          case 4:\n            res = _b.sent();\n            tokens = res.data.tokens;\n            this.tokenStore.setTokens(issuer, res.data.tokens);\n            _b.label = 5;\n\n          case 5:\n            if (this.config.autoEnableTokens) this.eventSender.emitSelectedTokensToClient(this.tokenStore.getSelectedTokens());\n            return [2, tokens];\n        }\n      });\n    });\n  };\n\n  Client.prototype.updateSelectedTokens = function (selectedTokens) {\n    this.tokenStore.setSelectedTokens(selectedTokens);\n    this.eventSender.emitSelectedTokensToClient(selectedTokens);\n  };\n\n  Client.prototype.authenticate = function (authRequest) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var issuer, unsignedToken, config, timer, AuthType, authenticator, res, err_3;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.checkUserAgentSupport(\"authentication\");\n            issuer = authRequest.issuer, unsignedToken = authRequest.unsignedToken;\n            requiredParams(issuer && unsignedToken, \"Issuer and signed token required.\");\n            config = this.tokenStore.getCurrentIssuers()[issuer];\n            if (!config) throw new Error(\"Provided issuer was not found.\");\n\n            if (this.ui) {\n              timer = setTimeout(function () {\n                _this.ui.showLoader(\"<h4>Authenticating...</h4>\", \"<small>You may need to sign a new challenge in your wallet</small>\");\n\n                _this.ui.openOverlay();\n              }, 600);\n            }\n\n            if (authRequest.type) {\n              AuthType = authRequest.type;\n            } else {\n              AuthType = config.onChain ? SignedUNChallenge : TicketZKProof;\n            }\n\n            authenticator = new AuthType(this);\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n\n            if (!authRequest.options) authRequest.options = {};\n            (_a = authRequest.options) === null || _a === void 0 ? void 0 : _a.messagingForceTab = this.config.messagingForceTab;\n            return [4, authenticator.getTokenProof(config, [authRequest.unsignedToken], authRequest)];\n\n          case 2:\n            res = _b.sent();\n            logger(2, \"Ticket proof successfully validated.\");\n            this.eventSender.emitProofToClient(res.data, issuer);\n            return [3, 4];\n\n          case 3:\n            err_3 = _b.sent();\n            logger(2, err_3);\n\n            if (err_3.message === \"WALLET_REQUIRED\") {\n              if (timer) clearTimeout(timer);\n              return [2, this.handleWalletRequired(authRequest)];\n            }\n\n            this.handleProofError(err_3, issuer);\n            throw err_3;\n\n          case 4:\n            if (this.ui) {\n              if (timer) clearTimeout(timer);\n              this.ui.dismissLoader();\n              this.ui.closeOverlay();\n            }\n\n            return [2, res.data];\n        }\n      });\n    });\n  };\n\n  Client.prototype.handleWalletRequired = function (authRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var walletProvider;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.ui) return [3, 1];\n            this.ui.dismissLoader();\n            this.ui.openOverlay();\n            return [3, 4];\n\n          case 1:\n            return [4, this.getWalletProvider()];\n\n          case 2:\n            walletProvider = _a.sent();\n            return [4, walletProvider.connectWith(\"MetaMask\")];\n\n          case 3:\n            _a.sent();\n\n            return [2, this.authenticate(authRequest)];\n\n          case 4:\n            return [2, new Promise(function (resolve, reject) {\n              _this.ui.updateUI(SelectWallet, {\n                connectCallback: function () {\n                  return __awaiter(_this, void 0, void 0, function () {\n                    var res, e_4;\n                    return __generator(this, function (_a) {\n                      switch (_a.label) {\n                        case 0:\n                          this.ui.updateUI(SelectIssuers);\n                          _a.label = 1;\n\n                        case 1:\n                          _a.trys.push([1, 3,, 4]);\n\n                          return [4, this.authenticate(authRequest)];\n\n                        case 2:\n                          res = _a.sent();\n                          resolve(res);\n                          return [3, 4];\n\n                        case 3:\n                          e_4 = _a.sent();\n                          reject(e_4);\n                          return [3, 4];\n\n                        case 4:\n                          return [2];\n                      }\n                    });\n                  });\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n\n  Client.prototype.handleProofError = function (err, issuer) {\n    if (this.ui) this.ui.showError(err);\n    this.eventSender.emitProofToClient(null, issuer, err);\n  };\n\n  Client.prototype.addTokenViaMagicLink = function (magicLink) {\n    return __awaiter(this, void 0, void 0, function () {\n      var url, params, res;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            url = new URL(magicLink);\n            params = url.hash.length > 1 ? url.hash.substring(1) : url.search.substring(1);\n            return [4, this.messaging.sendMessage({\n              action: OutletAction.MAGIC_URL,\n              origin: url.origin + url.pathname,\n              data: {\n                urlParams: params\n              }\n            }, this.config.messagingForceTab)];\n\n          case 1:\n            res = _a.sent();\n            if (res.evt === OutletResponseAction.ISSUER_TOKENS) return [2, res.data.tokens];\n            throw new Error(res.errors.join(\"\\n\"));\n        }\n      });\n    });\n  };\n\n  Client.prototype.on = function (type, callback, data) {\n    requiredParams(type, \"Event type is not defined\");\n\n    if (callback) {\n      this.clientCallBackEvents[type] = callback;\n    } else {\n      if (this.clientCallBackEvents[type]) {\n        return this.clientCallBackEvents[type].call(type, data);\n      }\n    }\n  };\n\n  return Client;\n}();\n\nexport { Client }; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module"}