{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EthereumKeyLinkingAttestation = void 0;\n\nconst SignedLinkedAttestation_1 = require(\"../asn1/shemas/SignedLinkedAttestation\");\n\nconst EthereumKeyLinkingAttestation_1 = require(\"../asn1/shemas/EthereumKeyLinkingAttestation\");\n\nconst asn1_schema_1 = require(\"@peculiar/asn1-schema\");\n\nconst utils_1 = require(\"../libs/utils\");\n\nconst EpochTimeValidity_1 = require(\"../asn1/shemas/EpochTimeValidity\");\n\nconst EthereumKeyLinkingAttestation_2 = require(\"../asn1/shemas/EthereumKeyLinkingAttestation\");\n\nconst AuthenticationFramework_1 = require(\"../asn1/shemas/AuthenticationFramework\");\n\nconst EthereumAddressAttestation_1 = require(\"./EthereumAddressAttestation\");\n\nconst NFTOwnershipAttestation_1 = require(\"./NFTOwnershipAttestation\");\n\nconst SubtleCryptoShim_1 = require(\"./SubtleCryptoShim\");\n\nconst HOLDING_KEY_ALGORITHM = \"RSASSA-PKCS1-v1_5\";\n\nclass EthereumKeyLinkingAttestation {\n  create(linkedAttestation, linkedEthereumAddress, validity, context, validFrom) {\n    let addressAttestObj = asn1_schema_1.AsnParser.parse((0, utils_1.base64ToUint8array)(linkedAttestation), SignedLinkedAttestation_1.SignedLinkedAttestation);\n    this.linkAttest = new EthereumKeyLinkingAttestation_1.SignedEthereumKeyLinkingAttestation();\n    this.linkAttest.ethereumKeyLinkingAttestation = new EthereumKeyLinkingAttestation_2.EthereumKeyLinkingAttestation();\n    this.linkAttest.ethereumKeyLinkingAttestation.subjectEthereumAddress = (0, utils_1.hexStringToUint8)(linkedEthereumAddress);\n    this.linkAttest.ethereumKeyLinkingAttestation.linkedAttestation = addressAttestObj;\n    if (!validFrom) validFrom = Math.round(Date.now() / 1000);\n    const expiry = validFrom + validity;\n    this.linkAttest.ethereumKeyLinkingAttestation.validity = new EpochTimeValidity_1.EpochTimeValidity();\n    this.linkAttest.ethereumKeyLinkingAttestation.validity.notBefore = validFrom;\n    this.linkAttest.ethereumKeyLinkingAttestation.validity.notAfter = expiry;\n    if (!context) this.linkAttest.ethereumKeyLinkingAttestation.context = context;\n  }\n\n  sign(holdingPrivateKey) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const linkAttestInfo = asn1_schema_1.AsnSerializer.serialize(_this.linkAttest.ethereumKeyLinkingAttestation);\n      const linkSig = yield SubtleCryptoShim_1.default.sign({\n        name: HOLDING_KEY_ALGORITHM,\n        saltLength: 128\n      }, holdingPrivateKey, linkAttestInfo);\n      _this.linkAttest.signingAlgorithm = new AuthenticationFramework_1.AlgorithmIdentifierASN();\n      _this.linkAttest.signingAlgorithm.algorithm = \"1.2.840.113549.1.1.11\"; // RSASSA pkcs1 v1.5 with SHA-256\n\n      _this.linkAttest.signatureValue = new Uint8Array(linkSig);\n    })();\n  }\n\n  fromBytes(asnBytes) {\n    this.linkAttest = asn1_schema_1.AsnParser.parse(asnBytes, EthereumKeyLinkingAttestation_1.SignedEthereumKeyLinkingAttestation);\n  }\n\n  fromBase64(base64Attestation) {\n    this.fromBytes((0, utils_1.base64ToUint8array)(base64Attestation));\n  }\n\n  getEncoded() {\n    return new Uint8Array(asn1_schema_1.AsnSerializer.serialize(this.linkAttest));\n  }\n\n  getBase64() {\n    return (0, utils_1.uint8arrayToBase64)(this.getEncoded());\n  }\n\n  getAttestation() {\n    return this.linkAttest;\n  }\n\n  getSignedLinkedAttestation() {\n    return this.linkAttest.ethereumKeyLinkingAttestation.linkedAttestation;\n  }\n\n  getLinkedAttestationData() {\n    const signedLinkedAttestation = this.getSignedLinkedAttestation();\n    return signedLinkedAttestation.attestation.ethereumAddress ?? signedLinkedAttestation.attestation.nftOwnership;\n  }\n\n  getLinkedAttestationObject() {\n    const signedLinkedAttestation = this.getSignedLinkedAttestation();\n    let linkedAttestation;\n\n    if (signedLinkedAttestation.attestation.ethereumAddress) {\n      linkedAttestation = new EthereumAddressAttestation_1.EthereumAddressAttestation();\n      linkedAttestation.fromObject(signedLinkedAttestation);\n    } else {\n      linkedAttestation = new NFTOwnershipAttestation_1.NFTOwnershipAttestation();\n      linkedAttestation.fromObject(signedLinkedAttestation);\n    }\n\n    return linkedAttestation;\n  }\n\n  verify(attestorKeys) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let linkedAttestation = _this2.getLinkedAttestationObject();\n\n      linkedAttestation.verify(attestorKeys);\n      let linkedAttestationPubKey = linkedAttestation.getSubjectPublicKey();\n      const encodedLinkAttestation = asn1_schema_1.AsnSerializer.serialize(_this2.linkAttest.ethereumKeyLinkingAttestation);\n      const nftSubjectPubKey = yield SubtleCryptoShim_1.default.importKey(\"spki\", new Uint8Array(linkedAttestationPubKey), {\n        name: HOLDING_KEY_ALGORITHM,\n        hash: {\n          name: \"SHA-256\"\n        }\n      }, true, [\"verify\"]);\n      const valid = yield SubtleCryptoShim_1.default.verify({\n        name: HOLDING_KEY_ALGORITHM,\n        saltLength: 128\n      }, nftSubjectPubKey, _this2.linkAttest.signatureValue, encodedLinkAttestation);\n      if (!valid) throw new Error(\"Signature verification failed\");\n      let now = Math.round(Date.now() / 1000);\n      let data = _this2.linkAttest.ethereumKeyLinkingAttestation;\n      if (data.validity.notBefore > now) throw new Error(\"Linked attestation is not yet valid\");\n      if (data.validity.notAfter < now) throw new Error(\"Linked attestation has expired\");\n    })();\n  }\n\n}\n\nexports.EthereumKeyLinkingAttestation = EthereumKeyLinkingAttestation; //# sourceMappingURL=EthereumKeyLinkingAttestation.js.map","map":null,"metadata":{},"sourceType":"script"}