{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Eip712AttestationRequestWithUsage = void 0;\n\nconst AttestationRequestWithUsage_1 = require(\"./AttestationRequestWithUsage\");\n\nconst KeyPair_1 = require(\"./KeyPair\");\n\nconst utils_1 = require(\"./utils\");\n\nconst SignatureUtility_1 = require(\"./SignatureUtility\");\n\nconst Nonce_1 = require(\"./Nonce\");\n\nconst Eip712Token_1 = require(\"./Eip712Token\");\n\nconst Timestamp_1 = require(\"./Timestamp\");\n\nconst config_1 = require(\"../config\");\n\nclass Eip712AttestationRequestWithUsage extends Eip712Token_1.Eip712Token {\n  constructor(userKey = null, acceptableTimeLimit = Timestamp_1.Timestamp.DEFAULT_TIME_LIMIT_MS, maxTokenValidityInMs = Timestamp_1.Timestamp.DEFAULT_TOKEN_TIME_LIMIT) {\n    super(); // public static DEFAULT_TOKEN_TIME_LIMIT: number = Eip712AttestationUsage.DEFAULT_TOKEN_TIME_LIMIT;\n    // public static DEFAULT_TIME_LIMIT_MS: number = Eip712AttestationRequest.DEFAULT_TIME_LIMIT_MS;\n\n    this.Eip712UserDataTypes = [{\n      name: 'payload',\n      type: 'string'\n    }, {\n      name: 'description',\n      type: 'string'\n    }, {\n      name: 'identifier',\n      type: 'string'\n    }, {\n      name: 'timestamp',\n      type: 'string'\n    }, {\n      name: 'expirationTime',\n      type: 'string'\n    }];\n    this.Eip712UserDataPrimaryName = \"AttestationRequestWUsage\";\n    this.Eip712UserDataDescription = \"Prove that the \\\"identifier\\\" is the identifier hidden in attestation contained in\\\"payload\\\"\" + \" and use this to authorize usage of local, temporary keys.\";\n    this.userKey = userKey;\n    this.acceptableTimeLimit = acceptableTimeLimit;\n    this.maxTokenValidityInMs = maxTokenValidityInMs;\n  }\n\n  fromData(attestorDomain, acceptableTimeLimit = Timestamp_1.Timestamp.DEFAULT_TIME_LIMIT_MS, maxTokenValidityInMs = Timestamp_1.Timestamp.DEFAULT_TOKEN_TIME_LIMIT, identifier, attestationRequestWithUsage, signingKey = null) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.setDomain(attestorDomain);\n\n      if (signingKey) {\n        _this.userKey = signingKey;\n      }\n\n      try {\n        _this.acceptableTimeLimit = acceptableTimeLimit;\n        _this.maxTokenValidityInMs = maxTokenValidityInMs;\n        _this.attestationRequestWithUsage = attestationRequestWithUsage;\n        _this.jsonEncoding = yield _this.makeToken(identifier, attestationRequestWithUsage);\n      } catch (e) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, e);\n        throw new Error(\"Could not encode object\");\n      }\n\n      try {\n        _this.fillJsonData(_this.jsonEncoding);\n      } catch (e) {\n        throw new Error(\"Could not decode object\");\n      }\n    })();\n  }\n\n  Eip712AttestationRequestWithUsage(attestorDomain, acceptableTimeLimit, maxTokenValidityInMs, jsonEncoding) {\n    //TODO\n    // super(attestorDomain);\n    try {\n      this.acceptableTimeLimit = acceptableTimeLimit;\n      this.maxTokenValidityInMs = maxTokenValidityInMs;\n      this.jsonEncoding = jsonEncoding;\n      this.fillJsonData(this.jsonEncoding);\n    } catch (e) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, e);\n      throw new Error(\"Could not decode object\");\n    }\n  }\n\n  fillJsonData(json) {\n    if (!json) throw new Error('Empty json');\n    this.jsonEncoding = json;\n    let tokenData = JSON.parse(json);\n    let signatureInHex = tokenData.signatureInHex;\n    let jsonSigned = JSON.parse(tokenData.jsonSigned);\n    this.eip712DomainData = jsonSigned.domain;\n    this.data = jsonSigned.message;\n\n    try {\n      let publicKey = SignatureUtility_1.SignatureUtility.recoverPublicKeyFromTypedMessageSignature(jsonSigned, signatureInHex);\n      this.userPublicKey = KeyPair_1.KeyPair.fromPublicHex(publicKey.substr(2));\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, 'Eip712 withUsage restored address: ' + this.userPublicKey.getAddress());\n    } catch (e) {\n      let m = \"Recover Address failed with error:\" + e;\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, m, e);\n      throw new Error(m);\n    }\n\n    if (!this.attestationRequestWithUsage) {\n      this.attestationRequestWithUsage = AttestationRequestWithUsage_1.AttestationRequestWithUsage.fromBytes((0, utils_1.base64ToUint8array)(this.data.payload));\n    }\n\n    this.constructorCheck();\n  }\n\n  constructorCheck() {\n    if (!this.verify()) {\n      throw new Error(\"Could not verify Eip712 use attestation\");\n    }\n  }\n\n  makeToken(identifier, attestationRequestWithUsage) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2.userKey) {\n        yield SignatureUtility_1.SignatureUtility.connectMetamaskAndGetAddress();\n      }\n\n      let ts = new Timestamp_1.Timestamp().getTimeAsString();\n      let expirationTime = new Timestamp_1.Timestamp(Date.now() + _this2.maxTokenValidityInMs).getTimeAsString();\n      let userData = {\n        payload: (0, utils_1.hexStringToBase64Url)(attestationRequestWithUsage.getDerEncoding()),\n        description: _this2.Eip712UserDataDescription,\n        timestamp: ts,\n        identifier: identifier,\n        expirationTime: expirationTime\n      };\n      return yield SignatureUtility_1.SignatureUtility.signEIP712WithBrowserWallet(_this2.domain, userData, _this2.Eip712UserDataTypes, _this2.Eip712UserDataPrimaryName, _this2.userKey);\n    })();\n  }\n\n  getIdentifier() {\n    return this.data.identifier;\n  }\n\n  getUserPublicKey() {\n    return this.userPublicKey;\n  }\n\n  getPok() {\n    return this.attestationRequestWithUsage.getPok();\n  }\n\n  getType() {\n    return this.attestationRequestWithUsage.getType();\n  }\n\n  getSessionPublicKey() {\n    return this.attestationRequestWithUsage.getSessionPublicKey();\n  }\n\n  getJsonEncoding() {\n    return this.jsonEncoding;\n  }\n  /**\n   * Verify that an attestation can be issued. I.e. the nonce is not expired\n   */\n\n\n  checkValidity() {\n    if (!this.testNonceAndDescription(this.acceptableTimeLimit)) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Verify that the object can be used as a usage token. I.e. the token timestamp has not expired.\n   * Note that the object can still be used as a token after the nonce for issuance has expired.\n   */\n\n\n  checkTokenValidity() {\n    let time = new Timestamp_1.Timestamp(this.data.timestamp);\n    time.setValidity(this.maxTokenValidityInMs);\n\n    if (!time.validateAgainstExpiration(Timestamp_1.Timestamp.stringTimestampToLong(this.data.expirationTime))) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'time.validateAgainstExpiration filed');\n      return false;\n    } // Nonce validation must still happen since this also verifies user's address and receiver's domain\n\n\n    if (!this.testNonceAndDescription(this.maxTokenValidityInMs)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  testNonceAndDescription(timeLimit) {\n    if (!timeLimit) {\n      throw new Error('timeLimit required');\n    }\n\n    let nonceMinTime = Timestamp_1.Timestamp.stringTimestampToLong(this.data.timestamp) - timeLimit;\n    let nonceMaxTime = Timestamp_1.Timestamp.stringTimestampToLong(this.data.timestamp) + timeLimit;\n\n    if (!new Nonce_1.Nonce().validateNonce(this.attestationRequestWithUsage.getPok().getNonce(), this.userPublicKey.getAddress(), this.domain, nonceMinTime, nonceMaxTime)) {\n      return false;\n    }\n\n    if (this.data.description !== this.Eip712UserDataDescription) {\n      return false;\n    }\n\n    return true;\n  }\n\n  verify() {\n    if (!this.attestationRequestWithUsage.verify()) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nexports.Eip712AttestationRequestWithUsage = Eip712AttestationRequestWithUsage; //# sourceMappingURL=Eip712AttestationRequestWithUsage.js.map","map":null,"metadata":{},"sourceType":"script"}