{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Eip712AttestationUsage = void 0;\n\nconst KeyPair_1 = require(\"./KeyPair\");\n\nconst SignatureUtility_1 = require(\"./SignatureUtility\");\n\nconst Eip712Token_1 = require(\"./Eip712Token\");\n\nconst UseAttestation_1 = require(\"./UseAttestation\");\n\nconst utils_1 = require(\"./utils\");\n\nconst AttestationCrypto_1 = require(\"./AttestationCrypto\");\n\nconst Point_1 = require(\"./Point\");\n\nconst Nonce_1 = require(\"./Nonce\");\n\nconst Timestamp_1 = require(\"./Timestamp\");\n\nconst config_1 = require(\"../config\");\n\nclass Eip712AttestationUsage extends Eip712Token_1.Eip712Token {\n  constructor(userKey = null, maxTokenValidityInMs = Timestamp_1.Timestamp.DEFAULT_TOKEN_TIME_LIMIT) {\n    super();\n    this.PLACEHOLDER_CHAIN_ID = 0;\n    this.Eip712PrimaryName = \"AttestationUsage\";\n    this.Eip712Description = \"Prove that the \\\"identifier\\\" is the identifier hidden in attestation contained in\\\"payload\\\".\";\n    this.Eip712UserTypes = [{\n      name: 'description',\n      type: 'string'\n    }, {\n      name: 'identifier',\n      type: 'string'\n    }, {\n      name: 'payload',\n      type: 'string'\n    }, {\n      name: 'timestamp',\n      type: 'string'\n    }, {\n      name: 'expirationTime',\n      type: 'string'\n    }];\n    this.maxTokenValidityInMs = maxTokenValidityInMs;\n    this.userKey = userKey;\n  } // TODO make signingKey universal\n\n\n  addData(attestorDomain, identifier, useAttestation) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.setDomain(attestorDomain);\n\n      _this.useAttestation = useAttestation;\n\n      try {\n        _this.jsonEncoding = yield _this.makeToken(identifier, useAttestation);\n      } catch (e) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, e);\n        throw new Error(\"Could not encode object. \" + e);\n      }\n\n      try {\n        // decode JSON and fill publicKey\n        _this.fillJsonData(_this.jsonEncoding);\n      } catch (e) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, e);\n        return false;\n      }\n\n      _this.constructorCheck();\n    })();\n  }\n\n  fillJsonData(json, attestorKey = null) {\n    if (!json) {\n      throw new Error('Empty json');\n    }\n\n    if (attestorKey !== null) {\n      this.attestorKey = attestorKey;\n    }\n\n    this.jsonEncoding = json;\n    let tokenData = JSON.parse(json);\n    let signatureInHex = tokenData.signatureInHex;\n    let jsonSigned = JSON.parse(tokenData.jsonSigned);\n    this.eip712DomainData = jsonSigned.domain;\n    this.data = jsonSigned.message;\n\n    try {\n      let publicKey = SignatureUtility_1.SignatureUtility.recoverPublicKeyFromTypedMessageSignature(jsonSigned, signatureInHex);\n      this.requestorKeys = KeyPair_1.KeyPair.fromPublicHex(publicKey.substr(2));\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, 'restored address: ' + this.requestorKeys.getAddress());\n    } catch (e) {\n      let m = \"Recover Address failed with error:\" + e;\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, m, e);\n      throw new Error(m);\n    }\n\n    if (!this.useAttestation) {\n      try {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.VERBOSE, (0, utils_1.uint8tohex)((0, utils_1.base64ToUint8array)(this.data.payload)));\n        this.useAttestation = UseAttestation_1.UseAttestation.fromBytes((0, utils_1.base64ToUint8array)(this.data.payload), this.attestorKey);\n      } catch (e) {\n        let m = \"Failed to read UseAttestation. \" + e;\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.MEDIUM, m, e);\n        throw new Error(m);\n      }\n    }\n\n    this.constructorCheck();\n  }\n\n  constructorCheck() {\n    if (!this.verify()) {\n      throw new Error(\"Could not verify Eip712 use attestation\");\n    }\n  } // use Att\n\n\n  makeToken(identifier, useAttestation) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2.userKey) {\n        yield SignatureUtility_1.SignatureUtility.connectMetamaskAndGetAddress();\n      }\n\n      let userData = {\n        payload: (0, utils_1.hexStringToBase64Url)(useAttestation.getDerEncoding()),\n        description: _this2.Eip712Description,\n        timestamp: new Timestamp_1.Timestamp().getTimeAsString(),\n        identifier: identifier,\n        expirationTime: new Timestamp_1.Timestamp(Date.now() + _this2.maxTokenValidityInMs).getTimeAsString()\n      };\n      return yield SignatureUtility_1.SignatureUtility.signEIP712WithBrowserWallet(_this2.domain, userData, _this2.Eip712UserTypes, _this2.Eip712PrimaryName, _this2.userKey);\n    })();\n  }\n\n  proofLinking() {\n    let crypto = new AttestationCrypto_1.AttestationCrypto();\n    let candidateExponent = crypto.mapToCurveMultiplier(this.getType(), this.getIdentifier());\n    let commitmentPoint = Point_1.Point.decodeFromUint8(this.getAttestation().getUnsignedAttestation().getCommitment(), Point_1.CURVE_BN256);\n    let candidateRiddle = commitmentPoint.subtract(AttestationCrypto_1.Pedestren_G.multiplyDA(candidateExponent));\n\n    if (!candidateRiddle.equals(this.getPok().getRiddle())) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'candidateRiddle.equals(this.getPok().getRiddle()) error');\n      return false;\n    }\n\n    return true;\n  }\n\n  getPok() {\n    return this.useAttestation.getPok();\n  }\n\n  getType() {\n    return this.useAttestation.type;\n  }\n\n  getIdentifier() {\n    return this.data.identifier;\n  }\n\n  getAttestation() {\n    return this.useAttestation.getAttestation();\n  }\n\n  getJsonEncoding() {\n    return this.jsonEncoding;\n  }\n\n  checkTokenValidity() {\n    let nonceMinTime = Timestamp_1.Timestamp.stringTimestampToLong(this.data.expirationTime) - this.maxTokenValidityInMs - 2 * Timestamp_1.Timestamp.ALLOWED_ROUNDING;\n    let nonceMaxTime = Timestamp_1.Timestamp.stringTimestampToLong(this.data.expirationTime);\n\n    if (!this.useAttestation.checkValidity()) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'useAttestation.checkValidity failed');\n      return false;\n    }\n\n    ;\n\n    if (this.data.description != this.Eip712Description) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, `wrong description: \"${this.data.description}\", must be \"${this.Eip712Description}\"`);\n      return false;\n    }\n\n    ;\n    let time = new Timestamp_1.Timestamp(this.data.timestamp);\n    time.setValidity(this.maxTokenValidityInMs);\n\n    if (!time.validateAgainstExpiration(Timestamp_1.Timestamp.stringTimestampToLong(this.data.expirationTime))) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'verify timestamp failed.\\n' + this.data.timestamp + \"\\n\" + this.maxTokenValidityInMs + \"\\n\" + this.data.expirationTime + \"\\n\" + Timestamp_1.Timestamp.stringTimestampToLong(this.data.expirationTime) + \"\\n\");\n      return false;\n    }\n\n    if (this.requestorKeys.getAddress().toLowerCase() !== this.useAttestation.getAttestation().getUnsignedAttestation().getAddress().toLowerCase()) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'wrong address');\n      return false;\n    }\n\n    ;\n\n    if (!new Nonce_1.Nonce().validateNonce(this.useAttestation.getPok().getNonce(), this.useAttestation.getAttestation().getUnsignedAttestation().getAddress(), this.domain, nonceMinTime, nonceMaxTime)) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'wrong Nonce');\n      return false;\n    }\n\n    ;\n\n    if (!this.proofLinking()) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'wrong proofLinking');\n      return false;\n    }\n\n    ;\n    return true;\n  }\n\n  verify() {\n    if (!this.useAttestation.verify()) {\n      return false;\n    }\n\n    return true;\n  }\n\n  getSessionPublicKey() {\n    return this.useAttestation.getSessionPublicKey();\n  }\n\n}\n\nexports.Eip712AttestationUsage = Eip712AttestationUsage; //# sourceMappingURL=Eip712AttestationUsage.js.map","map":null,"metadata":{},"sourceType":"script"}