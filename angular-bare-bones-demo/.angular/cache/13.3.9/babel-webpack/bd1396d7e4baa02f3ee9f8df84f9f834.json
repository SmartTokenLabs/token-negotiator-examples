{"ast":null,"code":"const inherits = require('util').inherits;\n\nconst Transaction = require('ethereumjs-tx');\n\nconst ethUtil = require('ethereumjs-util');\n\nconst Subprovider = require('./subprovider.js');\n\nconst blockTagForPayload = require('../util/rpc-cache-utils').blockTagForPayload;\n\nmodule.exports = NonceTrackerSubprovider; // handles the following RPC methods:\n//   eth_getTransactionCount (pending only)\n//\n// observes the following RPC methods:\n//   eth_sendRawTransaction\n//   evm_revert (to clear the nonce cache)\n\ninherits(NonceTrackerSubprovider, Subprovider);\n\nfunction NonceTrackerSubprovider(opts) {\n  const self = this;\n  self.nonceCache = {};\n}\n\nNonceTrackerSubprovider.prototype.handleRequest = function (payload, next, end) {\n  const self = this;\n\n  switch (payload.method) {\n    case 'eth_getTransactionCount':\n      var blockTag = blockTagForPayload(payload);\n      var address = payload.params[0].toLowerCase();\n      var cachedResult = self.nonceCache[address]; // only handle requests against the 'pending' blockTag\n\n      if (blockTag === 'pending') {\n        // has a result\n        if (cachedResult) {\n          end(null, cachedResult); // fallthrough then populate cache\n        } else {\n          next(function (err, result, cb) {\n            if (err) return cb();\n\n            if (self.nonceCache[address] === undefined) {\n              self.nonceCache[address] = result;\n            }\n\n            cb();\n          });\n        }\n      } else {\n        next();\n      }\n\n      return;\n\n    case 'eth_sendRawTransaction':\n      // allow the request to continue normally\n      next(function (err, result, cb) {\n        // only update local nonce if tx was submitted correctly\n        if (err) return cb(); // parse raw tx\n\n        var rawTx = payload.params[0];\n        var stripped = ethUtil.stripHexPrefix(rawTx);\n        var rawData = Buffer.from(ethUtil.stripHexPrefix(rawTx), 'hex');\n        var tx = new Transaction(Buffer.from(ethUtil.stripHexPrefix(rawTx), 'hex')); // extract address\n\n        var address = '0x' + tx.getSenderAddress().toString('hex').toLowerCase(); // extract nonce and increment\n\n        var nonce = ethUtil.bufferToInt(tx.nonce);\n        nonce++; // hexify and normalize\n\n        var hexNonce = nonce.toString(16);\n        if (hexNonce.length % 2) hexNonce = '0' + hexNonce;\n        hexNonce = '0x' + hexNonce; // dont update our record on the nonce until the submit was successful\n        // update cache\n\n        self.nonceCache[address] = hexNonce;\n        cb();\n      });\n      return;\n    // Clear cache on a testrpc revert\n\n    case 'evm_revert':\n      self.nonceCache = {};\n      next();\n      return;\n\n    default:\n      next();\n      return;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}