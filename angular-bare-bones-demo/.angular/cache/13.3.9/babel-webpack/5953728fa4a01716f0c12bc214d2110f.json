{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Attestation = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst asn1_schema_1 = require(\"@peculiar/asn1-schema\");\n\nconst AttestationFramework_1 = require(\"../asn1/shemas/AttestationFramework\");\n\nconst KeyPair_1 = require(\"./KeyPair\");\n\nconst DerUtility_1 = require(\"./DerUtility\");\n\nconst Timestamp_1 = require(\"./Timestamp\");\n\nconst config_1 = require(\"../config\");\n\nclass Attestation {\n  constructor() {\n    this.version = 18; // = 0x10+0x02 where 0x02 means x509 v3 (v1 has version 0) and 0x10 is Attestation v 0\n\n    this.blockchainFriendly = true;\n  }\n\n  parseNames(rdn) {\n    let invertedX500NamesLabels = {};\n    Object.keys(DerUtility_1.X500NamesLabels).forEach(key => {\n      invertedX500NamesLabels[DerUtility_1.X500NamesLabels[key].toLowerCase()] = key;\n    });\n    let nameArray = [];\n    rdn.forEach(obj => {\n      let type = invertedX500NamesLabels[obj.type.toString().toLowerCase()];\n      if (!type) throw new Error(`X500 with name ${obj.type.toString()} not implemented yet.`);\n      nameArray.push(`${type}=\"${obj.value}\"`);\n    });\n    return nameArray.join(',');\n  }\n\n  fromBytes(uint8bytes) {\n    const me = this;\n    let decodedAttestationObj = asn1_schema_1.AsnParser.parse(uint8bytes, AttestationFramework_1.SignedInfo);\n    me.signedInfo = uint8bytes;\n    me.version = decodedAttestationObj.version.version;\n    me.serialNumber = decodedAttestationObj.serialNumber;\n    me.signingAlgorithm = decodedAttestationObj.signature.algorithm.toString();\n\n    if (decodedAttestationObj.validity) {\n      me.notValidBefore = decodedAttestationObj.validity.notBefore.generalizedTime.getTime();\n      me.notValidAfter = decodedAttestationObj.validity.notAfter.generalizedTime.getTime(); // TODO validate time when it will be updated in Java code\n      // if (\n      //     (decodedAttestationObj.validity.notAfterInt && (decodedAttestationObj.validity.notAfterInt != Math.floor( me.notValidAfter / 1000 ) )) ||\n      //     (decodedAttestationObj.validity.notBeforeInt && (decodedAttestationObj.validity.notBeforeInt != Math.floor( me.notValidBefore / 1000 ) ))\n      // ) {\n      //     throw new Error(\"Date doesnt fit\");\n      // }\n\n      if (typeof decodedAttestationObj.validity.notBeforeInt === 'undefined' || typeof decodedAttestationObj.validity.notAfterInt === 'undefined') {\n        this.blockchainFriendly = false;\n      } else {\n        this.blockchainFriendly = true;\n      }\n    }\n\n    let rdn = decodedAttestationObj.subject.rdnSequence;\n    me.subject = \"\";\n\n    if (rdn && rdn[0] && rdn[0].length) {\n      me.subject = this.parseNames(rdn[0]);\n    }\n\n    me.subjectKey = KeyPair_1.KeyPair.publicFromSubjectPublicKeyInfo(decodedAttestationObj.subjectPublicKeyInfo);\n    let issuerSet = decodedAttestationObj.issuer.rdnSequence;\n    me.issuer = '';\n\n    if (issuerSet.length) {\n      me.issuer = this.parseNames(issuerSet[0]);\n    }\n\n    if (decodedAttestationObj.contract) {\n      me.smartcontracts = decodedAttestationObj.contract;\n    }\n\n    if (decodedAttestationObj.attestsTo && decodedAttestationObj.attestsTo.extensions) {\n      me.extensions = decodedAttestationObj.attestsTo.extensions;\n      me.commitment = new Uint8Array(me.extensions.extension.extnValue);\n    } else if (decodedAttestationObj.attestsTo && decodedAttestationObj.attestsTo.dataObject) {\n      throw new Error(\"Implement parse dataObject\"); // TODO parse dataObject\n      //this.extensions = decodedAttestationObj.attestsTo.dataObject;\n    }\n  }\n\n  isValidX509() {\n    if (this.version != 0 && this.version != 1 && this.version != 2) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Incorrect version number\");\n      return false;\n    }\n\n    if (!this.issuer) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Issuer info not set\");\n      return false;\n    }\n\n    if (this.notValidBefore == null || this.notValidAfter == null) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Validity period not set\");\n      return false;\n    }\n\n    if (this.subject == null) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Subject info not set\");\n      return false;\n    }\n\n    if (!this.subjectKey) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"No subject public key info set\");\n      return false;\n    }\n\n    if (this.smartcontracts != null) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Smart contract info set\");\n      return false;\n    }\n\n    if (this.dataObject != null) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Data object set\");\n      return false;\n    }\n\n    if (this.version == null || this.serialNumber == null || this.signingAlgorithm == null) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Version, serial number, subject or algorithm missing\");\n      return false;\n    }\n\n    return true;\n  }\n\n  getDerEncoding() {\n    if (!this.signedInfo) {\n      this.signedInfo = this.getPrehash();\n    }\n\n    if (!this.signedInfo) {\n      throw new Error('Empty Attestaion Der Encoding');\n    }\n\n    return (0, utils_1.uint8tohex)(new Uint8Array(this.signedInfo));\n  }\n\n  getCommitment() {\n    return this.commitment;\n  }\n\n  getNotValidBefore() {\n    return this.notValidBefore;\n  }\n\n  setNotValidBefore(d) {\n    this.notValidBefore = d;\n  }\n\n  getNotValidAfter() {\n    return this.notValidAfter;\n  }\n\n  setNotValidAfter(d) {\n    this.notValidAfter = d;\n  }\n\n  getSubjectPublicKeyInfo() {\n    return this.subjectKey;\n  }\n\n  checkValidity() {\n    if (this.version == null) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Attest version missed\");\n      return false;\n    }\n\n    if (this.serialNumber == null) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Attest serial number missed\");\n      return false;\n    }\n\n    if (this.subject == null) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Attest subject missed\");\n      return false;\n    }\n\n    if (this.signingAlgorithm == null) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Attest signing algorithm missed\");\n      return false;\n    }\n\n    let attNotBefore = this.getNotValidBefore();\n    let attNotAfter = this.getNotValidAfter();\n    let timestamp = new Timestamp_1.Timestamp(attNotBefore);\n    timestamp.setValidity(attNotAfter - attNotBefore);\n\n    if (!timestamp.validateAgainstExpiration(attNotAfter)) {\n      return false;\n    }\n\n    if (this.extensions != null && this.dataObject != null) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Both Extensions and dataObject not allowed\");\n      return false;\n    }\n\n    return true;\n  }\n\n  getExtensions() {\n    return this.extensions;\n  }\n\n  setVersion(version) {\n    this.version = version;\n  }\n\n  getVersion() {\n    return this.version;\n  }\n\n  setSubject(subject) {\n    this.subject = subject;\n  }\n\n  getSubject() {\n    return this.subject;\n  }\n\n  setSigningAlgorithm(alg) {\n    this.signingAlgorithm = alg;\n  }\n\n  getPrehash() {\n    if (!this.checkValidity()) {\n      return null;\n    } // = 0x10+0x02 where 0x02 means x509 v3 (v1 has version 0) and 0x10 is Attestation v 0\n    // new DERTaggedObject(true, 0, this.version);\n\n\n    let res = DerUtility_1.Asn1Der.encode('TAG', DerUtility_1.Asn1Der.encode('INTEGER', this.version), 0) + DerUtility_1.Asn1Der.encode('INTEGER', this.serialNumber) // TODO verify encoding!!!\n    + DerUtility_1.Asn1Der.encodeObjectId(this.signingAlgorithm);\n    res += this.issuer ? DerUtility_1.Asn1Der.encodeName(this.issuer) : DerUtility_1.Asn1Der.encode('NULL_VALUE', '');\n\n    if (this.notValidAfter != null && this.notValidBefore != null) {\n      let date = DerUtility_1.Asn1Der.encode('GENERALIZED_TIME', this.notValidBefore) + (this.blockchainFriendly ? DerUtility_1.Asn1Der.encode('INTEGER', Math.floor(this.notValidBefore / 1000)) : \"\") + DerUtility_1.Asn1Der.encode('GENERALIZED_TIME', this.notValidAfter) + (this.blockchainFriendly ? DerUtility_1.Asn1Der.encode('INTEGER', Math.floor(this.notValidAfter / 1000)) : \"\");\n      res += DerUtility_1.Asn1Der.encode('SEQUENCE_30', date);\n    } else {\n      res += DerUtility_1.Asn1Der.encode('NULL_VALUE', '');\n    } // res.add(this.subject == null ? new DERSequence() : this.subject);\n    // res += this.subject ? Asn1Der.encodeName(this.subject) : Asn1Der.encode('NULL_VALUE','');\n\n\n    res += this.subject ? DerUtility_1.Asn1Der.encodeName(this.subject) : DerUtility_1.Asn1Der.encode('NULL_VALUE', '');\n    res += this.subjectKey ? this.subjectKey.getAsnDerPublic() : DerUtility_1.Asn1Der.encode('NULL_VALUE', '');\n\n    if (this.smartcontracts != null) {\n      res += this.smartcontracts;\n    } // if (this.commitment && this.commitment.length){\n    //     let extensions: string = Asn1Der.encode('OBJECT_ID', Attestation.OID_OCTETSTRING)\n    //         + Asn1Der.encode('BOOLEAN', 1)\n    //         + Asn1Der.encode('OCTET_STRING', uint8tohex(this.commitment));\n    //     // Double Sequence is needed to be compatible with X509V3\n    //     res += Asn1Der.encode('TAG',Asn1Der.encode('SEQUENCE_30', Asn1Der.encode('SEQUENCE_30', extensions)),3);\n    // }\n    // The validity check ensure that only one of \"extensions\" and \"dataObject\" is set\n\n\n    if (this.extensions != null) {\n      res += DerUtility_1.Asn1Der.encode('TAG', DerUtility_1.Asn1Der.encode('SEQUENCE_30', DerUtility_1.Asn1Der.encode('SEQUENCE_30', this.extensions)), 3);\n    }\n\n    if (this.dataObject != null) {\n      res += DerUtility_1.Asn1Der.encode('TAG', DerUtility_1.Asn1Der.encode('SEQUENCE_30', DerUtility_1.Asn1Der.encode('SEQUENCE_30', this.dataObject)), 4);\n    }\n\n    return (0, utils_1.hexStringToUint8)(DerUtility_1.Asn1Der.encode('SEQUENCE_30', res));\n  }\n\n  getSigningAlgorithm() {\n    return this.signingAlgorithm;\n  }\n\n}\n\nexports.Attestation = Attestation;\nAttestation.OID_OCTETSTRING = \"1.3.6.1.4.1.1466.115.121.1.40\"; //# sourceMappingURL=Attestation.js.map","map":null,"metadata":{},"sourceType":"script"}