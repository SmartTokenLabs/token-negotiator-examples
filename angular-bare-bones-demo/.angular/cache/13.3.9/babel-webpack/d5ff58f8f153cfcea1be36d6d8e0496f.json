{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst cacheUtils = require('./cache-utils.js');\n\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware'); // `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\n\n\nconst emptyValues = [undefined, null, '\\u003cnil\\u003e'];\nmodule.exports = createBlockCacheMiddleware;\n\nfunction createBlockCacheMiddleware(opts = {}) {\n  // validate options\n  const {\n    blockTracker\n  } = opts;\n  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified'); // create caching strategies\n\n  const blockCache = new BlockCacheStrategy();\n  const strategies = {\n    perma: blockCache,\n    block: blockCache,\n    fork: blockCache\n  };\n  return createAsyncMiddleware( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (req, res, next) {\n      // allow cach to be skipped if so specified\n      if (req.skipCache) {\n        return next();\n      } // check type and matching strategy\n\n\n      const type = cacheUtils.cacheTypeForPayload(req);\n      const strategy = strategies[type]; // If there's no strategy in place, pass it down the chain.\n\n      if (!strategy) {\n        return next();\n      } // If the strategy can't cache this request, ignore it.\n\n\n      if (!strategy.canCacheRequest(req)) {\n        return next();\n      } // get block reference (number or keyword)\n\n\n      let blockTag = cacheUtils.blockTagForPayload(req);\n      if (!blockTag) blockTag = 'latest'; // get exact block number\n\n      let requestedBlockNumber;\n\n      if (blockTag === 'earliest') {\n        // this just exists for symmetry with \"latest\"\n        requestedBlockNumber = '0x00';\n      } else if (blockTag === 'latest') {\n        // fetch latest block number\n        const latestBlockNumber = yield blockTracker.getLatestBlock(); // clear all cache before latest block\n\n        blockCache.clearBefore(latestBlockNumber);\n        requestedBlockNumber = latestBlockNumber;\n      } else {\n        // We have a hex number\n        requestedBlockNumber = blockTag;\n      } // end on a hit, continue on a miss\n\n\n      const cacheResult = yield strategy.get(req, requestedBlockNumber);\n\n      if (cacheResult === undefined) {\n        // cache miss\n        // wait for other middleware to handle request\n        yield next(); // add result to cache\n\n        yield strategy.set(req, requestedBlockNumber, res.result);\n      } else {\n        // fill in result from cache\n        res.result = cacheResult;\n      }\n    });\n\n    return function (_x, _x2, _x3) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n} //\n// Cache Strategies\n//\n\n\nclass BlockCacheStrategy {\n  constructor() {\n    this.cache = {};\n  }\n\n  getBlockCacheForPayload(payload, blockNumberHex) {\n    const blockNumber = Number.parseInt(blockNumberHex, 16);\n    let blockCache = this.cache[blockNumber]; // create new cache if necesary\n\n    if (!blockCache) {\n      const newCache = {};\n      this.cache[blockNumber] = newCache;\n      blockCache = newCache;\n    }\n\n    return blockCache;\n  }\n\n  get(payload, requestedBlockNumber) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // lookup block cache\n      const blockCache = _this.getBlockCacheForPayload(payload, requestedBlockNumber);\n\n      if (!blockCache) return; // lookup payload in block cache\n\n      const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n      const cached = blockCache[identifier]; // may be undefined\n\n      return cached;\n    })();\n  }\n\n  set(payload, requestedBlockNumber, result) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // check if we can cached this result\n      const canCache = _this2.canCacheResult(payload, result);\n\n      if (!canCache) return; // set the value in the cache\n\n      const blockCache = _this2.getBlockCacheForPayload(payload, requestedBlockNumber);\n\n      const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n      blockCache[identifier] = result;\n    })();\n  }\n\n  canCacheRequest(payload) {\n    // check request method\n    if (!cacheUtils.canCache(payload)) {\n      return false;\n    } // check blockTag\n\n\n    const blockTag = cacheUtils.blockTagForPayload(payload);\n\n    if (blockTag === 'pending') {\n      return false;\n    } // can be cached\n\n\n    return true;\n  }\n\n  canCacheResult(payload, result) {\n    // never cache empty values (e.g. undefined)\n    if (emptyValues.includes(result)) return; // check if transactions have block reference before caching\n\n    if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {\n      if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n        return false;\n      }\n    } // otherwise true\n\n\n    return true;\n  } // removes all block caches with block number lower than `oldBlockHex`\n\n\n  clearBefore(oldBlockHex) {\n    const self = this;\n    const oldBlockNumber = Number.parseInt(oldBlockHex, 16); // clear old caches\n\n    Object.keys(self.cache).map(Number).filter(num => num < oldBlockNumber).forEach(num => delete self.cache[num]);\n  }\n\n}","map":null,"metadata":{},"sourceType":"script"}