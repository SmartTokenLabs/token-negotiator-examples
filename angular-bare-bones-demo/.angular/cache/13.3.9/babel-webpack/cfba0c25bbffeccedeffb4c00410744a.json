{"ast":null,"code":"/*!\n * Copyright (c) 2014, GMO GlobalSign\n * Copyright (c) 2015-2022, Peculiar Ventures\n * All rights reserved.\n * \n * Author 2014-2019, Yury Strozhevsky\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n * \n * * Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n * \n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n */\nimport * as pvtsutils from 'pvtsutils';\nimport * as pvutils from 'pvutils';\n\nfunction assertBigInt() {\n  if (typeof BigInt === \"undefined\") {\n    throw new Error(\"BigInt is not defined. Your environment doesn't implement BigInt.\");\n  }\n}\n\nfunction concat(buffers) {\n  let outputLength = 0;\n  let prevLength = 0;\n\n  for (let i = 0; i < buffers.length; i++) {\n    const buffer = buffers[i];\n    outputLength += buffer.byteLength;\n  }\n\n  const retView = new Uint8Array(outputLength);\n\n  for (let i = 0; i < buffers.length; i++) {\n    const buffer = buffers[i];\n    retView.set(new Uint8Array(buffer), prevLength);\n    prevLength += buffer.byteLength;\n  }\n\n  return retView.buffer;\n}\n\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\n  if (!(inputBuffer instanceof Uint8Array)) {\n    baseBlock.error = \"Wrong parameter: inputBuffer must be 'Uint8Array'\";\n    return false;\n  }\n\n  if (!inputBuffer.byteLength) {\n    baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\n    return false;\n  }\n\n  if (inputOffset < 0) {\n    baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\n    return false;\n  }\n\n  if (inputLength < 0) {\n    baseBlock.error = \"Wrong parameter: inputLength less than zero\";\n    return false;\n  }\n\n  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {\n    baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n    return false;\n  }\n\n  return true;\n}\n\nclass ViewWriter {\n  constructor() {\n    this.items = [];\n  }\n\n  write(buf) {\n    this.items.push(buf);\n  }\n\n  final() {\n    return concat(this.items);\n  }\n\n}\n\nconst powers2 = [new Uint8Array([1])];\nconst digitsString = \"0123456789\";\nconst NAME = \"name\";\nconst VALUE_HEX_VIEW = \"valueHexView\";\nconst IS_HEX_ONLY = \"isHexOnly\";\nconst ID_BLOCK = \"idBlock\";\nconst TAG_CLASS = \"tagClass\";\nconst TAG_NUMBER = \"tagNumber\";\nconst IS_CONSTRUCTED = \"isConstructed\";\nconst FROM_BER = \"fromBER\";\nconst TO_BER = \"toBER\";\nconst LOCAL = \"local\";\nconst EMPTY_STRING = \"\";\nconst EMPTY_BUFFER = new ArrayBuffer(0);\nconst EMPTY_VIEW = new Uint8Array(0);\nconst END_OF_CONTENT_NAME = \"EndOfContent\";\nconst OCTET_STRING_NAME = \"OCTET STRING\";\nconst BIT_STRING_NAME = \"BIT STRING\";\n\nfunction HexBlock(BaseClass) {\n  var _a;\n\n  return _a = class Some extends BaseClass {\n    constructor(...args) {\n      var _a;\n\n      super(...args);\n      const params = args[0] || {};\n      this.isHexOnly = (_a = params.isHexOnly) !== null && _a !== void 0 ? _a : false;\n      this.valueHexView = params.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;\n    }\n\n    get valueHex() {\n      return this.valueHexView.slice().buffer;\n    }\n\n    set valueHex(value) {\n      this.valueHexView = new Uint8Array(value);\n    }\n\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\n\n      if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n        return -1;\n      }\n\n      const endLength = inputOffset + inputLength;\n      this.valueHexView = view.subarray(inputOffset, endLength);\n\n      if (!this.valueHexView.length) {\n        this.warnings.push(\"Zero buffer length\");\n        return inputOffset;\n      }\n\n      this.blockLength = inputLength;\n      return endLength;\n    }\n\n    toBER(sizeOnly = false) {\n      if (!this.isHexOnly) {\n        this.error = \"Flag 'isHexOnly' is not set, abort\";\n        return EMPTY_BUFFER;\n      }\n\n      if (sizeOnly) {\n        return new ArrayBuffer(this.valueHexView.byteLength);\n      }\n\n      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;\n    }\n\n    toJSON() {\n      return { ...super.toJSON(),\n        isHexOnly: this.isHexOnly,\n        valueHex: pvtsutils.Convert.ToHex(this.valueHexView)\n      };\n    }\n\n  }, _a.NAME = \"hexBlock\", _a;\n}\n\nlet LocalBaseBlock = /*#__PURE__*/(() => {\n  class LocalBaseBlock {\n    constructor({\n      blockLength = 0,\n      error = EMPTY_STRING,\n      warnings = [],\n      valueBeforeDecode = EMPTY_VIEW\n    } = {}) {\n      this.blockLength = blockLength;\n      this.error = error;\n      this.warnings = warnings;\n      this.valueBeforeDecodeView = pvtsutils.BufferSourceConverter.toUint8Array(valueBeforeDecode);\n    }\n\n    static blockName() {\n      return this.NAME;\n    }\n\n    get valueBeforeDecode() {\n      return this.valueBeforeDecodeView.slice().buffer;\n    }\n\n    set valueBeforeDecode(value) {\n      this.valueBeforeDecodeView = new Uint8Array(value);\n    }\n\n    toJSON() {\n      return {\n        blockName: this.constructor.NAME,\n        blockLength: this.blockLength,\n        error: this.error,\n        warnings: this.warnings,\n        valueBeforeDecode: pvtsutils.Convert.ToHex(this.valueBeforeDecodeView)\n      };\n    }\n\n  }\n\n  LocalBaseBlock.NAME = \"baseBlock\";\n  return LocalBaseBlock;\n})();\nlet ValueBlock = /*#__PURE__*/(() => {\n  class ValueBlock extends LocalBaseBlock {\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\n    }\n\n    toBER(sizeOnly, writer) {\n      throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\n    }\n\n  }\n\n  ValueBlock.NAME = \"valueBlock\";\n  return ValueBlock;\n})();\nlet LocalIdentificationBlock = /*#__PURE__*/(() => {\n  class LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {\n    constructor({\n      idBlock = {}\n    } = {}) {\n      var _a, _b, _c, _d;\n\n      super();\n\n      if (idBlock) {\n        this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;\n        this.valueHexView = idBlock.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;\n        this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;\n        this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;\n        this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;\n      } else {\n        this.tagClass = -1;\n        this.tagNumber = -1;\n        this.isConstructed = false;\n      }\n    }\n\n    toBER(sizeOnly = false) {\n      let firstOctet = 0;\n\n      switch (this.tagClass) {\n        case 1:\n          firstOctet |= 0x00;\n          break;\n\n        case 2:\n          firstOctet |= 0x40;\n          break;\n\n        case 3:\n          firstOctet |= 0x80;\n          break;\n\n        case 4:\n          firstOctet |= 0xC0;\n          break;\n\n        default:\n          this.error = \"Unknown tag class\";\n          return EMPTY_BUFFER;\n      }\n\n      if (this.isConstructed) firstOctet |= 0x20;\n\n      if (this.tagNumber < 31 && !this.isHexOnly) {\n        const retView = new Uint8Array(1);\n\n        if (!sizeOnly) {\n          let number = this.tagNumber;\n          number &= 0x1F;\n          firstOctet |= number;\n          retView[0] = firstOctet;\n        }\n\n        return retView.buffer;\n      }\n\n      if (!this.isHexOnly) {\n        const encodedBuf = pvutils.utilToBase(this.tagNumber, 7);\n        const encodedView = new Uint8Array(encodedBuf);\n        const size = encodedBuf.byteLength;\n        const retView = new Uint8Array(size + 1);\n        retView[0] = firstOctet | 0x1F;\n\n        if (!sizeOnly) {\n          for (let i = 0; i < size - 1; i++) retView[i + 1] = encodedView[i] | 0x80;\n\n          retView[size] = encodedView[size - 1];\n        }\n\n        return retView.buffer;\n      }\n\n      const retView = new Uint8Array(this.valueHexView.byteLength + 1);\n      retView[0] = firstOctet | 0x1F;\n\n      if (!sizeOnly) {\n        const curView = this.valueHexView;\n\n        for (let i = 0; i < curView.length - 1; i++) retView[i + 1] = curView[i] | 0x80;\n\n        retView[this.valueHexView.byteLength] = curView[curView.length - 1];\n      }\n\n      return retView.buffer;\n    }\n\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n\n      if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n        return -1;\n      }\n\n      const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n\n      if (intBuffer.length === 0) {\n        this.error = \"Zero buffer length\";\n        return -1;\n      }\n\n      const tagClassMask = intBuffer[0] & 0xC0;\n\n      switch (tagClassMask) {\n        case 0x00:\n          this.tagClass = 1;\n          break;\n\n        case 0x40:\n          this.tagClass = 2;\n          break;\n\n        case 0x80:\n          this.tagClass = 3;\n          break;\n\n        case 0xC0:\n          this.tagClass = 4;\n          break;\n\n        default:\n          this.error = \"Unknown tag class\";\n          return -1;\n      }\n\n      this.isConstructed = (intBuffer[0] & 0x20) === 0x20;\n      this.isHexOnly = false;\n      const tagNumberMask = intBuffer[0] & 0x1F;\n\n      if (tagNumberMask !== 0x1F) {\n        this.tagNumber = tagNumberMask;\n        this.blockLength = 1;\n      } else {\n        let count = 1;\n        let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);\n        let tagNumberBufferMaxLength = 255;\n\n        while (intBuffer[count] & 0x80) {\n          intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n          count++;\n\n          if (count >= intBuffer.length) {\n            this.error = \"End of input reached before message was fully decoded\";\n            return -1;\n          }\n\n          if (count === tagNumberBufferMaxLength) {\n            tagNumberBufferMaxLength += 255;\n            const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);\n\n            for (let i = 0; i < intTagNumberBuffer.length; i++) tempBufferView[i] = intTagNumberBuffer[i];\n\n            intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);\n          }\n        }\n\n        this.blockLength = count + 1;\n        intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n        const tempBufferView = new Uint8Array(count);\n\n        for (let i = 0; i < count; i++) tempBufferView[i] = intTagNumberBuffer[i];\n\n        intTagNumberBuffer = this.valueHexView = new Uint8Array(count);\n        intTagNumberBuffer.set(tempBufferView);\n        if (this.blockLength <= 9) this.tagNumber = pvutils.utilFromBase(intTagNumberBuffer, 7);else {\n          this.isHexOnly = true;\n          this.warnings.push(\"Tag too long, represented as hex-coded\");\n        }\n      }\n\n      if (this.tagClass === 1 && this.isConstructed) {\n        switch (this.tagNumber) {\n          case 1:\n          case 2:\n          case 5:\n          case 6:\n          case 9:\n          case 13:\n          case 14:\n          case 23:\n          case 24:\n          case 31:\n          case 32:\n          case 33:\n          case 34:\n            this.error = \"Constructed encoding used for primitive type\";\n            return -1;\n        }\n      }\n\n      return inputOffset + this.blockLength;\n    }\n\n    toJSON() {\n      return { ...super.toJSON(),\n        tagClass: this.tagClass,\n        tagNumber: this.tagNumber,\n        isConstructed: this.isConstructed\n      };\n    }\n\n  }\n\n  LocalIdentificationBlock.NAME = \"identificationBlock\";\n  return LocalIdentificationBlock;\n})();\nlet LocalLengthBlock = /*#__PURE__*/(() => {\n  class LocalLengthBlock extends LocalBaseBlock {\n    constructor({\n      lenBlock = {}\n    } = {}) {\n      var _a, _b, _c;\n\n      super();\n      this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;\n      this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;\n      this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;\n    }\n\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n\n      if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n        return -1;\n      }\n\n      const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);\n\n      if (intBuffer.length === 0) {\n        this.error = \"Zero buffer length\";\n        return -1;\n      }\n\n      if (intBuffer[0] === 0xFF) {\n        this.error = \"Length block 0xFF is reserved by standard\";\n        return -1;\n      }\n\n      this.isIndefiniteForm = intBuffer[0] === 0x80;\n\n      if (this.isIndefiniteForm) {\n        this.blockLength = 1;\n        return inputOffset + this.blockLength;\n      }\n\n      this.longFormUsed = !!(intBuffer[0] & 0x80);\n\n      if (this.longFormUsed === false) {\n        this.length = intBuffer[0];\n        this.blockLength = 1;\n        return inputOffset + this.blockLength;\n      }\n\n      const count = intBuffer[0] & 0x7F;\n\n      if (count > 8) {\n        this.error = \"Too big integer\";\n        return -1;\n      }\n\n      if (count + 1 > intBuffer.length) {\n        this.error = \"End of input reached before message was fully decoded\";\n        return -1;\n      }\n\n      const lenOffset = inputOffset + 1;\n      const lengthBufferView = view.subarray(lenOffset, lenOffset + count);\n      if (lengthBufferView[count - 1] === 0x00) this.warnings.push(\"Needlessly long encoded length\");\n      this.length = pvutils.utilFromBase(lengthBufferView, 8);\n      if (this.longFormUsed && this.length <= 127) this.warnings.push(\"Unnecessary usage of long length form\");\n      this.blockLength = count + 1;\n      return inputOffset + this.blockLength;\n    }\n\n    toBER(sizeOnly = false) {\n      let retBuf;\n      let retView;\n      if (this.length > 127) this.longFormUsed = true;\n\n      if (this.isIndefiniteForm) {\n        retBuf = new ArrayBuffer(1);\n\n        if (sizeOnly === false) {\n          retView = new Uint8Array(retBuf);\n          retView[0] = 0x80;\n        }\n\n        return retBuf;\n      }\n\n      if (this.longFormUsed) {\n        const encodedBuf = pvutils.utilToBase(this.length, 8);\n\n        if (encodedBuf.byteLength > 127) {\n          this.error = \"Too big length\";\n          return EMPTY_BUFFER;\n        }\n\n        retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n        if (sizeOnly) return retBuf;\n        const encodedView = new Uint8Array(encodedBuf);\n        retView = new Uint8Array(retBuf);\n        retView[0] = encodedBuf.byteLength | 0x80;\n\n        for (let i = 0; i < encodedBuf.byteLength; i++) retView[i + 1] = encodedView[i];\n\n        return retBuf;\n      }\n\n      retBuf = new ArrayBuffer(1);\n\n      if (sizeOnly === false) {\n        retView = new Uint8Array(retBuf);\n        retView[0] = this.length;\n      }\n\n      return retBuf;\n    }\n\n    toJSON() {\n      return { ...super.toJSON(),\n        isIndefiniteForm: this.isIndefiniteForm,\n        longFormUsed: this.longFormUsed,\n        length: this.length\n      };\n    }\n\n  }\n\n  LocalLengthBlock.NAME = \"lengthBlock\";\n  return LocalLengthBlock;\n})();\nconst typeStore = {};\nlet BaseBlock = /*#__PURE__*/(() => {\n  class BaseBlock extends LocalBaseBlock {\n    constructor({\n      name = EMPTY_STRING,\n      optional = false,\n      primitiveSchema,\n      ...parameters\n    } = {}, valueBlockType) {\n      super(parameters);\n      this.name = name;\n      this.optional = optional;\n\n      if (primitiveSchema) {\n        this.primitiveSchema = primitiveSchema;\n      }\n\n      this.idBlock = new LocalIdentificationBlock(parameters);\n      this.lenBlock = new LocalLengthBlock(parameters);\n      this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);\n    }\n\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n\n      if (resultOffset === -1) {\n        this.error = this.valueBlock.error;\n        return resultOffset;\n      }\n\n      if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n      if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n      if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;\n      return resultOffset;\n    }\n\n    toBER(sizeOnly, writer) {\n      const _writer = writer || new ViewWriter();\n\n      if (!writer) {\n        prepareIndefiniteForm(this);\n      }\n\n      const idBlockBuf = this.idBlock.toBER(sizeOnly);\n\n      _writer.write(idBlockBuf);\n\n      if (this.lenBlock.isIndefiniteForm) {\n        _writer.write(new Uint8Array([0x80]).buffer);\n\n        this.valueBlock.toBER(sizeOnly, _writer);\n\n        _writer.write(new ArrayBuffer(2));\n      } else {\n        const valueBlockBuf = this.valueBlock.toBER(sizeOnly);\n        this.lenBlock.length = valueBlockBuf.byteLength;\n        const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n\n        _writer.write(lenBlockBuf);\n\n        _writer.write(valueBlockBuf);\n      }\n\n      if (!writer) {\n        return _writer.final();\n      }\n\n      return EMPTY_BUFFER;\n    }\n\n    toJSON() {\n      const object = { ...super.toJSON(),\n        idBlock: this.idBlock.toJSON(),\n        lenBlock: this.lenBlock.toJSON(),\n        valueBlock: this.valueBlock.toJSON(),\n        name: this.name,\n        optional: this.optional\n      };\n      if (this.primitiveSchema) object.primitiveSchema = this.primitiveSchema.toJSON();\n      return object;\n    }\n\n    toString(encoding = \"ascii\") {\n      if (encoding === \"ascii\") {\n        return this.onAsciiEncoding();\n      }\n\n      return pvtsutils.Convert.ToHex(this.toBER());\n    }\n\n    onAsciiEncoding() {\n      return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;\n    }\n\n    isEqual(other) {\n      if (this === other) {\n        return true;\n      }\n\n      if (!(other instanceof this.constructor)) {\n        return false;\n      }\n\n      const thisRaw = this.toBER();\n      const otherRaw = other.toBER();\n      return pvutils.isEqualBuffer(thisRaw, otherRaw);\n    }\n\n  }\n\n  BaseBlock.NAME = \"BaseBlock\";\n  return BaseBlock;\n})();\n\nfunction prepareIndefiniteForm(baseBlock) {\n  if (baseBlock instanceof typeStore.Constructed) {\n    for (const value of baseBlock.valueBlock.value) {\n      if (prepareIndefiniteForm(value)) {\n        baseBlock.lenBlock.isIndefiniteForm = true;\n      }\n    }\n  }\n\n  return !!baseBlock.lenBlock.isIndefiniteForm;\n}\n\nlet BaseStringBlock = /*#__PURE__*/(() => {\n  class BaseStringBlock extends BaseBlock {\n    constructor({\n      value = EMPTY_STRING,\n      ...parameters\n    } = {}, stringValueBlockType) {\n      super(parameters, stringValueBlockType);\n\n      if (value) {\n        this.fromString(value);\n      }\n    }\n\n    getValue() {\n      return this.valueBlock.value;\n    }\n\n    setValue(value) {\n      this.valueBlock.value = value;\n    }\n\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n\n      if (resultOffset === -1) {\n        this.error = this.valueBlock.error;\n        return resultOffset;\n      }\n\n      this.fromBuffer(this.valueBlock.valueHexView);\n      if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n      if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n      if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;\n      return resultOffset;\n    }\n\n    onAsciiEncoding() {\n      return `${this.constructor.NAME} : '${this.valueBlock.value}'`;\n    }\n\n  }\n\n  BaseStringBlock.NAME = \"BaseStringBlock\";\n  return BaseStringBlock;\n})();\nlet LocalPrimitiveValueBlock = /*#__PURE__*/(() => {\n  class LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {\n    constructor({\n      isHexOnly = true,\n      ...parameters\n    } = {}) {\n      super(parameters);\n      this.isHexOnly = isHexOnly;\n    }\n\n  }\n\n  LocalPrimitiveValueBlock.NAME = \"PrimitiveValueBlock\";\n  return LocalPrimitiveValueBlock;\n})();\n\nvar _a$w;\n\nclass Primitive extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalPrimitiveValueBlock);\n    this.idBlock.isConstructed = false;\n  }\n\n}\n\n_a$w = Primitive;\n\n(() => {\n  typeStore.Primitive = _a$w;\n})();\n\nPrimitive.NAME = \"PRIMITIVE\";\n\nfunction localChangeType(inputObject, newType) {\n  if (inputObject instanceof newType) {\n    return inputObject;\n  }\n\n  const newObject = new newType();\n  newObject.idBlock = inputObject.idBlock;\n  newObject.lenBlock = inputObject.lenBlock;\n  newObject.warnings = inputObject.warnings;\n  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;\n  return newObject;\n}\n\nfunction localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {\n  const incomingOffset = inputOffset;\n  let returnObject = new BaseBlock({}, ValueBlock);\n  const baseBlock = new LocalBaseBlock();\n\n  if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {\n    returnObject.error = baseBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);\n\n  if (!intBuffer.length) {\n    returnObject.error = \"Zero buffer length\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n\n  if (returnObject.idBlock.warnings.length) {\n    returnObject.warnings.concat(returnObject.idBlock.warnings);\n  }\n\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.idBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  inputOffset = resultOffset;\n  inputLength -= returnObject.idBlock.blockLength;\n  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n\n  if (returnObject.lenBlock.warnings.length) {\n    returnObject.warnings.concat(returnObject.lenBlock.warnings);\n  }\n\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.lenBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  inputOffset = resultOffset;\n  inputLength -= returnObject.lenBlock.blockLength;\n\n  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {\n    returnObject.error = \"Indefinite length form used for primitive encoding form\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  let newASN1Type = BaseBlock;\n\n  switch (returnObject.idBlock.tagClass) {\n    case 1:\n      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {\n        returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\n        return {\n          offset: -1,\n          result: returnObject\n        };\n      }\n\n      switch (returnObject.idBlock.tagNumber) {\n        case 0:\n          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {\n            returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\n            return {\n              offset: -1,\n              result: returnObject\n            };\n          }\n\n          newASN1Type = typeStore.EndOfContent;\n          break;\n\n        case 1:\n          newASN1Type = typeStore.Boolean;\n          break;\n\n        case 2:\n          newASN1Type = typeStore.Integer;\n          break;\n\n        case 3:\n          newASN1Type = typeStore.BitString;\n          break;\n\n        case 4:\n          newASN1Type = typeStore.OctetString;\n          break;\n\n        case 5:\n          newASN1Type = typeStore.Null;\n          break;\n\n        case 6:\n          newASN1Type = typeStore.ObjectIdentifier;\n          break;\n\n        case 10:\n          newASN1Type = typeStore.Enumerated;\n          break;\n\n        case 12:\n          newASN1Type = typeStore.Utf8String;\n          break;\n\n        case 13:\n          newASN1Type = typeStore.RelativeObjectIdentifier;\n          break;\n\n        case 14:\n          newASN1Type = typeStore.TIME;\n          break;\n\n        case 15:\n          returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\n          return {\n            offset: -1,\n            result: returnObject\n          };\n\n        case 16:\n          newASN1Type = typeStore.Sequence;\n          break;\n\n        case 17:\n          newASN1Type = typeStore.Set;\n          break;\n\n        case 18:\n          newASN1Type = typeStore.NumericString;\n          break;\n\n        case 19:\n          newASN1Type = typeStore.PrintableString;\n          break;\n\n        case 20:\n          newASN1Type = typeStore.TeletexString;\n          break;\n\n        case 21:\n          newASN1Type = typeStore.VideotexString;\n          break;\n\n        case 22:\n          newASN1Type = typeStore.IA5String;\n          break;\n\n        case 23:\n          newASN1Type = typeStore.UTCTime;\n          break;\n\n        case 24:\n          newASN1Type = typeStore.GeneralizedTime;\n          break;\n\n        case 25:\n          newASN1Type = typeStore.GraphicString;\n          break;\n\n        case 26:\n          newASN1Type = typeStore.VisibleString;\n          break;\n\n        case 27:\n          newASN1Type = typeStore.GeneralString;\n          break;\n\n        case 28:\n          newASN1Type = typeStore.UniversalString;\n          break;\n\n        case 29:\n          newASN1Type = typeStore.CharacterString;\n          break;\n\n        case 30:\n          newASN1Type = typeStore.BmpString;\n          break;\n\n        case 31:\n          newASN1Type = typeStore.DATE;\n          break;\n\n        case 32:\n          newASN1Type = typeStore.TimeOfDay;\n          break;\n\n        case 33:\n          newASN1Type = typeStore.DateTime;\n          break;\n\n        case 34:\n          newASN1Type = typeStore.Duration;\n          break;\n\n        default:\n          {\n            const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();\n            newObject.idBlock = returnObject.idBlock;\n            newObject.lenBlock = returnObject.lenBlock;\n            newObject.warnings = returnObject.warnings;\n            returnObject = newObject;\n          }\n      }\n\n      break;\n\n    case 2:\n    case 3:\n    case 4:\n    default:\n      {\n        newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;\n      }\n  }\n\n  returnObject = localChangeType(returnObject, newASN1Type);\n  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);\n  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);\n  return {\n    offset: resultOffset,\n    result: returnObject\n  };\n}\n\nfunction fromBER(inputBuffer) {\n  if (!inputBuffer.byteLength) {\n    const result = new BaseBlock({}, ValueBlock);\n    result.error = \"Input buffer has zero length\";\n    return {\n      offset: -1,\n      result\n    };\n  }\n\n  return localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);\n}\n\nfunction checkLen(indefiniteLength, length) {\n  if (indefiniteLength) {\n    return 1;\n  }\n\n  return length;\n}\n\nlet LocalConstructedValueBlock = /*#__PURE__*/(() => {\n  class LocalConstructedValueBlock extends ValueBlock {\n    constructor({\n      value = [],\n      isIndefiniteForm = false,\n      ...parameters\n    } = {}) {\n      super(parameters);\n      this.value = value;\n      this.isIndefiniteForm = isIndefiniteForm;\n    }\n\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n\n      if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n        return -1;\n      }\n\n      this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);\n\n      if (this.valueBeforeDecodeView.length === 0) {\n        this.warnings.push(\"Zero buffer length\");\n        return inputOffset;\n      }\n\n      let currentOffset = inputOffset;\n\n      while (checkLen(this.isIndefiniteForm, inputLength) > 0) {\n        const returnObject = localFromBER(view, currentOffset, inputLength);\n\n        if (returnObject.offset === -1) {\n          this.error = returnObject.result.error;\n          this.warnings.concat(returnObject.result.warnings);\n          return -1;\n        }\n\n        currentOffset = returnObject.offset;\n        this.blockLength += returnObject.result.blockLength;\n        inputLength -= returnObject.result.blockLength;\n        this.value.push(returnObject.result);\n\n        if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {\n          break;\n        }\n      }\n\n      if (this.isIndefiniteForm) {\n        if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {\n          this.value.pop();\n        } else {\n          this.warnings.push(\"No EndOfContent block encoded\");\n        }\n      }\n\n      return currentOffset;\n    }\n\n    toBER(sizeOnly, writer) {\n      const _writer = writer || new ViewWriter();\n\n      for (let i = 0; i < this.value.length; i++) {\n        this.value[i].toBER(sizeOnly, _writer);\n      }\n\n      if (!writer) {\n        return _writer.final();\n      }\n\n      return EMPTY_BUFFER;\n    }\n\n    toJSON() {\n      const object = { ...super.toJSON(),\n        isIndefiniteForm: this.isIndefiniteForm,\n        value: []\n      };\n\n      for (const value of this.value) {\n        object.value.push(value.toJSON());\n      }\n\n      return object;\n    }\n\n  }\n\n  LocalConstructedValueBlock.NAME = \"ConstructedValueBlock\";\n  return LocalConstructedValueBlock;\n})();\n\nvar _a$v;\n\nclass Constructed extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalConstructedValueBlock);\n    this.idBlock.isConstructed = true;\n  }\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n    if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n    if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  }\n\n  onAsciiEncoding() {\n    const values = [];\n\n    for (const value of this.valueBlock.value) {\n      values.push(value.toString(\"ascii\").split(\"\\n\").map(o => `  ${o}`).join(\"\\n\"));\n    }\n\n    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;\n    return values.length ? `${blockName} :\\n${values.join(\"\\n\")}` : `${blockName} :`;\n  }\n\n}\n\n_a$v = Constructed;\n\n(() => {\n  typeStore.Constructed = _a$v;\n})();\n\nConstructed.NAME = \"CONSTRUCTED\";\nlet LocalEndOfContentValueBlock = /*#__PURE__*/(() => {\n  class LocalEndOfContentValueBlock extends ValueBlock {\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      return inputOffset;\n    }\n\n    toBER(sizeOnly) {\n      return EMPTY_BUFFER;\n    }\n\n  }\n\n  LocalEndOfContentValueBlock.override = \"EndOfContentValueBlock\";\n  return LocalEndOfContentValueBlock;\n})();\n\nvar _a$u;\n\nclass EndOfContent extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalEndOfContentValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 0;\n  }\n\n}\n\n_a$u = EndOfContent;\n\n(() => {\n  typeStore.EndOfContent = _a$u;\n})();\n\nEndOfContent.NAME = END_OF_CONTENT_NAME;\n\nvar _a$t;\n\nclass Null extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, ValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 5;\n  }\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (this.lenBlock.length > 0) this.warnings.push(\"Non-zero length of value block for Null type\");\n    if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n    if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n    this.blockLength += inputLength;\n\n    if (inputOffset + inputLength > inputBuffer.byteLength) {\n      this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n      return -1;\n    }\n\n    return inputOffset + inputLength;\n  }\n\n  toBER(sizeOnly, writer) {\n    const retBuf = new ArrayBuffer(2);\n\n    if (!sizeOnly) {\n      const retView = new Uint8Array(retBuf);\n      retView[0] = 0x05;\n      retView[1] = 0x00;\n    }\n\n    if (writer) {\n      writer.write(retBuf);\n    }\n\n    return retBuf;\n  }\n\n  onAsciiEncoding() {\n    return `${this.constructor.NAME}`;\n  }\n\n}\n\n_a$t = Null;\n\n(() => {\n  typeStore.Null = _a$t;\n})();\n\nNull.NAME = \"NULL\";\nlet LocalBooleanValueBlock = /*#__PURE__*/(() => {\n  class LocalBooleanValueBlock extends HexBlock(ValueBlock) {\n    constructor({\n      value,\n      ...parameters\n    } = {}) {\n      super(parameters);\n\n      if (parameters.valueHex) {\n        this.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(parameters.valueHex);\n      } else {\n        this.valueHexView = new Uint8Array(1);\n      }\n\n      if (value) {\n        this.value = value;\n      }\n    }\n\n    get value() {\n      for (const octet of this.valueHexView) {\n        if (octet > 0) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    set value(value) {\n      this.valueHexView[0] = value ? 0xFF : 0x00;\n    }\n\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n\n      if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n        return -1;\n      }\n\n      this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);\n      if (inputLength > 1) this.warnings.push(\"Boolean value encoded in more then 1 octet\");\n      this.isHexOnly = true;\n      pvutils.utilDecodeTC.call(this);\n      this.blockLength = inputLength;\n      return inputOffset + inputLength;\n    }\n\n    toBER() {\n      return this.valueHexView.slice();\n    }\n\n    toJSON() {\n      return { ...super.toJSON(),\n        value: this.value\n      };\n    }\n\n  }\n\n  LocalBooleanValueBlock.NAME = \"BooleanValueBlock\";\n  return LocalBooleanValueBlock;\n})();\n\nvar _a$s;\n\nclass Boolean extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalBooleanValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 1;\n  }\n\n  getValue() {\n    return this.valueBlock.value;\n  }\n\n  setValue(value) {\n    this.valueBlock.value = value;\n  }\n\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.getValue}`;\n  }\n\n}\n\n_a$s = Boolean;\n\n(() => {\n  typeStore.Boolean = _a$s;\n})();\n\nBoolean.NAME = \"BOOLEAN\";\nlet LocalOctetStringValueBlock = /*#__PURE__*/(() => {\n  class LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n    constructor({\n      isConstructed = false,\n      ...parameters\n    } = {}) {\n      super(parameters);\n      this.isConstructed = isConstructed;\n    }\n\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      let resultOffset = 0;\n\n      if (this.isConstructed) {\n        this.isHexOnly = false;\n        resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n        if (resultOffset === -1) return resultOffset;\n\n        for (let i = 0; i < this.value.length; i++) {\n          const currentBlockName = this.value[i].constructor.NAME;\n\n          if (currentBlockName === END_OF_CONTENT_NAME) {\n            if (this.isIndefiniteForm) break;else {\n              this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\n              return -1;\n            }\n          }\n\n          if (currentBlockName !== OCTET_STRING_NAME) {\n            this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\n            return -1;\n          }\n        }\n      } else {\n        this.isHexOnly = true;\n        resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n        this.blockLength = inputLength;\n      }\n\n      return resultOffset;\n    }\n\n    toBER(sizeOnly, writer) {\n      if (this.isConstructed) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\n      return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;\n    }\n\n    toJSON() {\n      return { ...super.toJSON(),\n        isConstructed: this.isConstructed\n      };\n    }\n\n  }\n\n  LocalOctetStringValueBlock.NAME = \"OctetStringValueBlock\";\n  return LocalOctetStringValueBlock;\n})();\n\nvar _a$r;\n\nclass OctetString extends BaseBlock {\n  constructor({\n    idBlock = {},\n    lenBlock = {},\n    ...parameters\n  } = {}) {\n    var _b, _c;\n\n    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);\n    super({\n      idBlock: {\n        isConstructed: parameters.isConstructed,\n        ...idBlock\n      },\n      lenBlock: { ...lenBlock,\n        isIndefiniteForm: !!parameters.isIndefiniteForm\n      },\n      ...parameters\n    }, LocalOctetStringValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 4;\n  }\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n\n    if (inputLength === 0) {\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      return inputOffset;\n    }\n\n    if (!this.valueBlock.isConstructed) {\n      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\n      const buf = view.subarray(inputOffset, inputOffset + inputLength);\n\n      try {\n        if (buf.byteLength) {\n          const asn = localFromBER(buf, 0, buf.byteLength);\n\n          if (asn.offset !== -1 && asn.offset === inputLength) {\n            this.valueBlock.value = [asn.result];\n          }\n        }\n      } catch (e) {}\n    }\n\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  }\n\n  onAsciiEncoding() {\n    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n      return Constructed.prototype.onAsciiEncoding.call(this);\n    }\n\n    return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueHexView)}`;\n  }\n\n  getValue() {\n    if (!this.idBlock.isConstructed) {\n      return this.valueBlock.valueHexView.slice().buffer;\n    }\n\n    const array = [];\n\n    for (const content of this.valueBlock.value) {\n      if (content instanceof OctetString) {\n        array.push(content.valueBlock.valueHexView);\n      }\n    }\n\n    return pvtsutils.BufferSourceConverter.concat(array);\n  }\n\n}\n\n_a$r = OctetString;\n\n(() => {\n  typeStore.OctetString = _a$r;\n})();\n\nOctetString.NAME = OCTET_STRING_NAME;\nlet LocalBitStringValueBlock = /*#__PURE__*/(() => {\n  class LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n    constructor({\n      unusedBits = 0,\n      isConstructed = false,\n      ...parameters\n    } = {}) {\n      super(parameters);\n      this.unusedBits = unusedBits;\n      this.isConstructed = isConstructed;\n      this.blockLength = this.valueHexView.byteLength;\n    }\n\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      if (!inputLength) {\n        return inputOffset;\n      }\n\n      let resultOffset = -1;\n\n      if (this.isConstructed) {\n        resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n        if (resultOffset === -1) return resultOffset;\n\n        for (const value of this.value) {\n          const currentBlockName = value.constructor.NAME;\n\n          if (currentBlockName === END_OF_CONTENT_NAME) {\n            if (this.isIndefiniteForm) break;else {\n              this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\n              return -1;\n            }\n          }\n\n          if (currentBlockName !== BIT_STRING_NAME) {\n            this.error = \"BIT STRING may consists of BIT STRINGs only\";\n            return -1;\n          }\n\n          const valueBlock = value.valueBlock;\n\n          if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {\n            this.error = \"Using of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\n            return -1;\n          }\n\n          this.unusedBits = valueBlock.unusedBits;\n        }\n\n        return resultOffset;\n      }\n\n      const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n\n      if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n        return -1;\n      }\n\n      const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n      this.unusedBits = intBuffer[0];\n\n      if (this.unusedBits > 7) {\n        this.error = \"Unused bits for BitString must be in range 0-7\";\n        return -1;\n      }\n\n      if (!this.unusedBits) {\n        const buf = intBuffer.subarray(1);\n\n        try {\n          if (buf.byteLength) {\n            const asn = localFromBER(buf, 0, buf.byteLength);\n\n            if (asn.offset !== -1 && asn.offset === inputLength - 1) {\n              this.value = [asn.result];\n            }\n          }\n        } catch (e) {}\n      }\n\n      this.valueHexView = intBuffer.subarray(1);\n      this.blockLength = intBuffer.length;\n      return inputOffset + inputLength;\n    }\n\n    toBER(sizeOnly, writer) {\n      if (this.isConstructed) {\n        return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\n      }\n\n      if (sizeOnly) {\n        return new ArrayBuffer(this.valueHexView.byteLength + 1);\n      }\n\n      if (!this.valueHexView.byteLength) {\n        return EMPTY_BUFFER;\n      }\n\n      const retView = new Uint8Array(this.valueHexView.length + 1);\n      retView[0] = this.unusedBits;\n      retView.set(this.valueHexView, 1);\n      return retView.buffer;\n    }\n\n    toJSON() {\n      return { ...super.toJSON(),\n        unusedBits: this.unusedBits,\n        isConstructed: this.isConstructed\n      };\n    }\n\n  }\n\n  LocalBitStringValueBlock.NAME = \"BitStringValueBlock\";\n  return LocalBitStringValueBlock;\n})();\n\nvar _a$q;\n\nclass BitString extends BaseBlock {\n  constructor({\n    idBlock = {},\n    lenBlock = {},\n    ...parameters\n  } = {}) {\n    var _b, _c;\n\n    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);\n    super({\n      idBlock: {\n        isConstructed: parameters.isConstructed,\n        ...idBlock\n      },\n      lenBlock: { ...lenBlock,\n        isIndefiniteForm: !!parameters.isIndefiniteForm\n      },\n      ...parameters\n    }, LocalBitStringValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 3;\n  }\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  }\n\n  onAsciiEncoding() {\n    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n      return Constructed.prototype.onAsciiEncoding.call(this);\n    } else {\n      const bits = [];\n      const valueHex = this.valueBlock.valueHexView;\n\n      for (const byte of valueHex) {\n        bits.push(byte.toString(2).padStart(8, \"0\"));\n      }\n\n      const bitsStr = bits.join(\"\");\n      return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;\n    }\n  }\n\n}\n\n_a$q = BitString;\n\n(() => {\n  typeStore.BitString = _a$q;\n})();\n\nBitString.NAME = BIT_STRING_NAME;\n\nvar _a$p;\n\nfunction viewAdd(first, second) {\n  const c = new Uint8Array([0]);\n  const firstView = new Uint8Array(first);\n  const secondView = new Uint8Array(second);\n  let firstViewCopy = firstView.slice(0);\n  const firstViewCopyLength = firstViewCopy.length - 1;\n  const secondViewCopy = secondView.slice(0);\n  const secondViewCopyLength = secondViewCopy.length - 1;\n  let value = 0;\n  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;\n  let counter = 0;\n\n  for (let i = max; i >= 0; i--, counter++) {\n    switch (true) {\n      case counter < secondViewCopy.length:\n        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n        break;\n\n      default:\n        value = firstViewCopy[firstViewCopyLength - counter] + c[0];\n    }\n\n    c[0] = value / 10;\n\n    switch (true) {\n      case counter >= firstViewCopy.length:\n        firstViewCopy = pvutils.utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\n        break;\n\n      default:\n        firstViewCopy[firstViewCopyLength - counter] = value % 10;\n    }\n  }\n\n  if (c[0] > 0) firstViewCopy = pvutils.utilConcatView(c, firstViewCopy);\n  return firstViewCopy;\n}\n\nfunction power2(n) {\n  if (n >= powers2.length) {\n    for (let p = powers2.length; p <= n; p++) {\n      const c = new Uint8Array([0]);\n      let digits = powers2[p - 1].slice(0);\n\n      for (let i = digits.length - 1; i >= 0; i--) {\n        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\n        c[0] = newValue[0] / 10;\n        digits[i] = newValue[0] % 10;\n      }\n\n      if (c[0] > 0) digits = pvutils.utilConcatView(c, digits);\n      powers2.push(digits);\n    }\n  }\n\n  return powers2[n];\n}\n\nfunction viewSub(first, second) {\n  let b = 0;\n  const firstView = new Uint8Array(first);\n  const secondView = new Uint8Array(second);\n  const firstViewCopy = firstView.slice(0);\n  const firstViewCopyLength = firstViewCopy.length - 1;\n  const secondViewCopy = secondView.slice(0);\n  const secondViewCopyLength = secondViewCopy.length - 1;\n  let value;\n  let counter = 0;\n\n  for (let i = secondViewCopyLength; i >= 0; i--, counter++) {\n    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n\n    switch (true) {\n      case value < 0:\n        b = 1;\n        firstViewCopy[firstViewCopyLength - counter] = value + 10;\n        break;\n\n      default:\n        b = 0;\n        firstViewCopy[firstViewCopyLength - counter] = value;\n    }\n  }\n\n  if (b > 0) {\n    for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {\n      value = firstViewCopy[firstViewCopyLength - counter] - b;\n\n      if (value < 0) {\n        b = 1;\n        firstViewCopy[firstViewCopyLength - counter] = value + 10;\n      } else {\n        b = 0;\n        firstViewCopy[firstViewCopyLength - counter] = value;\n        break;\n      }\n    }\n  }\n\n  return firstViewCopy.slice();\n}\n\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock) {\n  constructor({\n    value,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this._valueDec = 0;\n\n    if (parameters.valueHex) {\n      this.setValueHex();\n    }\n\n    if (value !== undefined) {\n      this.valueDec = value;\n    }\n  }\n\n  setValueHex() {\n    if (this.valueHexView.length >= 4) {\n      this.warnings.push(\"Too big Integer for decoding, hex only\");\n      this.isHexOnly = true;\n      this._valueDec = 0;\n    } else {\n      this.isHexOnly = false;\n\n      if (this.valueHexView.length > 0) {\n        this._valueDec = pvutils.utilDecodeTC.call(this);\n      }\n    }\n  }\n\n  set valueDec(v) {\n    this._valueDec = v;\n    this.isHexOnly = false;\n    this.valueHexView = new Uint8Array(pvutils.utilEncodeTC(v));\n  }\n\n  get valueDec() {\n    return this._valueDec;\n  }\n\n  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\n    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n    if (offset === -1) return offset;\n    const view = this.valueHexView;\n\n    if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {\n      this.valueHexView = view.subarray(1);\n    } else {\n      if (expectedLength !== 0) {\n        if (view.length < expectedLength) {\n          if (expectedLength - view.length > 1) expectedLength = view.length + 1;\n          this.valueHexView = view.subarray(expectedLength - view.length);\n        }\n      }\n    }\n\n    return offset;\n  }\n\n  toDER(sizeOnly = false) {\n    const view = this.valueHexView;\n\n    switch (true) {\n      case (view[0] & 0x80) !== 0:\n        {\n          const updatedView = new Uint8Array(this.valueHexView.length + 1);\n          updatedView[0] = 0x00;\n          updatedView.set(view, 1);\n          this.valueHexView = updatedView;\n        }\n        break;\n\n      case view[0] === 0x00 && (view[1] & 0x80) === 0:\n        {\n          this.valueHexView = this.valueHexView.subarray(1);\n        }\n        break;\n    }\n\n    return this.toBER(sizeOnly);\n  }\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n\n    if (resultOffset === -1) {\n      return resultOffset;\n    }\n\n    this.setValueHex();\n    return resultOffset;\n  }\n\n  toBER(sizeOnly) {\n    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;\n  }\n\n  toJSON() {\n    return { ...super.toJSON(),\n      valueDec: this.valueDec\n    };\n  }\n\n  toString() {\n    const firstBit = this.valueHexView.length * 8 - 1;\n    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);\n    let bitNumber = 0;\n    let currentByte;\n    const asn1View = this.valueHexView;\n    let result = \"\";\n    let flag = false;\n\n    for (let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {\n      currentByte = asn1View[byteNumber];\n\n      for (let i = 0; i < 8; i++) {\n        if ((currentByte & 1) === 1) {\n          switch (bitNumber) {\n            case firstBit:\n              digits = viewSub(power2(bitNumber), digits);\n              result = \"-\";\n              break;\n\n            default:\n              digits = viewAdd(digits, power2(bitNumber));\n          }\n        }\n\n        bitNumber++;\n        currentByte >>= 1;\n      }\n    }\n\n    for (let i = 0; i < digits.length; i++) {\n      if (digits[i]) flag = true;\n      if (flag) result += digitsString.charAt(digits[i]);\n    }\n\n    if (flag === false) result += digitsString.charAt(0);\n    return result;\n  }\n\n}\n\n_a$p = LocalIntegerValueBlock;\nLocalIntegerValueBlock.NAME = \"IntegerValueBlock\";\n\n(() => {\n  Object.defineProperty(_a$p.prototype, \"valueHex\", {\n    set: function (v) {\n      this.valueHexView = new Uint8Array(v);\n      this.setValueHex();\n    },\n    get: function () {\n      return this.valueHexView.slice().buffer;\n    }\n  });\n})();\n\nvar _a$o;\n\nclass Integer extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalIntegerValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 2;\n  }\n\n  toBigInt() {\n    assertBigInt();\n    return BigInt(this.valueBlock.toString());\n  }\n\n  static fromBigInt(value) {\n    assertBigInt();\n    const bigIntValue = BigInt(value);\n    const writer = new ViewWriter();\n    const hex = bigIntValue.toString(16).replace(/^-/, \"\");\n    const view = new Uint8Array(pvtsutils.Convert.FromHex(hex));\n\n    if (bigIntValue < 0) {\n      const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));\n      first[0] |= 0x80;\n      const firstInt = BigInt(`0x${pvtsutils.Convert.ToHex(first)}`);\n      const secondInt = firstInt + bigIntValue;\n      const second = pvtsutils.BufferSourceConverter.toUint8Array(pvtsutils.Convert.FromHex(secondInt.toString(16)));\n      second[0] |= 0x80;\n      writer.write(second);\n    } else {\n      if (view[0] & 0x80) {\n        writer.write(new Uint8Array([0]));\n      }\n\n      writer.write(view);\n    }\n\n    const res = new Integer({\n      valueHex: writer.final()\n    });\n    return res;\n  }\n\n  convertToDER() {\n    const integer = new Integer({\n      valueHex: this.valueBlock.valueHexView\n    });\n    integer.valueBlock.toDER();\n    return integer;\n  }\n\n  convertFromDER() {\n    return new Integer({\n      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView\n    });\n  }\n\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;\n  }\n\n}\n\n_a$o = Integer;\n\n(() => {\n  typeStore.Integer = _a$o;\n})();\n\nInteger.NAME = \"INTEGER\";\n\nvar _a$n;\n\nclass Enumerated extends Integer {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 10;\n  }\n\n}\n\n_a$n = Enumerated;\n\n(() => {\n  typeStore.Enumerated = _a$n;\n})();\n\nEnumerated.NAME = \"ENUMERATED\";\nlet LocalSidValueBlock = /*#__PURE__*/(() => {\n  class LocalSidValueBlock extends HexBlock(ValueBlock) {\n    constructor({\n      valueDec = -1,\n      isFirstSid = false,\n      ...parameters\n    } = {}) {\n      super(parameters);\n      this.valueDec = valueDec;\n      this.isFirstSid = isFirstSid;\n    }\n\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      if (!inputLength) {\n        return inputOffset;\n      }\n\n      const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n\n      if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n        return -1;\n      }\n\n      const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n      this.valueHexView = new Uint8Array(inputLength);\n\n      for (let i = 0; i < inputLength; i++) {\n        this.valueHexView[i] = intBuffer[i] & 0x7F;\n        this.blockLength++;\n        if ((intBuffer[i] & 0x80) === 0x00) break;\n      }\n\n      const tempView = new Uint8Array(this.blockLength);\n\n      for (let i = 0; i < this.blockLength; i++) {\n        tempView[i] = this.valueHexView[i];\n      }\n\n      this.valueHexView = tempView;\n\n      if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n        this.error = \"End of input reached before message was fully decoded\";\n        return -1;\n      }\n\n      if (this.valueHexView[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n      if (this.blockLength <= 8) this.valueDec = pvutils.utilFromBase(this.valueHexView, 7);else {\n        this.isHexOnly = true;\n        this.warnings.push(\"Too big SID for decoding, hex only\");\n      }\n      return inputOffset + this.blockLength;\n    }\n\n    set valueBigInt(value) {\n      assertBigInt();\n      let bits = BigInt(value).toString(2);\n\n      while (bits.length % 7) {\n        bits = \"0\" + bits;\n      }\n\n      const bytes = new Uint8Array(bits.length / 7);\n\n      for (let i = 0; i < bytes.length; i++) {\n        bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);\n      }\n\n      this.fromBER(bytes.buffer, 0, bytes.length);\n    }\n\n    toBER(sizeOnly) {\n      if (this.isHexOnly) {\n        if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);\n        const curView = this.valueHexView;\n        const retView = new Uint8Array(this.blockLength);\n\n        for (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;\n\n        retView[this.blockLength - 1] = curView[this.blockLength - 1];\n        return retView.buffer;\n      }\n\n      const encodedBuf = pvutils.utilToBase(this.valueDec, 7);\n\n      if (encodedBuf.byteLength === 0) {\n        this.error = \"Error during encoding SID value\";\n        return EMPTY_BUFFER;\n      }\n\n      const retView = new Uint8Array(encodedBuf.byteLength);\n\n      if (!sizeOnly) {\n        const encodedView = new Uint8Array(encodedBuf);\n        const len = encodedBuf.byteLength - 1;\n\n        for (let i = 0; i < len; i++) retView[i] = encodedView[i] | 0x80;\n\n        retView[len] = encodedView[len];\n      }\n\n      return retView;\n    }\n\n    toString() {\n      let result = \"\";\n      if (this.isHexOnly) result = pvtsutils.Convert.ToHex(this.valueHexView);else {\n        if (this.isFirstSid) {\n          let sidValue = this.valueDec;\n          if (this.valueDec <= 39) result = \"0.\";else {\n            if (this.valueDec <= 79) {\n              result = \"1.\";\n              sidValue -= 40;\n            } else {\n              result = \"2.\";\n              sidValue -= 80;\n            }\n          }\n          result += sidValue.toString();\n        } else result = this.valueDec.toString();\n      }\n      return result;\n    }\n\n    toJSON() {\n      return { ...super.toJSON(),\n        valueDec: this.valueDec,\n        isFirstSid: this.isFirstSid\n      };\n    }\n\n  }\n\n  LocalSidValueBlock.NAME = \"sidBlock\";\n  return LocalSidValueBlock;\n})();\nlet LocalObjectIdentifierValueBlock = /*#__PURE__*/(() => {\n  class LocalObjectIdentifierValueBlock extends ValueBlock {\n    constructor({\n      value = EMPTY_STRING,\n      ...parameters\n    } = {}) {\n      super(parameters);\n      this.value = [];\n\n      if (value) {\n        this.fromString(value);\n      }\n    }\n\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      let resultOffset = inputOffset;\n\n      while (inputLength > 0) {\n        const sidBlock = new LocalSidValueBlock();\n        resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\n        if (resultOffset === -1) {\n          this.blockLength = 0;\n          this.error = sidBlock.error;\n          return resultOffset;\n        }\n\n        if (this.value.length === 0) sidBlock.isFirstSid = true;\n        this.blockLength += sidBlock.blockLength;\n        inputLength -= sidBlock.blockLength;\n        this.value.push(sidBlock);\n      }\n\n      return resultOffset;\n    }\n\n    toBER(sizeOnly) {\n      const retBuffers = [];\n\n      for (let i = 0; i < this.value.length; i++) {\n        const valueBuf = this.value[i].toBER(sizeOnly);\n\n        if (valueBuf.byteLength === 0) {\n          this.error = this.value[i].error;\n          return EMPTY_BUFFER;\n        }\n\n        retBuffers.push(valueBuf);\n      }\n\n      return concat(retBuffers);\n    }\n\n    fromString(string) {\n      this.value = [];\n      let pos1 = 0;\n      let pos2 = 0;\n      let sid = \"\";\n      let flag = false;\n\n      do {\n        pos2 = string.indexOf(\".\", pos1);\n        if (pos2 === -1) sid = string.substring(pos1);else sid = string.substring(pos1, pos2);\n        pos1 = pos2 + 1;\n\n        if (flag) {\n          const sidBlock = this.value[0];\n          let plus = 0;\n\n          switch (sidBlock.valueDec) {\n            case 0:\n              break;\n\n            case 1:\n              plus = 40;\n              break;\n\n            case 2:\n              plus = 80;\n              break;\n\n            default:\n              this.value = [];\n              return;\n          }\n\n          const parsedSID = parseInt(sid, 10);\n          if (isNaN(parsedSID)) return;\n          sidBlock.valueDec = parsedSID + plus;\n          flag = false;\n        } else {\n          const sidBlock = new LocalSidValueBlock();\n\n          if (sid > Number.MAX_SAFE_INTEGER) {\n            assertBigInt();\n            const sidValue = BigInt(sid);\n            sidBlock.valueBigInt = sidValue;\n          } else {\n            sidBlock.valueDec = parseInt(sid, 10);\n            if (isNaN(sidBlock.valueDec)) return;\n          }\n\n          if (!this.value.length) {\n            sidBlock.isFirstSid = true;\n            flag = true;\n          }\n\n          this.value.push(sidBlock);\n        }\n      } while (pos2 !== -1);\n    }\n\n    toString() {\n      let result = \"\";\n      let isHexOnly = false;\n\n      for (let i = 0; i < this.value.length; i++) {\n        isHexOnly = this.value[i].isHexOnly;\n        let sidStr = this.value[i].toString();\n        if (i !== 0) result = `${result}.`;\n\n        if (isHexOnly) {\n          sidStr = `{${sidStr}}`;\n          if (this.value[i].isFirstSid) result = `2.{${sidStr} - 80}`;else result += sidStr;\n        } else result += sidStr;\n      }\n\n      return result;\n    }\n\n    toJSON() {\n      const object = { ...super.toJSON(),\n        value: this.toString(),\n        sidArray: []\n      };\n\n      for (let i = 0; i < this.value.length; i++) {\n        object.sidArray.push(this.value[i].toJSON());\n      }\n\n      return object;\n    }\n\n  }\n\n  LocalObjectIdentifierValueBlock.NAME = \"ObjectIdentifierValueBlock\";\n  return LocalObjectIdentifierValueBlock;\n})();\n\nvar _a$m;\n\nclass ObjectIdentifier extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 6;\n  }\n\n  getValue() {\n    return this.valueBlock.toString();\n  }\n\n  setValue(value) {\n    this.valueBlock.fromString(value);\n  }\n\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\n  }\n\n  toJSON() {\n    return { ...super.toJSON(),\n      value: this.getValue()\n    };\n  }\n\n}\n\n_a$m = ObjectIdentifier;\n\n(() => {\n  typeStore.ObjectIdentifier = _a$m;\n})();\n\nObjectIdentifier.NAME = \"OBJECT IDENTIFIER\";\nlet LocalRelativeSidValueBlock = /*#__PURE__*/(() => {\n  class LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {\n    constructor({\n      valueDec = 0,\n      ...parameters\n    } = {}) {\n      super(parameters);\n      this.valueDec = valueDec;\n    }\n\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      if (inputLength === 0) return inputOffset;\n      const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n      if (!checkBufferParams(this, inputView, inputOffset, inputLength)) return -1;\n      const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n      this.valueHexView = new Uint8Array(inputLength);\n\n      for (let i = 0; i < inputLength; i++) {\n        this.valueHexView[i] = intBuffer[i] & 0x7F;\n        this.blockLength++;\n        if ((intBuffer[i] & 0x80) === 0x00) break;\n      }\n\n      const tempView = new Uint8Array(this.blockLength);\n\n      for (let i = 0; i < this.blockLength; i++) tempView[i] = this.valueHexView[i];\n\n      this.valueHexView = tempView;\n\n      if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n        this.error = \"End of input reached before message was fully decoded\";\n        return -1;\n      }\n\n      if (this.valueHexView[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n      if (this.blockLength <= 8) this.valueDec = pvutils.utilFromBase(this.valueHexView, 7);else {\n        this.isHexOnly = true;\n        this.warnings.push(\"Too big SID for decoding, hex only\");\n      }\n      return inputOffset + this.blockLength;\n    }\n\n    toBER(sizeOnly) {\n      if (this.isHexOnly) {\n        if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);\n        const curView = this.valueHexView;\n        const retView = new Uint8Array(this.blockLength);\n\n        for (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;\n\n        retView[this.blockLength - 1] = curView[this.blockLength - 1];\n        return retView.buffer;\n      }\n\n      const encodedBuf = pvutils.utilToBase(this.valueDec, 7);\n\n      if (encodedBuf.byteLength === 0) {\n        this.error = \"Error during encoding SID value\";\n        return EMPTY_BUFFER;\n      }\n\n      const retView = new Uint8Array(encodedBuf.byteLength);\n\n      if (!sizeOnly) {\n        const encodedView = new Uint8Array(encodedBuf);\n        const len = encodedBuf.byteLength - 1;\n\n        for (let i = 0; i < len; i++) retView[i] = encodedView[i] | 0x80;\n\n        retView[len] = encodedView[len];\n      }\n\n      return retView.buffer;\n    }\n\n    toString() {\n      let result = \"\";\n      if (this.isHexOnly) result = pvtsutils.Convert.ToHex(this.valueHexView);else {\n        result = this.valueDec.toString();\n      }\n      return result;\n    }\n\n    toJSON() {\n      return { ...super.toJSON(),\n        valueDec: this.valueDec\n      };\n    }\n\n  }\n\n  LocalRelativeSidValueBlock.NAME = \"relativeSidBlock\";\n  return LocalRelativeSidValueBlock;\n})();\nlet LocalRelativeObjectIdentifierValueBlock = /*#__PURE__*/(() => {\n  class LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\n    constructor({\n      value = EMPTY_STRING,\n      ...parameters\n    } = {}) {\n      super(parameters);\n      this.value = [];\n\n      if (value) {\n        this.fromString(value);\n      }\n    }\n\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      let resultOffset = inputOffset;\n\n      while (inputLength > 0) {\n        const sidBlock = new LocalRelativeSidValueBlock();\n        resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\n        if (resultOffset === -1) {\n          this.blockLength = 0;\n          this.error = sidBlock.error;\n          return resultOffset;\n        }\n\n        this.blockLength += sidBlock.blockLength;\n        inputLength -= sidBlock.blockLength;\n        this.value.push(sidBlock);\n      }\n\n      return resultOffset;\n    }\n\n    toBER(sizeOnly, writer) {\n      const retBuffers = [];\n\n      for (let i = 0; i < this.value.length; i++) {\n        const valueBuf = this.value[i].toBER(sizeOnly);\n\n        if (valueBuf.byteLength === 0) {\n          this.error = this.value[i].error;\n          return EMPTY_BUFFER;\n        }\n\n        retBuffers.push(valueBuf);\n      }\n\n      return concat(retBuffers);\n    }\n\n    fromString(string) {\n      this.value = [];\n      let pos1 = 0;\n      let pos2 = 0;\n      let sid = \"\";\n\n      do {\n        pos2 = string.indexOf(\".\", pos1);\n        if (pos2 === -1) sid = string.substring(pos1);else sid = string.substring(pos1, pos2);\n        pos1 = pos2 + 1;\n        const sidBlock = new LocalRelativeSidValueBlock();\n        sidBlock.valueDec = parseInt(sid, 10);\n        if (isNaN(sidBlock.valueDec)) return true;\n        this.value.push(sidBlock);\n      } while (pos2 !== -1);\n\n      return true;\n    }\n\n    toString() {\n      let result = \"\";\n      let isHexOnly = false;\n\n      for (let i = 0; i < this.value.length; i++) {\n        isHexOnly = this.value[i].isHexOnly;\n        let sidStr = this.value[i].toString();\n        if (i !== 0) result = `${result}.`;\n\n        if (isHexOnly) {\n          sidStr = `{${sidStr}}`;\n          result += sidStr;\n        } else result += sidStr;\n      }\n\n      return result;\n    }\n\n    toJSON() {\n      const object = { ...super.toJSON(),\n        value: this.toString(),\n        sidArray: []\n      };\n\n      for (let i = 0; i < this.value.length; i++) object.sidArray.push(this.value[i].toJSON());\n\n      return object;\n    }\n\n  }\n\n  LocalRelativeObjectIdentifierValueBlock.NAME = \"RelativeObjectIdentifierValueBlock\";\n  return LocalRelativeObjectIdentifierValueBlock;\n})();\n\nvar _a$l;\n\nclass RelativeObjectIdentifier extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalRelativeObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 13;\n  }\n\n  getValue() {\n    return this.valueBlock.toString();\n  }\n\n  setValue(value) {\n    this.valueBlock.fromString(value);\n  }\n\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\n  }\n\n  toJSON() {\n    return { ...super.toJSON(),\n      value: this.getValue()\n    };\n  }\n\n}\n\n_a$l = RelativeObjectIdentifier;\n\n(() => {\n  typeStore.RelativeObjectIdentifier = _a$l;\n})();\n\nRelativeObjectIdentifier.NAME = \"RelativeObjectIdentifier\";\n\nvar _a$k;\n\nclass Sequence extends Constructed {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 16;\n  }\n\n}\n\n_a$k = Sequence;\n\n(() => {\n  typeStore.Sequence = _a$k;\n})();\n\nSequence.NAME = \"SEQUENCE\";\n\nvar _a$j;\n\nclass Set extends Constructed {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 17;\n  }\n\n}\n\n_a$j = Set;\n\n(() => {\n  typeStore.Set = _a$j;\n})();\n\nSet.NAME = \"SET\";\nlet LocalStringValueBlock = /*#__PURE__*/(() => {\n  class LocalStringValueBlock extends HexBlock(ValueBlock) {\n    constructor({ ...parameters\n    } = {}) {\n      super(parameters);\n      this.isHexOnly = true;\n      this.value = EMPTY_STRING;\n    }\n\n    toJSON() {\n      return { ...super.toJSON(),\n        value: this.value\n      };\n    }\n\n  }\n\n  LocalStringValueBlock.NAME = \"StringValueBlock\";\n  return LocalStringValueBlock;\n})();\nlet LocalSimpleStringValueBlock = /*#__PURE__*/(() => {\n  class LocalSimpleStringValueBlock extends LocalStringValueBlock {}\n\n  LocalSimpleStringValueBlock.NAME = \"SimpleStringValueBlock\";\n  return LocalSimpleStringValueBlock;\n})();\nlet LocalSimpleStringBlock = /*#__PURE__*/(() => {\n  class LocalSimpleStringBlock extends BaseStringBlock {\n    constructor({ ...parameters\n    } = {}) {\n      super(parameters, LocalSimpleStringValueBlock);\n    }\n\n    fromBuffer(inputBuffer) {\n      this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));\n    }\n\n    fromString(inputString) {\n      const strLen = inputString.length;\n      const view = this.valueBlock.valueHexView = new Uint8Array(strLen);\n\n      for (let i = 0; i < strLen; i++) view[i] = inputString.charCodeAt(i);\n\n      this.valueBlock.value = inputString;\n    }\n\n  }\n\n  LocalSimpleStringBlock.NAME = \"SIMPLE STRING\";\n  return LocalSimpleStringBlock;\n})();\nlet LocalUtf8StringValueBlock = /*#__PURE__*/(() => {\n  class LocalUtf8StringValueBlock extends LocalSimpleStringBlock {\n    fromBuffer(inputBuffer) {\n      this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n\n      try {\n        this.valueBlock.value = pvtsutils.Convert.ToUtf8String(inputBuffer);\n      } catch (ex) {\n        this.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\n        this.valueBlock.value = pvtsutils.Convert.ToBinary(inputBuffer);\n      }\n    }\n\n    fromString(inputString) {\n      this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf8String(inputString));\n      this.valueBlock.value = inputString;\n    }\n\n  }\n\n  LocalUtf8StringValueBlock.NAME = \"Utf8StringValueBlock\";\n  return LocalUtf8StringValueBlock;\n})();\n\nvar _a$i;\n\nclass Utf8String extends LocalUtf8StringValueBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 12;\n  }\n\n}\n\n_a$i = Utf8String;\n\n(() => {\n  typeStore.Utf8String = _a$i;\n})();\n\nUtf8String.NAME = \"UTF8String\";\nlet LocalBmpStringValueBlock = /*#__PURE__*/(() => {\n  class LocalBmpStringValueBlock extends LocalSimpleStringBlock {\n    fromBuffer(inputBuffer) {\n      this.valueBlock.value = pvtsutils.Convert.ToUtf16String(inputBuffer);\n      this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n    }\n\n    fromString(inputString) {\n      this.valueBlock.value = inputString;\n      this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf16String(inputString));\n    }\n\n  }\n\n  LocalBmpStringValueBlock.NAME = \"BmpStringValueBlock\";\n  return LocalBmpStringValueBlock;\n})();\n\nvar _a$h;\n\nclass BmpString extends LocalBmpStringValueBlock {\n  constructor({ ...parameters\n  } = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 30;\n  }\n\n}\n\n_a$h = BmpString;\n\n(() => {\n  typeStore.BmpString = _a$h;\n})();\n\nBmpString.NAME = \"BMPString\";\nlet LocalUniversalStringValueBlock = /*#__PURE__*/(() => {\n  class LocalUniversalStringValueBlock extends LocalSimpleStringBlock {\n    fromBuffer(inputBuffer) {\n      const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);\n      const valueView = new Uint8Array(copyBuffer);\n\n      for (let i = 0; i < valueView.length; i += 4) {\n        valueView[i] = valueView[i + 3];\n        valueView[i + 1] = valueView[i + 2];\n        valueView[i + 2] = 0x00;\n        valueView[i + 3] = 0x00;\n      }\n\n      this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n    }\n\n    fromString(inputString) {\n      const strLength = inputString.length;\n      const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);\n\n      for (let i = 0; i < strLength; i++) {\n        const codeBuf = pvutils.utilToBase(inputString.charCodeAt(i), 8);\n        const codeView = new Uint8Array(codeBuf);\n        if (codeView.length > 4) continue;\n        const dif = 4 - codeView.length;\n\n        for (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 4 + j + dif] = codeView[j];\n      }\n\n      this.valueBlock.value = inputString;\n    }\n\n  }\n\n  LocalUniversalStringValueBlock.NAME = \"UniversalStringValueBlock\";\n  return LocalUniversalStringValueBlock;\n})();\n\nvar _a$g;\n\nclass UniversalString extends LocalUniversalStringValueBlock {\n  constructor({ ...parameters\n  } = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 28;\n  }\n\n}\n\n_a$g = UniversalString;\n\n(() => {\n  typeStore.UniversalString = _a$g;\n})();\n\nUniversalString.NAME = \"UniversalString\";\n\nvar _a$f;\n\nclass NumericString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 18;\n  }\n\n}\n\n_a$f = NumericString;\n\n(() => {\n  typeStore.NumericString = _a$f;\n})();\n\nNumericString.NAME = \"NumericString\";\n\nvar _a$e;\n\nclass PrintableString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 19;\n  }\n\n}\n\n_a$e = PrintableString;\n\n(() => {\n  typeStore.PrintableString = _a$e;\n})();\n\nPrintableString.NAME = \"PrintableString\";\n\nvar _a$d;\n\nclass TeletexString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 20;\n  }\n\n}\n\n_a$d = TeletexString;\n\n(() => {\n  typeStore.TeletexString = _a$d;\n})();\n\nTeletexString.NAME = \"TeletexString\";\n\nvar _a$c;\n\nclass VideotexString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 21;\n  }\n\n}\n\n_a$c = VideotexString;\n\n(() => {\n  typeStore.VideotexString = _a$c;\n})();\n\nVideotexString.NAME = \"VideotexString\";\n\nvar _a$b;\n\nclass IA5String extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 22;\n  }\n\n}\n\n_a$b = IA5String;\n\n(() => {\n  typeStore.IA5String = _a$b;\n})();\n\nIA5String.NAME = \"IA5String\";\n\nvar _a$a;\n\nclass GraphicString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 25;\n  }\n\n}\n\n_a$a = GraphicString;\n\n(() => {\n  typeStore.GraphicString = _a$a;\n})();\n\nGraphicString.NAME = \"GraphicString\";\n\nvar _a$9;\n\nclass VisibleString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 26;\n  }\n\n}\n\n_a$9 = VisibleString;\n\n(() => {\n  typeStore.VisibleString = _a$9;\n})();\n\nVisibleString.NAME = \"VisibleString\";\n\nvar _a$8;\n\nclass GeneralString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 27;\n  }\n\n}\n\n_a$8 = GeneralString;\n\n(() => {\n  typeStore.GeneralString = _a$8;\n})();\n\nGeneralString.NAME = \"GeneralString\";\n\nvar _a$7;\n\nclass CharacterString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 29;\n  }\n\n}\n\n_a$7 = CharacterString;\n\n(() => {\n  typeStore.CharacterString = _a$7;\n})();\n\nCharacterString.NAME = \"CharacterString\";\n\nvar _a$6;\n\nclass UTCTime extends VisibleString {\n  constructor({\n    value,\n    valueDate,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.year = 0;\n    this.month = 0;\n    this.day = 0;\n    this.hour = 0;\n    this.minute = 0;\n    this.second = 0;\n\n    if (value) {\n      this.fromString(value);\n      this.valueBlock.valueHexView = new Uint8Array(value.length);\n\n      for (let i = 0; i < value.length; i++) this.valueBlock.valueHexView[i] = value.charCodeAt(i);\n    }\n\n    if (valueDate) {\n      this.fromDate(valueDate);\n      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());\n    }\n\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 23;\n  }\n\n  fromBuffer(inputBuffer) {\n    this.fromString(String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer)));\n  }\n\n  toBuffer() {\n    const str = this.toString();\n    const buffer = new ArrayBuffer(str.length);\n    const view = new Uint8Array(buffer);\n\n    for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n\n    return buffer;\n  }\n\n  fromDate(inputDate) {\n    this.year = inputDate.getUTCFullYear();\n    this.month = inputDate.getUTCMonth() + 1;\n    this.day = inputDate.getUTCDate();\n    this.hour = inputDate.getUTCHours();\n    this.minute = inputDate.getUTCMinutes();\n    this.second = inputDate.getUTCSeconds();\n  }\n\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));\n  }\n\n  fromString(inputString) {\n    const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n    const parserArray = parser.exec(inputString);\n\n    if (parserArray === null) {\n      this.error = \"Wrong input string for conversion\";\n      return;\n    }\n\n    const year = parseInt(parserArray[1], 10);\n    if (year >= 50) this.year = 1900 + year;else this.year = 2000 + year;\n    this.month = parseInt(parserArray[2], 10);\n    this.day = parseInt(parserArray[3], 10);\n    this.hour = parseInt(parserArray[4], 10);\n    this.minute = parseInt(parserArray[5], 10);\n    this.second = parseInt(parserArray[6], 10);\n  }\n\n  toString(encoding = \"iso\") {\n    if (encoding === \"iso\") {\n      const outputArray = new Array(7);\n      outputArray[0] = pvutils.padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);\n      outputArray[1] = pvutils.padNumber(this.month, 2);\n      outputArray[2] = pvutils.padNumber(this.day, 2);\n      outputArray[3] = pvutils.padNumber(this.hour, 2);\n      outputArray[4] = pvutils.padNumber(this.minute, 2);\n      outputArray[5] = pvutils.padNumber(this.second, 2);\n      outputArray[6] = \"Z\";\n      return outputArray.join(\"\");\n    }\n\n    return super.toString(encoding);\n  }\n\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;\n  }\n\n  toJSON() {\n    return { ...super.toJSON(),\n      year: this.year,\n      month: this.month,\n      day: this.day,\n      hour: this.hour,\n      minute: this.minute,\n      second: this.second\n    };\n  }\n\n}\n\n_a$6 = UTCTime;\n\n(() => {\n  typeStore.UTCTime = _a$6;\n})();\n\nUTCTime.NAME = \"UTCTime\";\n\nvar _a$5;\n\nclass GeneralizedTime extends UTCTime {\n  constructor(parameters = {}) {\n    var _b;\n\n    super(parameters);\n    (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 24;\n  }\n\n  fromDate(inputDate) {\n    super.fromDate(inputDate);\n    this.millisecond = inputDate.getUTCMilliseconds();\n  }\n\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));\n  }\n\n  fromString(inputString) {\n    let isUTC = false;\n    let timeString = \"\";\n    let dateTimeString = \"\";\n    let fractionPart = 0;\n    let parser;\n    let hourDifference = 0;\n    let minuteDifference = 0;\n\n    if (inputString[inputString.length - 1] === \"Z\") {\n      timeString = inputString.substring(0, inputString.length - 1);\n      isUTC = true;\n    } else {\n      const number = new Number(inputString[inputString.length - 1]);\n      if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for conversion\");\n      timeString = inputString;\n    }\n\n    if (isUTC) {\n      if (timeString.indexOf(\"+\") !== -1) throw new Error(\"Wrong input string for conversion\");\n      if (timeString.indexOf(\"-\") !== -1) throw new Error(\"Wrong input string for conversion\");\n    } else {\n      let multiplier = 1;\n      let differencePosition = timeString.indexOf(\"+\");\n      let differenceString = \"\";\n\n      if (differencePosition === -1) {\n        differencePosition = timeString.indexOf(\"-\");\n        multiplier = -1;\n      }\n\n      if (differencePosition !== -1) {\n        differenceString = timeString.substring(differencePosition + 1);\n        timeString = timeString.substring(0, differencePosition);\n        if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error(\"Wrong input string for conversion\");\n        let number = parseInt(differenceString.substring(0, 2), 10);\n        if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for conversion\");\n        hourDifference = multiplier * number;\n\n        if (differenceString.length === 4) {\n          number = parseInt(differenceString.substring(2, 4), 10);\n          if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for conversion\");\n          minuteDifference = multiplier * number;\n        }\n      }\n    }\n\n    let fractionPointPosition = timeString.indexOf(\".\");\n    if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(\",\");\n\n    if (fractionPointPosition !== -1) {\n      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);\n      if (isNaN(fractionPartCheck.valueOf())) throw new Error(\"Wrong input string for conversion\");\n      fractionPart = fractionPartCheck.valueOf();\n      dateTimeString = timeString.substring(0, fractionPointPosition);\n    } else dateTimeString = timeString;\n\n    switch (true) {\n      case dateTimeString.length === 8:\n        parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n        if (fractionPointPosition !== -1) throw new Error(\"Wrong input string for conversion\");\n        break;\n\n      case dateTimeString.length === 10:\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.minute = Math.floor(fractionResult);\n          fractionResult = 60 * (fractionResult - this.minute);\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1000 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      case dateTimeString.length === 12:\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1000 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      case dateTimeString.length === 14:\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          const fractionResult = 1000 * fractionPart;\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Wrong input string for conversion\");\n    }\n\n    const parserArray = parser.exec(dateTimeString);\n    if (parserArray === null) throw new Error(\"Wrong input string for conversion\");\n\n    for (let j = 1; j < parserArray.length; j++) {\n      switch (j) {\n        case 1:\n          this.year = parseInt(parserArray[j], 10);\n          break;\n\n        case 2:\n          this.month = parseInt(parserArray[j], 10);\n          break;\n\n        case 3:\n          this.day = parseInt(parserArray[j], 10);\n          break;\n\n        case 4:\n          this.hour = parseInt(parserArray[j], 10) + hourDifference;\n          break;\n\n        case 5:\n          this.minute = parseInt(parserArray[j], 10) + minuteDifference;\n          break;\n\n        case 6:\n          this.second = parseInt(parserArray[j], 10);\n          break;\n\n        default:\n          throw new Error(\"Wrong input string for conversion\");\n      }\n    }\n\n    if (isUTC === false) {\n      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n      this.year = tempDate.getUTCFullYear();\n      this.month = tempDate.getUTCMonth();\n      this.day = tempDate.getUTCDay();\n      this.hour = tempDate.getUTCHours();\n      this.minute = tempDate.getUTCMinutes();\n      this.second = tempDate.getUTCSeconds();\n      this.millisecond = tempDate.getUTCMilliseconds();\n    }\n  }\n\n  toString(encoding = \"iso\") {\n    if (encoding === \"iso\") {\n      const outputArray = [];\n      outputArray.push(pvutils.padNumber(this.year, 4));\n      outputArray.push(pvutils.padNumber(this.month, 2));\n      outputArray.push(pvutils.padNumber(this.day, 2));\n      outputArray.push(pvutils.padNumber(this.hour, 2));\n      outputArray.push(pvutils.padNumber(this.minute, 2));\n      outputArray.push(pvutils.padNumber(this.second, 2));\n\n      if (this.millisecond !== 0) {\n        outputArray.push(\".\");\n        outputArray.push(pvutils.padNumber(this.millisecond, 3));\n      }\n\n      outputArray.push(\"Z\");\n      return outputArray.join(\"\");\n    }\n\n    return super.toString(encoding);\n  }\n\n  toJSON() {\n    return { ...super.toJSON(),\n      millisecond: this.millisecond\n    };\n  }\n\n}\n\n_a$5 = GeneralizedTime;\n\n(() => {\n  typeStore.GeneralizedTime = _a$5;\n})();\n\nGeneralizedTime.NAME = \"GeneralizedTime\";\n\nvar _a$4;\n\nclass DATE extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 31;\n  }\n\n}\n\n_a$4 = DATE;\n\n(() => {\n  typeStore.DATE = _a$4;\n})();\n\nDATE.NAME = \"DATE\";\n\nvar _a$3;\n\nclass TimeOfDay extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 32;\n  }\n\n}\n\n_a$3 = TimeOfDay;\n\n(() => {\n  typeStore.TimeOfDay = _a$3;\n})();\n\nTimeOfDay.NAME = \"TimeOfDay\";\n\nvar _a$2;\n\nclass DateTime extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 33;\n  }\n\n}\n\n_a$2 = DateTime;\n\n(() => {\n  typeStore.DateTime = _a$2;\n})();\n\nDateTime.NAME = \"DateTime\";\n\nvar _a$1;\n\nclass Duration extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 34;\n  }\n\n}\n\n_a$1 = Duration;\n\n(() => {\n  typeStore.Duration = _a$1;\n})();\n\nDuration.NAME = \"Duration\";\n\nvar _a;\n\nclass TIME extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 14;\n  }\n\n}\n\n_a = TIME;\n\n(() => {\n  typeStore.TIME = _a;\n})();\n\nTIME.NAME = \"TIME\";\n\nclass Any {\n  constructor({\n    name = EMPTY_STRING,\n    optional = false\n  } = {}) {\n    this.name = name;\n    this.optional = optional;\n  }\n\n}\n\nclass Choice extends Any {\n  constructor({\n    value = [],\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.value = value;\n  }\n\n}\n\nclass Repeated extends Any {\n  constructor({\n    value = new Any(),\n    local = false,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.value = value;\n    this.local = local;\n  }\n\n}\n\nclass RawData {\n  constructor({\n    data = EMPTY_VIEW\n  } = {}) {\n    this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(data);\n  }\n\n  get data() {\n    return this.dataView.slice().buffer;\n  }\n\n  set data(value) {\n    this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(value);\n  }\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const endLength = inputOffset + inputLength;\n    this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);\n    return endLength;\n  }\n\n  toBER(sizeOnly) {\n    return this.dataView.slice().buffer;\n  }\n\n}\n\nfunction compareSchema(root, inputData, inputSchema) {\n  if (inputSchema instanceof Choice) {\n    for (let j = 0; j < inputSchema.value.length; j++) {\n      const result = compareSchema(root, inputData, inputSchema.value[j]);\n\n      if (result.verified) {\n        return {\n          verified: true,\n          result: root\n        };\n      }\n    }\n\n    {\n      const _result = {\n        verified: false,\n        result: {\n          error: \"Wrong values for Choice type\"\n        }\n      };\n      if (inputSchema.hasOwnProperty(NAME)) _result.name = inputSchema.name;\n      return _result;\n    }\n  }\n\n  if (inputSchema instanceof Any) {\n    if (inputSchema.hasOwnProperty(NAME)) root[inputSchema.name] = inputData;\n    return {\n      verified: true,\n      result: root\n    };\n  }\n\n  if (root instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong root object\"\n      }\n    };\n  }\n\n  if (inputData instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 data\"\n      }\n    };\n  }\n\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (ID_BLOCK in inputSchema === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (FROM_BER in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (TO_BER in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  const encodedId = inputSchema.idBlock.toBER(false);\n\n  if (encodedId.byteLength === 0) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error encoding idBlock for ASN.1 schema\"\n      }\n    };\n  }\n\n  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n\n  if (decodedOffset === -1) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error decoding idBlock for ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\n    return {\n      verified: false,\n      result: root\n    };\n  }\n\n  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\n    return {\n      verified: false,\n      result: root\n    };\n  }\n\n  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\n    return {\n      verified: false,\n      result: root\n    };\n  }\n\n  if (!(IS_HEX_ONLY in inputSchema.idBlock)) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\n    return {\n      verified: false,\n      result: root\n    };\n  }\n\n  if (inputSchema.idBlock.isHexOnly) {\n    if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {\n      return {\n        verified: false,\n        result: {\n          error: \"Wrong ASN.1 schema\"\n        }\n      };\n    }\n\n    const schemaView = inputSchema.idBlock.valueHexView;\n    const asn1View = inputData.idBlock.valueHexView;\n\n    if (schemaView.length !== asn1View.length) {\n      return {\n        verified: false,\n        result: root\n      };\n    }\n\n    for (let i = 0; i < schemaView.length; i++) {\n      if (schemaView[i] !== asn1View[1]) {\n        return {\n          verified: false,\n          result: root\n        };\n      }\n    }\n  }\n\n  if (inputSchema.name) {\n    inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n    if (inputSchema.name) root[inputSchema.name] = inputData;\n  }\n\n  if (inputSchema instanceof typeStore.Constructed) {\n    let admission = 0;\n    let result = {\n      verified: false,\n      result: {\n        error: \"Unknown error\"\n      }\n    };\n    let maxLength = inputSchema.valueBlock.value.length;\n\n    if (maxLength > 0) {\n      if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n        maxLength = inputData.valueBlock.value.length;\n      }\n    }\n\n    if (maxLength === 0) {\n      return {\n        verified: true,\n        result: root\n      };\n    }\n\n    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {\n      let _optional = true;\n\n      for (let i = 0; i < inputSchema.valueBlock.value.length; i++) _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\n\n      if (_optional) {\n        return {\n          verified: true,\n          result: root\n        };\n      }\n\n      if (inputSchema.name) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n        if (inputSchema.name) delete root[inputSchema.name];\n      }\n\n      root.error = \"Inconsistent object length\";\n      return {\n        verified: false,\n        result: root\n      };\n    }\n\n    for (let i = 0; i < maxLength; i++) {\n      if (i - admission >= inputData.valueBlock.value.length) {\n        if (inputSchema.valueBlock.value[i].optional === false) {\n          const _result = {\n            verified: false,\n            result: root\n          };\n          root.error = \"Inconsistent length between ASN.1 data and schema\";\n\n          if (inputSchema.name) {\n            inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n\n            if (inputSchema.name) {\n              delete root[inputSchema.name];\n              _result.name = inputSchema.name;\n            }\n          }\n\n          return _result;\n        }\n      } else {\n        if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n          result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\n\n          if (result.verified === false) {\n            if (inputSchema.valueBlock.value[0].optional) admission++;else {\n              if (inputSchema.name) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                if (inputSchema.name) delete root[inputSchema.name];\n              }\n\n              return result;\n            }\n          }\n\n          if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {\n            let arrayRoot = {};\n            if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local) arrayRoot = inputData;else arrayRoot = root;\n            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\") arrayRoot[inputSchema.valueBlock.value[0].name] = [];\n            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\n          }\n        } else {\n          result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\n\n          if (result.verified === false) {\n            if (inputSchema.valueBlock.value[i].optional) admission++;else {\n              if (inputSchema.name) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                if (inputSchema.name) delete root[inputSchema.name];\n              }\n\n              return result;\n            }\n          }\n        }\n      }\n    }\n\n    if (result.verified === false) {\n      const _result = {\n        verified: false,\n        result: root\n      };\n\n      if (inputSchema.name) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n\n        if (inputSchema.name) {\n          delete root[inputSchema.name];\n          _result.name = inputSchema.name;\n        }\n      }\n\n      return _result;\n    }\n\n    return {\n      verified: true,\n      result: root\n    };\n  }\n\n  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {\n    const asn1 = localFromBER(inputData.valueBlock.valueHexView);\n\n    if (asn1.offset === -1) {\n      const _result = {\n        verified: false,\n        result: asn1.result\n      };\n\n      if (inputSchema.name) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n\n        if (inputSchema.name) {\n          delete root[inputSchema.name];\n          _result.name = inputSchema.name;\n        }\n      }\n\n      return _result;\n    }\n\n    return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n  }\n\n  return {\n    verified: true,\n    result: root\n  };\n}\n\nfunction verifySchema(inputBuffer, inputSchema) {\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema type\"\n      }\n    };\n  }\n\n  const asn1 = localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));\n\n  if (asn1.offset === -1) {\n    return {\n      verified: false,\n      result: asn1.result\n    };\n  }\n\n  return compareSchema(asn1.result, asn1.result, inputSchema);\n}\n\nexport { Any, BaseBlock, BaseStringBlock, BitString, BmpString, Boolean, CharacterString, Choice, Constructed, DATE, DateTime, Duration, EndOfContent, Enumerated, GeneralString, GeneralizedTime, GraphicString, HexBlock, IA5String, Integer, Null, NumericString, ObjectIdentifier, OctetString, Primitive, PrintableString, RawData, RelativeObjectIdentifier, Repeated, Sequence, Set, TIME, TeletexString, TimeOfDay, UTCTime, UniversalString, Utf8String, ValueBlock, VideotexString, ViewWriter, VisibleString, compareSchema, fromBER, verifySchema };","map":null,"metadata":{},"sourceType":"module"}