{"ast":null,"code":"import _asyncToGenerator from \"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { generatePrivate, getPublic, decrypt } from '@toruslabs/eccrypto';\nimport { post, generateJsonRPCObject, setAPIKey, setEmbedHost, get } from '@toruslabs/http-helpers';\nimport BN from 'bn.js';\nimport { ec } from 'elliptic';\nimport JsonStringify from 'json-stable-stringify';\nimport { toChecksumAddress } from 'web3-utils';\nimport loglevel from 'loglevel';\nimport createKeccakHash from 'keccak';\nconst log = loglevel.getLogger(\"torus.js\");\nlog.disableAll();\n\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nclass SomeError extends Error {\n  constructor(_ref) {\n    let {\n      errors,\n      responses,\n      predicate\n    } = _ref;\n    super(\"Unable to resolve enough promises.\");\n\n    _defineProperty(this, \"errors\", void 0);\n\n    _defineProperty(this, \"responses\", void 0);\n\n    _defineProperty(this, \"predicate\", void 0);\n\n    this.errors = errors;\n    this.responses = responses;\n    this.predicate = predicate;\n  }\n\n}\n\nconst Some = (promises, predicate) => new Promise((resolve, reject) => {\n  let finishedCount = 0;\n  const sharedState = {\n    resolved: false\n  };\n  const errorArr = new Array(promises.length).fill(undefined);\n  const resultArr = new Array(promises.length).fill(undefined);\n  let predicateError;\n  return promises.forEach((x, index) => {\n    return x.then(resp => {\n      resultArr[index] = resp;\n      return undefined;\n    }).catch(error => {\n      errorArr[index] = error;\n    }) // eslint-disable-next-line promise/no-return-in-finally\n    .finally(() => {\n      if (sharedState.resolved) return;\n      return predicate(resultArr.slice(0), sharedState).then(data => {\n        sharedState.resolved = true;\n        resolve(data);\n        return undefined;\n      }).catch(error => {\n        // log only the last predicate error\n        predicateError = error;\n      }).finally(() => {\n        finishedCount += 1;\n\n        if (finishedCount === promises.length) {\n          const errors = Object.values(resultArr.reduce((acc, z) => {\n            if (z) {\n              var _error$data;\n\n              const {\n                id,\n                error\n              } = z;\n\n              if ((error === null || error === void 0 ? void 0 : (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.length) > 0) {\n                if (error.data.startsWith(\"Error occurred while verifying params\")) acc[id] = capitalizeFirstLetter(error.data);else acc[id] = error.data;\n              }\n            }\n\n            return acc;\n          }, {}));\n\n          if (errors.length > 0) {\n            // Format-able errors\n            const msg = errors.length > 1 ? `\\n${errors.map(it => `â€¢ ${it}`).join(\"\\n\")}` : errors[0];\n            reject(new Error(msg));\n          } else {\n            var _predicateError;\n\n            reject(new SomeError({\n              errors: errorArr,\n              responses: resultArr,\n              predicate: ((_predicateError = predicateError) === null || _predicateError === void 0 ? void 0 : _predicateError.message) || predicateError\n            }));\n          }\n        }\n      });\n    });\n  });\n});\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass GetOrSetNonceError extends Error {}\n\nconst kCombinations = (s, k) => {\n  let set = s;\n\n  if (typeof set === \"number\") {\n    set = Array.from({\n      length: set\n    }, (_, i) => i);\n  }\n\n  if (k > set.length || k <= 0) {\n    return [];\n  }\n\n  if (k === set.length) {\n    return [set];\n  }\n\n  if (k === 1) {\n    return set.reduce((acc, cur) => [...acc, [cur]], []);\n  }\n\n  const combs = [];\n  let tailCombs = [];\n\n  for (let i = 0; i <= set.length - k + 1; i += 1) {\n    tailCombs = kCombinations(set.slice(i + 1), k - 1);\n\n    for (let j = 0; j < tailCombs.length; j += 1) {\n      combs.push([set[i], ...tailCombs[j]]);\n    }\n  }\n\n  return combs;\n};\n\nconst thresholdSame = (arr, t) => {\n  const hashMap = {};\n\n  for (let i = 0; i < arr.length; i += 1) {\n    const str = JsonStringify(arr[i]);\n    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1;\n\n    if (hashMap[str] === t) {\n      return arr[i];\n    }\n  }\n\n  return undefined;\n};\n\nconst keyLookup = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (endpoints, verifier, verifierId) {\n    const lookupPromises = endpoints.map(x => post(x, generateJsonRPCObject(\"VerifierLookupRequest\", {\n      verifier,\n      verifier_id: verifierId.toString()\n    })).catch(err => log.error(\"lookup request failed\", err)));\n    return Some(lookupPromises, lookupResults => {\n      const lookupShares = lookupResults.filter(x1 => x1);\n      const errorResult = thresholdSame(lookupShares.map(x2 => x2 && x2.error), ~~(endpoints.length / 2) + 1);\n      const keyResult = thresholdSame(lookupShares.map(x3 => x3 && x3.result), ~~(endpoints.length / 2) + 1);\n\n      if (keyResult || errorResult) {\n        return Promise.resolve({\n          keyResult,\n          errorResult\n        });\n      }\n\n      return Promise.reject(new Error(`invalid results ${JSON.stringify(lookupResults)}`));\n    });\n  });\n\n  return function keyLookup(_x, _x2, _x3) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nconst waitKeyLookup = (endpoints, verifier, verifierId, timeout) => new Promise((resolve, reject) => {\n  setTimeout(() => {\n    keyLookup(endpoints, verifier, verifierId).then(resolve).catch(reject);\n  }, timeout);\n});\n\nconst keyAssign = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator(function* (_ref) {\n    let {\n      endpoints,\n      torusNodePubs,\n      lastPoint,\n      firstPoint,\n      verifier,\n      verifierId,\n      signerHost,\n      network\n    } = _ref;\n    let nodeNum;\n    let initialPoint;\n\n    if (lastPoint === undefined) {\n      nodeNum = Math.floor(Math.random() * endpoints.length);\n      initialPoint = nodeNum;\n    } else {\n      nodeNum = lastPoint % endpoints.length;\n    }\n\n    if (nodeNum === firstPoint) throw new Error(\"Looped through all\");\n    if (firstPoint !== undefined) initialPoint = firstPoint;\n    const data = generateJsonRPCObject(\"KeyAssign\", {\n      verifier,\n      verifier_id: verifierId.toString()\n    });\n\n    try {\n      const signedData = yield post(signerHost, data, {\n        headers: {\n          pubKeyX: torusNodePubs[nodeNum].X,\n          pubKeyY: torusNodePubs[nodeNum].Y,\n          network\n        }\n      }, {\n        useAPIKey: true\n      });\n      return yield post(endpoints[nodeNum], _objectSpread$1(_objectSpread$1({}, data), signedData), {\n        headers: {\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n      });\n    } catch (error) {\n      log.error(error);\n      const acceptedErrorMsgs = [// Slow node\n      \"Timed out\", // Happens when the node is not reachable (dns issue etc)\n      \"TypeError: Failed to fetch\", \"TypeError: cancelled\", \"TypeError: NetworkError when attempting to fetch resource.\" // Firefox\n      ];\n      if (acceptedErrorMsgs.includes(error.message)) return keyAssign({\n        endpoints,\n        torusNodePubs,\n        lastPoint: nodeNum + 1,\n        firstPoint: initialPoint,\n        verifier,\n        verifierId,\n        signerHost,\n        network\n      });\n      throw new Error(`Sorry, the Torus Network that powers Web3Auth is currently very busy.\n    We will generate your key in time. Pls try again later. \\n\n    ${error.message || \"\"}`);\n    }\n  });\n\n  return function keyAssign(_x4) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nfunction keccak256(a) {\n  const hash = createKeccakHash(\"keccak256\").update(a).digest().toString(\"hex\");\n  return `0x${hash}`;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n} // of Torus nodes to handle malicious node responses\n\n\nclass Torus {\n  constructor() {\n    let {\n      enableOneKey = false,\n      metadataHost = \"https://metadata.tor.us\",\n      allowHost = \"https://signer.tor.us/api/allow\",\n      signerHost = \"https://signer.tor.us/api/sign\",\n      serverTimeOffset = 0,\n      network = \"mainnet\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _defineProperty(this, \"metadataHost\", void 0);\n\n    _defineProperty(this, \"allowHost\", void 0);\n\n    _defineProperty(this, \"serverTimeOffset\", void 0);\n\n    _defineProperty(this, \"enableOneKey\", void 0);\n\n    _defineProperty(this, \"signerHost\", void 0);\n\n    _defineProperty(this, \"network\", void 0);\n\n    _defineProperty(this, \"ec\", void 0);\n\n    this.ec = new ec(\"secp256k1\");\n    this.metadataHost = metadataHost;\n    this.allowHost = allowHost;\n    this.enableOneKey = enableOneKey;\n    this.serverTimeOffset = serverTimeOffset || 0; // ms\n\n    this.signerHost = signerHost;\n    this.network = network;\n  }\n\n  static enableLogging() {\n    let v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (v) log.enableAll();else log.disableAll();\n  }\n\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey);\n  }\n\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost);\n  }\n\n  static isGetOrSetNonceError(err) {\n    return err instanceof GetOrSetNonceError;\n  }\n  /**\n   * Note: use this function only for openlogin tkey account lookups.\n   */\n\n\n  getUserTypeAndAddress(endpoints, torusNodePubs, _ref) {\n    var _arguments = arguments,\n        _this = this;\n\n    return _asyncToGenerator(function* () {\n      let {\n        verifier,\n        verifierId\n      } = _ref;\n      let doesKeyAssign = _arguments.length > 3 && _arguments[3] !== undefined ? _arguments[3] : false;\n      const {\n        keyResult,\n        errorResult\n      } = (yield keyLookup(endpoints, verifier, verifierId)) || {};\n      let isNewKey = false;\n      let finalKeyResult;\n\n      if (errorResult && JSON.stringify(errorResult).includes(\"Verifier + VerifierID has not yet been assigned\")) {\n        if (!doesKeyAssign) {\n          throw new Error(\"Verifier + VerifierID has not yet been assigned\");\n        }\n\n        yield keyAssign({\n          endpoints,\n          torusNodePubs,\n          lastPoint: undefined,\n          firstPoint: undefined,\n          verifier,\n          verifierId,\n          signerHost: _this.signerHost,\n          network: _this.network\n        });\n        const assignResult = yield waitKeyLookup(endpoints, verifier, verifierId, 1000);\n        finalKeyResult = assignResult === null || assignResult === void 0 ? void 0 : assignResult.keyResult;\n        isNewKey = true;\n      } else if (keyResult) {\n        finalKeyResult = keyResult;\n      } else {\n        throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n      }\n\n      if (finalKeyResult) {\n        const {\n          pub_key_X: X,\n          pub_key_Y: Y\n        } = finalKeyResult.keys[0];\n        let nonceResult;\n        let nonce;\n        let modifiedPubKey;\n\n        try {\n          nonceResult = yield _this.getOrSetNonce(X, Y, undefined, !isNewKey);\n          nonce = new BN(nonceResult.nonce || \"0\", 16);\n        } catch {\n          throw new GetOrSetNonceError();\n        }\n\n        if (nonceResult.typeOfUser === \"v1\") {\n          modifiedPubKey = _this.ec.keyFromPublic({\n            x: X,\n            y: Y\n          }).getPublic().add(_this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n        } else if (nonceResult.typeOfUser === \"v2\") {\n          modifiedPubKey = _this.ec.keyFromPublic({\n            x: X,\n            y: Y\n          }).getPublic().add(_this.ec.keyFromPublic({\n            x: nonceResult.pubNonce.x,\n            y: nonceResult.pubNonce.y\n          }).getPublic());\n        } else {\n          throw new Error(\"getOrSetNonce should always return typeOfUser.\");\n        }\n\n        const finalX = modifiedPubKey.getX().toString(16);\n        const finalY = modifiedPubKey.getY().toString(16);\n\n        const address = _this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n\n        if (nonceResult.typeOfUser === \"v1\") return {\n          typeOfUser: nonceResult.typeOfUser,\n          nonce,\n          X: finalX,\n          Y: finalY,\n          address\n        };else if (nonceResult.typeOfUser === \"v2\") {\n          return {\n            typeOfUser: nonceResult.typeOfUser,\n            nonce,\n            pubNonce: nonceResult.pubNonce,\n            upgraded: nonceResult.upgraded,\n            X: finalX,\n            Y: finalY,\n            address\n          };\n        }\n      }\n\n      throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n    })();\n  }\n\n  setCustomKey(_ref2) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let {\n        privKeyHex,\n        metadataNonce,\n        torusKeyHex,\n        customKeyHex\n      } = _ref2;\n      let torusKey;\n\n      if (torusKeyHex) {\n        torusKey = new BN(torusKeyHex, 16);\n      } else {\n        const privKey = new BN(privKeyHex, 16);\n        torusKey = privKey.sub(metadataNonce).umod(_this2.ec.curve.n);\n      }\n\n      const customKey = new BN(customKeyHex, 16);\n      const newMetadataNonce = customKey.sub(torusKey).umod(_this2.ec.curve.n);\n\n      const data = _this2.generateMetadataParams(newMetadataNonce.toString(16), torusKey);\n\n      yield _this2.setMetadata(data);\n    })();\n  }\n\n  retrieveShares(endpoints, indexes, verifier, verifierParams, idToken) {\n    var _arguments2 = arguments,\n        _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let extraParams = _arguments2.length > 5 && _arguments2[5] !== undefined ? _arguments2[5] : {};\n      const promiseArr = [];\n      yield get(_this3.allowHost, {\n        headers: {\n          verifier,\n          verifier_id: verifierParams.verifier_id,\n          network: _this3.network\n        }\n      }, {\n        useAPIKey: true\n      });\n      /*\n        CommitmentRequestParams struct {\n          MessagePrefix      string `json:\"messageprefix\"`\n          TokenCommitment    string `json:\"tokencommitment\"`\n          TempPubX           string `json:\"temppubx\"`\n          TempPubY           string `json:\"temppuby\"`\n          VerifierIdentifier string `json:\"verifieridentifier\"`\n        }\n        */\n      // generate temporary private and public key that is used to secure receive shares\n\n      const tmpKey = generatePrivate();\n      const pubKey = getPublic(tmpKey).toString(\"hex\");\n      const pubKeyX = pubKey.slice(2, 66);\n      const pubKeyY = pubKey.slice(66);\n      const tokenCommitment = keccak256(idToken); // make commitment requests to endpoints\n\n      for (let i = 0; i < endpoints.length; i += 1) {\n        const p = post(endpoints[i], generateJsonRPCObject(\"CommitmentRequest\", {\n          messageprefix: \"mug00\",\n          tokencommitment: tokenCommitment.slice(2),\n          temppubx: pubKeyX,\n          temppuby: pubKeyY,\n          verifieridentifier: verifier\n        })).catch(err => {\n          log.error(\"commitment\", err);\n        });\n        promiseArr.push(p);\n      }\n      /*\n        ShareRequestParams struct {\n          Item []bijson.RawMessage `json:\"item\"`\n        }\n        ShareRequestItem struct {\n          IDToken            string          `json:\"idtoken\"`\n          NodeSignatures     []NodeSignature `json:\"nodesignatures\"`\n          VerifierIdentifier string          `json:\"verifieridentifier\"`\n        }\n        NodeSignature struct {\n          Signature   string\n          Data        string\n          NodePubKeyX string\n          NodePubKeyY string\n        }\n        CommitmentRequestResult struct {\n          Signature string `json:\"signature\"`\n          Data      string `json:\"data\"`\n          NodePubX  string `json:\"nodepubx\"`\n          NodePubY  string `json:\"nodepuby\"`\n        }\n        */\n      // send share request once k + t number of commitment requests have completed\n\n\n      return Some(promiseArr, resultArr => {\n        const completedRequests = resultArr.filter(x => {\n          if (!x || typeof x !== \"object\") {\n            return false;\n          }\n\n          if (x.error) {\n            return false;\n          }\n\n          return true;\n        });\n\n        if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {\n          return Promise.resolve(resultArr);\n        }\n\n        return Promise.reject(new Error(`invalid ${JSON.stringify(resultArr)}`));\n      }).then(responses => {\n        const promiseArrRequest = [];\n        const nodeSigs = [];\n\n        for (let i = 0; i < responses.length; i += 1) {\n          if (responses[i]) nodeSigs.push(responses[i].result);\n        }\n\n        for (let i = 0; i < endpoints.length; i += 1) {\n          // eslint-disable-next-line promise/no-nesting\n          const p = post(endpoints[i], generateJsonRPCObject(\"ShareRequest\", {\n            encrypted: \"yes\",\n            item: [_objectSpread(_objectSpread({}, verifierParams), {}, {\n              idtoken: idToken,\n              nodesignatures: nodeSigs,\n              verifieridentifier: verifier\n            }, extraParams)]\n          })).catch(err => log.error(\"share req\", err));\n          promiseArrRequest.push(p);\n        }\n\n        return Some(promiseArrRequest, /*#__PURE__*/function () {\n          var _ref6 = _asyncToGenerator(function* (shareResponses, sharedState) {\n            /*\n                ShareRequestResult struct {\n                  Keys []KeyAssignment\n                }\n                        / KeyAssignmentPublic -\n                type KeyAssignmentPublic struct {\n                  Index     big.Int\n                  PublicKey common.Point\n                  Threshold int\n                  Verifiers map[string][]string // Verifier => VerifierID\n                }\n                       // KeyAssignment -\n                type KeyAssignment struct {\n                  KeyAssignmentPublic\n                  Share big.Int // Or Si\n                }\n              */\n            // check if threshold number of nodes have returned the same user public key\n            const completedRequests = shareResponses.filter(x => x);\n            const thresholdPublicKey = thresholdSame(shareResponses.map(x => x && x.result && x.result.keys[0].PublicKey), ~~(endpoints.length / 2) + 1); // optimistically run lagrange interpolation once threshold number of shares have been received\n            // this is matched against the user public key to ensure that shares are consistent\n\n            if (completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey) {\n              const sharePromises = [];\n              const nodeIndexes = [];\n\n              for (let i = 0; i < shareResponses.length; i += 1) {\n                var _currentShareResponse, _currentShareResponse2;\n\n                const currentShareResponse = shareResponses[i];\n\n                if ((currentShareResponse === null || currentShareResponse === void 0 ? void 0 : (_currentShareResponse = currentShareResponse.result) === null || _currentShareResponse === void 0 ? void 0 : (_currentShareResponse2 = _currentShareResponse.keys) === null || _currentShareResponse2 === void 0 ? void 0 : _currentShareResponse2.length) > 0) {\n                  currentShareResponse.result.keys.sort((a, b) => new BN(a.Index, 16).cmp(new BN(b.Index, 16)));\n                  const firstKey = currentShareResponse.result.keys[0];\n\n                  if (firstKey.Metadata) {\n                    const metadata = {\n                      ephemPublicKey: Buffer.from(firstKey.Metadata.ephemPublicKey, \"hex\"),\n                      iv: Buffer.from(firstKey.Metadata.iv, \"hex\"),\n                      mac: Buffer.from(firstKey.Metadata.mac, \"hex\") // mode: Buffer.from(firstKey.Metadata.mode, \"hex\"),\n\n                    };\n                    sharePromises.push( // eslint-disable-next-line promise/no-nesting\n                    decrypt(tmpKey, _objectSpread(_objectSpread({}, metadata), {}, {\n                      ciphertext: Buffer.from(Buffer.from(firstKey.Share, \"base64\").toString(\"binary\").padStart(64, \"0\"), \"hex\")\n                    })).catch(err => log.debug(\"share decryption\", err)));\n                  } else {\n                    sharePromises.push(Promise.resolve(Buffer.from(firstKey.Share.padStart(64, \"0\"), \"hex\")));\n                  }\n                } else {\n                  sharePromises.push(Promise.resolve(undefined));\n                }\n\n                nodeIndexes.push(new BN(indexes[i], 16));\n              }\n\n              const sharesResolved = yield Promise.all(sharePromises);\n              if (sharedState.resolved) return undefined;\n              const decryptedShares = sharesResolved.reduce((acc, curr, index) => {\n                if (curr) acc.push({\n                  index: nodeIndexes[index],\n                  value: new BN(curr)\n                });\n                return acc;\n              }, []); // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit\n\n              const allCombis = kCombinations(decryptedShares.length, ~~(endpoints.length / 2) + 1);\n              let privateKey = null;\n\n              for (let j = 0; j < allCombis.length; j += 1) {\n                const currentCombi = allCombis[j];\n                const currentCombiShares = decryptedShares.filter((v, index) => currentCombi.includes(index));\n                const shares = currentCombiShares.map(x => x.value);\n                const indices = currentCombiShares.map(x => x.index);\n\n                const derivedPrivateKey = _this3.lagrangeInterpolation(shares, indices);\n\n                if (!derivedPrivateKey) continue;\n                const decryptedPubKey = getPublic(Buffer.from(derivedPrivateKey.toString(16, 64), \"hex\")).toString(\"hex\");\n                const decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n                const decryptedPubKeyY = decryptedPubKey.slice(66);\n\n                if (new BN(decryptedPubKeyX, 16).cmp(new BN(thresholdPublicKey.X, 16)) === 0 && new BN(decryptedPubKeyY, 16).cmp(new BN(thresholdPublicKey.Y, 16)) === 0) {\n                  privateKey = derivedPrivateKey;\n                  break;\n                }\n              }\n\n              if (privateKey === undefined || privateKey === null) {\n                throw new Error(\"could not derive private key\");\n              }\n\n              return privateKey;\n            }\n\n            throw new Error(\"invalid\");\n          });\n\n          return function (_x5, _x6) {\n            return _ref6.apply(this, arguments);\n          };\n        }());\n      }).then( /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator(function* (returnedKey) {\n          let privateKey = returnedKey;\n          if (!privateKey) throw new Error(\"Invalid private key returned\");\n          const decryptedPubKey = getPublic(Buffer.from(privateKey.toString(16, 64), \"hex\")).toString(\"hex\");\n          const decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n          const decryptedPubKeyY = decryptedPubKey.slice(66);\n          let metadataNonce;\n\n          if (_this3.enableOneKey) {\n            const {\n              nonce\n            } = yield _this3.getNonce(decryptedPubKeyX, decryptedPubKeyY, privateKey);\n            metadataNonce = new BN(nonce || \"0\", 16);\n          } else {\n            metadataNonce = yield _this3.getMetadata({\n              pub_key_X: decryptedPubKeyX,\n              pub_key_Y: decryptedPubKeyY\n            });\n          }\n\n          log.debug(\"> torus.js/retrieveShares\", {\n            privKey: privateKey.toString(16),\n            metadataNonce: metadataNonce.toString(16)\n          });\n          privateKey = privateKey.add(metadataNonce).umod(_this3.ec.curve.n);\n\n          const ethAddress = _this3.generateAddressFromPrivKey(privateKey);\n\n          log.debug(\"> torus.js/retrieveShares\", {\n            ethAddress,\n            privKey: privateKey.toString(16)\n          }); // return reconstructed private key and ethereum address\n\n          return {\n            ethAddress,\n            privKey: privateKey.toString(\"hex\", 64),\n            metadataNonce\n          };\n        });\n\n        return function (_x7) {\n          return _ref7.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  getMetadata(data) {\n    var _arguments3 = arguments,\n        _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      let options = _arguments3.length > 1 && _arguments3[1] !== undefined ? _arguments3[1] : {};\n\n      try {\n        const metadataResponse = yield post(`${_this4.metadataHost}/get`, data, options, {\n          useAPIKey: true\n        });\n\n        if (!metadataResponse || !metadataResponse.message) {\n          return new BN(0);\n        }\n\n        return new BN(metadataResponse.message, 16); // nonce\n      } catch (error) {\n        log.error(\"get metadata error\", error);\n        return new BN(0);\n      }\n    })();\n  }\n\n  generateMetadataParams(message, privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString(\"hex\", 64));\n    const setData = {\n      data: message,\n      timestamp: new BN(~~(this.serverTimeOffset + Date.now() / 1000)).toString(16)\n    };\n    const sig = key.sign(keccak256(JsonStringify(setData)).slice(2));\n    return {\n      pub_key_X: key.getPublic().getX().toString(\"hex\"),\n      pub_key_Y: key.getPublic().getY().toString(\"hex\"),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(\"\").toString(16, 2), \"hex\").toString(\"base64\")\n    };\n  }\n\n  setMetadata(data) {\n    var _arguments4 = arguments,\n        _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      let options = _arguments4.length > 1 && _arguments4[1] !== undefined ? _arguments4[1] : {};\n\n      try {\n        const metadataResponse = yield post(`${_this5.metadataHost}/set`, data, options, {\n          useAPIKey: true\n        });\n        return metadataResponse.message; // IPFS hash\n      } catch (error) {\n        log.error(\"set metadata error\", error);\n        return \"\";\n      }\n    })();\n  }\n\n  lagrangeInterpolation(shares, nodeIndex) {\n    if (shares.length !== nodeIndex.length) {\n      return null;\n    }\n\n    let secret = new BN(0);\n\n    for (let i = 0; i < shares.length; i += 1) {\n      let upper = new BN(1);\n      let lower = new BN(1);\n\n      for (let j = 0; j < shares.length; j += 1) {\n        if (i !== j) {\n          upper = upper.mul(nodeIndex[j].neg());\n          upper = upper.umod(this.ec.curve.n);\n          let temp = nodeIndex[i].sub(nodeIndex[j]);\n          temp = temp.umod(this.ec.curve.n);\n          lower = lower.mul(temp).umod(this.ec.curve.n);\n        }\n      }\n\n      let delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n);\n      delta = delta.mul(shares[i]).umod(this.ec.curve.n);\n      secret = secret.add(delta);\n    }\n\n    return secret.umod(this.ec.curve.n);\n  }\n\n  generateAddressFromPrivKey(privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString(\"hex\", 64), \"hex\");\n    const publicKey = key.getPublic().encode(\"hex\", false).slice(2);\n    log.info(publicKey, \"public key\");\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, \"hex\")).slice(64 - 38)}`;\n    return toChecksumAddress(ethAddressLower);\n  }\n\n  generateAddressFromPubKey(publicKeyX, publicKeyY) {\n    const key = this.ec.keyFromPublic({\n      x: publicKeyX.toString(\"hex\", 64),\n      y: publicKeyY.toString(\"hex\", 64)\n    });\n    const publicKey = key.getPublic().encode(\"hex\", false).slice(2);\n    log.info(key.getPublic().encode(\"hex\", false), \"public key\");\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, \"hex\")).slice(64 - 38)}`;\n    return toChecksumAddress(ethAddressLower);\n  }\n  /**\n   * Note: use this function only with custom auth, don't use to lookup openlogin accounts.\n   */\n\n\n  getPublicAddress(endpoints, torusNodePubs, _ref3) {\n    var _arguments5 = arguments,\n        _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      let {\n        verifier,\n        verifierId\n      } = _ref3;\n      let isExtended = _arguments5.length > 3 && _arguments5[3] !== undefined ? _arguments5[3] : false;\n      log.debug(\"> torus.js/getPublicAddress\", {\n        endpoints,\n        torusNodePubs,\n        verifier,\n        verifierId,\n        isExtended\n      });\n      let finalKeyResult;\n      let isNewKey = false;\n      const {\n        keyResult,\n        errorResult\n      } = (yield keyLookup(endpoints, verifier, verifierId)) || {};\n\n      if (errorResult && JSON.stringify(errorResult).includes(\"Verifier not supported\")) {\n        // change error msg\n        throw new Error(`Verifier not supported. Check if you: \\n\n      1. Are on the right network (Torus testnet/mainnet) \\n\n      2. Have setup a verifier on dashboard.web3auth.io?`);\n      } else if (errorResult && JSON.stringify(errorResult).includes(\"Verifier + VerifierID has not yet been assigned\")) {\n        yield keyAssign({\n          endpoints,\n          torusNodePubs,\n          lastPoint: undefined,\n          firstPoint: undefined,\n          verifier,\n          verifierId,\n          signerHost: _this6.signerHost,\n          network: _this6.network\n        });\n        const assignResult = yield waitKeyLookup(endpoints, verifier, verifierId, 1000);\n        finalKeyResult = assignResult === null || assignResult === void 0 ? void 0 : assignResult.keyResult;\n        isNewKey = true;\n      } else if (keyResult) {\n        finalKeyResult = keyResult;\n      } else {\n        throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n      }\n\n      log.debug(\"> torus.js/getPublicAddress\", {\n        finalKeyResult,\n        isNewKey\n      });\n\n      if (finalKeyResult) {\n        var _nonce;\n\n        let {\n          pub_key_X: X,\n          pub_key_Y: Y\n        } = finalKeyResult.keys[0];\n        let nonceResult;\n        let nonce;\n        let modifiedPubKey;\n        let typeOfUser;\n        let pubNonce;\n\n        if (_this6.enableOneKey) {\n          try {\n            nonceResult = yield _this6.getOrSetNonce(X, Y, undefined, !isNewKey);\n            nonce = new BN(nonceResult.nonce || \"0\", 16);\n            typeOfUser = nonceResult.typeOfUser;\n          } catch {\n            throw new GetOrSetNonceError();\n          }\n\n          if (nonceResult.typeOfUser === \"v1\") {\n            modifiedPubKey = _this6.ec.keyFromPublic({\n              x: X,\n              y: Y\n            }).getPublic().add(_this6.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n          } else if (nonceResult.typeOfUser === \"v2\") {\n            if (nonceResult.upgraded) {\n              // OneKey is upgraded to 2/n, returned address is address of Torus key (postbox key), not tKey\n              modifiedPubKey = _this6.ec.keyFromPublic({\n                x: X,\n                y: Y\n              }).getPublic();\n            } else {\n              modifiedPubKey = _this6.ec.keyFromPublic({\n                x: X,\n                y: Y\n              }).getPublic().add(_this6.ec.keyFromPublic({\n                x: nonceResult.pubNonce.x,\n                y: nonceResult.pubNonce.y\n              }).getPublic());\n              pubNonce = nonceResult.pubNonce;\n            }\n          } else {\n            throw new Error(\"getOrSetNonce should always return typeOfUser.\");\n          }\n        } else {\n          typeOfUser = \"v1\";\n          nonce = yield _this6.getMetadata({\n            pub_key_X: X,\n            pub_key_Y: Y\n          });\n          modifiedPubKey = _this6.ec.keyFromPublic({\n            x: X,\n            y: Y\n          }).getPublic().add(_this6.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n        }\n\n        X = modifiedPubKey.getX().toString(16);\n        Y = modifiedPubKey.getY().toString(16);\n\n        const address = _this6.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n\n        log.debug(\"> torus.js/getPublicAddress\", {\n          X,\n          Y,\n          address,\n          typeOfUser,\n          nonce: (_nonce = nonce) === null || _nonce === void 0 ? void 0 : _nonce.toString(16),\n          pubNonce\n        });\n        if (!isExtended) return address;\n        return {\n          typeOfUser,\n          address,\n          X,\n          Y,\n          metadataNonce: nonce,\n          pubNonce\n        };\n      }\n\n      throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n    })();\n  }\n  /**\n   * Internal functions for OneKey (OpenLogin v2), only call these functions if you know what you're doing\n   */\n\n\n  getOrSetNonce(X, Y, privKey) {\n    var _arguments6 = arguments,\n        _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      let getOnly = _arguments6.length > 3 && _arguments6[3] !== undefined ? _arguments6[3] : false;\n      let data;\n      const msg = getOnly ? \"getNonce\" : \"getOrSetNonce\";\n\n      if (privKey) {\n        data = _this7.generateMetadataParams(msg, privKey);\n      } else {\n        data = {\n          pub_key_X: X,\n          pub_key_Y: Y,\n          set_data: {\n            data: msg\n          }\n        };\n      }\n\n      return post(`${_this7.metadataHost}/get_or_set_nonce`, data, undefined, {\n        useAPIKey: true\n      });\n    })();\n  }\n\n  getNonce(X, Y, privKey) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this8.getOrSetNonce(X, Y, privKey, true);\n    })();\n  }\n\n  getPostboxKeyFrom1OutOf1(privKey, nonce) {\n    const privKeyBN = new BN(privKey, 16);\n    const nonceBN = new BN(nonce, 16);\n    return privKeyBN.sub(nonceBN).umod(this.ec.curve.n).toString(\"hex\");\n  }\n\n}\n\nexport { GetOrSetNonceError, Torus as default, kCombinations, keccak256, keyAssign, keyLookup, thresholdSame, waitKeyLookup }; //# sourceMappingURL=torusUtils.esm.js.map","map":null,"metadata":{},"sourceType":"module"}