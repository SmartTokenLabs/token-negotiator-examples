{"ast":null,"code":"import * as asn1js from \"asn1js\";\nimport { AsnPropTypes, AsnTypeTypes } from \"./enums\";\nimport { isConvertible } from \"./helper\";\nexport class AsnSchemaStorage {\n  constructor() {\n    this.items = new WeakMap();\n  }\n\n  has(target) {\n    return this.items.has(target);\n  }\n\n  get(target, checkSchema = false) {\n    const schema = this.items.get(target);\n\n    if (!schema) {\n      throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);\n    }\n\n    if (checkSchema && !schema.schema) {\n      throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);\n    }\n\n    return schema;\n  }\n\n  cache(target) {\n    const schema = this.get(target);\n\n    if (!schema.schema) {\n      schema.schema = this.create(target, true);\n    }\n  }\n\n  createDefault(target) {\n    const schema = {\n      type: AsnTypeTypes.Sequence,\n      items: {}\n    };\n    const parentSchema = this.findParentSchema(target);\n\n    if (parentSchema) {\n      Object.assign(schema, parentSchema);\n      schema.items = Object.assign({}, schema.items, parentSchema.items);\n    }\n\n    return schema;\n  }\n\n  create(target, useNames) {\n    const schema = this.items.get(target) || this.createDefault(target);\n    const asn1Value = [];\n\n    for (const key in schema.items) {\n      const item = schema.items[key];\n      const name = useNames ? key : \"\";\n      let asn1Item;\n\n      if (typeof item.type === \"number\") {\n        const Asn1TypeName = AsnPropTypes[item.type];\n        const Asn1Type = asn1js[Asn1TypeName];\n\n        if (!Asn1Type) {\n          throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);\n        }\n\n        asn1Item = new Asn1Type({\n          name\n        });\n      } else if (isConvertible(item.type)) {\n        const instance = new item.type();\n        asn1Item = instance.toSchema(name);\n      } else if (item.optional) {\n        const itemSchema = this.get(item.type);\n\n        if (itemSchema.type === AsnTypeTypes.Choice) {\n          asn1Item = new asn1js.Any({\n            name\n          });\n        } else {\n          asn1Item = this.create(item.type, false);\n          asn1Item.name = name;\n        }\n      } else {\n        asn1Item = new asn1js.Any({\n          name\n        });\n      }\n\n      const optional = !!item.optional || item.defaultValue !== undefined;\n\n      if (item.repeated) {\n        asn1Item.name = \"\";\n        const Container = item.repeated === \"set\" ? asn1js.Set : asn1js.Sequence;\n        asn1Item = new Container({\n          name: \"\",\n          value: [new asn1js.Repeated({\n            name,\n            value: asn1Item\n          })]\n        });\n      }\n\n      if (item.context !== null && item.context !== undefined) {\n        if (item.implicit) {\n          if (typeof item.type === \"number\" || isConvertible(item.type)) {\n            const Container = item.repeated ? asn1js.Constructed : asn1js.Primitive;\n            asn1Value.push(new Container({\n              name,\n              optional,\n              idBlock: {\n                tagClass: 3,\n                tagNumber: item.context\n              }\n            }));\n          } else {\n            this.cache(item.type);\n            const isRepeated = !!item.repeated;\n            let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;\n            value = \"valueBlock\" in value ? value.valueBlock.value : value.value;\n            asn1Value.push(new asn1js.Constructed({\n              name: !isRepeated ? name : \"\",\n              optional,\n              idBlock: {\n                tagClass: 3,\n                tagNumber: item.context\n              },\n              value: value\n            }));\n          }\n        } else {\n          asn1Value.push(new asn1js.Constructed({\n            optional,\n            idBlock: {\n              tagClass: 3,\n              tagNumber: item.context\n            },\n            value: [asn1Item]\n          }));\n        }\n      } else {\n        asn1Item.optional = optional;\n        asn1Value.push(asn1Item);\n      }\n    }\n\n    switch (schema.type) {\n      case AsnTypeTypes.Sequence:\n        return new asn1js.Sequence({\n          value: asn1Value,\n          name: \"\"\n        });\n\n      case AsnTypeTypes.Set:\n        return new asn1js.Set({\n          value: asn1Value,\n          name: \"\"\n        });\n\n      case AsnTypeTypes.Choice:\n        return new asn1js.Choice({\n          value: asn1Value,\n          name: \"\"\n        });\n\n      default:\n        throw new Error(`Unsupported ASN1 type in use`);\n    }\n  }\n\n  set(target, schema) {\n    this.items.set(target, schema);\n    return this;\n  }\n\n  findParentSchema(target) {\n    const parent = target.__proto__;\n\n    if (parent) {\n      const schema = this.items.get(parent);\n      return schema || this.findParentSchema(parent);\n    }\n\n    return null;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}