{"ast":null,"code":"const EC = require('elliptic').ec;\n\nconst ec = new EC('secp256k1');\nconst ecparams = ec.curve; // Hack, we can not use bn.js@5, while elliptic uses bn.js@4\n// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758\n\nconst BN = ecparams.n.constructor;\n\nfunction loadCompressedPublicKey(first, xbuf) {\n  let x = new BN(xbuf); // overflow\n\n  if (x.cmp(ecparams.p) >= 0) return null;\n  x = x.toRed(ecparams.red); // compute corresponding Y\n\n  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();\n  if (first === 0x03 !== y.isOdd()) y = y.redNeg();\n  return ec.keyPair({\n    pub: {\n      x: x,\n      y: y\n    }\n  });\n}\n\nfunction loadUncompressedPublicKey(first, xbuf, ybuf) {\n  let x = new BN(xbuf);\n  let y = new BN(ybuf); // overflow\n\n  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null;\n  x = x.toRed(ecparams.red);\n  y = y.toRed(ecparams.red); // is odd flag\n\n  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null; // x*x*x + b = y*y\n\n  const x3 = x.redSqr().redIMul(x);\n  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;\n  return ec.keyPair({\n    pub: {\n      x: x,\n      y: y\n    }\n  });\n}\n\nfunction loadPublicKey(pubkey) {\n  // length should be validated in interface\n  const first = pubkey[0];\n\n  switch (first) {\n    case 0x02:\n    case 0x03:\n      if (pubkey.length !== 33) return null;\n      return loadCompressedPublicKey(first, pubkey.subarray(1, 33));\n\n    case 0x04:\n    case 0x06:\n    case 0x07:\n      if (pubkey.length !== 65) return null;\n      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));\n\n    default:\n      return null;\n  }\n}\n\nfunction savePublicKey(output, point) {\n  const pubkey = point.encode(null, output.length === 33); // Loop should be faster because we do not need create extra Uint8Array\n  // output.set(new Uint8Array(pubkey))\n\n  for (let i = 0; i < output.length; ++i) output[i] = pubkey[i];\n}\n\nmodule.exports = {\n  contextRandomize() {\n    return 0;\n  },\n\n  privateKeyVerify(seckey) {\n    const bn = new BN(seckey);\n    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;\n  },\n\n  privateKeyNegate(seckey) {\n    const bn = new BN(seckey);\n    const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32);\n    seckey.set(negate);\n    return 0;\n  },\n\n  privateKeyTweakAdd(seckey, tweak) {\n    const bn = new BN(tweak);\n    if (bn.cmp(ecparams.n) >= 0) return 1;\n    bn.iadd(new BN(seckey));\n    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);\n    if (bn.isZero()) return 1;\n    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32);\n    seckey.set(tweaked);\n    return 0;\n  },\n\n  privateKeyTweakMul(seckey, tweak) {\n    let bn = new BN(tweak);\n    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;\n    bn.imul(new BN(seckey));\n    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n);\n    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32);\n    seckey.set(tweaked);\n    return 0;\n  },\n\n  publicKeyVerify(pubkey) {\n    const pair = loadPublicKey(pubkey);\n    return pair === null ? 1 : 0;\n  },\n\n  publicKeyCreate(output, seckey) {\n    const bn = new BN(seckey);\n    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;\n    const point = ec.keyFromPrivate(seckey).getPublic();\n    savePublicKey(output, point);\n    return 0;\n  },\n\n  publicKeyConvert(output, pubkey) {\n    const pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    const point = pair.getPublic();\n    savePublicKey(output, point);\n    return 0;\n  },\n\n  publicKeyNegate(output, pubkey) {\n    const pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    const point = pair.getPublic();\n    point.y = point.y.redNeg();\n    savePublicKey(output, point);\n    return 0;\n  },\n\n  publicKeyCombine(output, pubkeys) {\n    const pairs = new Array(pubkeys.length);\n\n    for (let i = 0; i < pubkeys.length; ++i) {\n      pairs[i] = loadPublicKey(pubkeys[i]);\n      if (pairs[i] === null) return 1;\n    }\n\n    let point = pairs[0].getPublic();\n\n    for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub);\n\n    if (point.isInfinity()) return 2;\n    savePublicKey(output, point);\n    return 0;\n  },\n\n  publicKeyTweakAdd(output, pubkey, tweak) {\n    const pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    tweak = new BN(tweak);\n    if (tweak.cmp(ecparams.n) >= 0) return 2;\n    const point = pair.getPublic().add(ecparams.g.mul(tweak));\n    if (point.isInfinity()) return 2;\n    savePublicKey(output, point);\n    return 0;\n  },\n\n  publicKeyTweakMul(output, pubkey, tweak) {\n    const pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    tweak = new BN(tweak);\n    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2;\n    const point = pair.getPublic().mul(tweak);\n    savePublicKey(output, point);\n    return 0;\n  },\n\n  signatureNormalize(sig) {\n    const r = new BN(sig.subarray(0, 32));\n    const s = new BN(sig.subarray(32, 64));\n    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1;\n\n    if (s.cmp(ec.nh) === 1) {\n      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32);\n    }\n\n    return 0;\n  },\n\n  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n  // Adapted for Uint8Array instead Buffer\n  signatureExport(obj, sig) {\n    const sigR = sig.subarray(0, 32);\n    const sigS = sig.subarray(32, 64);\n    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1;\n    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1;\n    const {\n      output\n    } = obj; // Prepare R\n\n    let r = output.subarray(4, 4 + 33);\n    r[0] = 0x00;\n    r.set(sigR, 1);\n    let lenR = 33;\n    let posR = 0;\n\n    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);\n\n    r = r.subarray(posR);\n    if (r[0] & 0x80) return 1;\n    if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80)) return 1; // Prepare S\n\n    let s = output.subarray(6 + 33, 6 + 33 + 33);\n    s[0] = 0x00;\n    s.set(sigS, 1);\n    let lenS = 33;\n    let posS = 0;\n\n    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);\n\n    s = s.subarray(posS);\n    if (s[0] & 0x80) return 1;\n    if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80)) return 1; // Set output length for return\n\n    obj.outputlen = 6 + lenR + lenS; // Output in specified format\n    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n\n    output[0] = 0x30;\n    output[1] = obj.outputlen - 2;\n    output[2] = 0x02;\n    output[3] = r.length;\n    output.set(r, 4);\n    output[4 + lenR] = 0x02;\n    output[5 + lenR] = s.length;\n    output.set(s, 6 + lenR);\n    return 0;\n  },\n\n  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n  // Adapted for Uint8Array instead Buffer\n  signatureImport(output, sig) {\n    if (sig.length < 8) return 1;\n    if (sig.length > 72) return 1;\n    if (sig[0] !== 0x30) return 1;\n    if (sig[1] !== sig.length - 2) return 1;\n    if (sig[2] !== 0x02) return 1;\n    const lenR = sig[3];\n    if (lenR === 0) return 1;\n    if (5 + lenR >= sig.length) return 1;\n    if (sig[4 + lenR] !== 0x02) return 1;\n    const lenS = sig[5 + lenR];\n    if (lenS === 0) return 1;\n    if (6 + lenR + lenS !== sig.length) return 1;\n    if (sig[4] & 0x80) return 1;\n    if (lenR > 1 && sig[4] === 0x00 && !(sig[5] & 0x80)) return 1;\n    if (sig[lenR + 6] & 0x80) return 1;\n    if (lenS > 1 && sig[lenR + 6] === 0x00 && !(sig[lenR + 7] & 0x80)) return 1;\n    let sigR = sig.subarray(4, 4 + lenR);\n    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1);\n    if (sigR.length > 32) return 1;\n    let sigS = sig.subarray(6 + lenR);\n    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1);\n    if (sigS.length > 32) throw new Error('S length is too long');\n    let r = new BN(sigR);\n    if (r.cmp(ecparams.n) >= 0) r = new BN(0);\n    let s = new BN(sig.subarray(6 + lenR));\n    if (s.cmp(ecparams.n) >= 0) s = new BN(0);\n    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0);\n    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32);\n    return 0;\n  },\n\n  ecdsaSign(obj, message, seckey, data, noncefn) {\n    if (noncefn) {\n      const _noncefn = noncefn;\n\n      noncefn = counter => {\n        const nonce = _noncefn(message, seckey, null, data, counter);\n\n        const isValid = nonce instanceof Uint8Array && nonce.length === 32;\n        if (!isValid) throw new Error('This is the way');\n        return new BN(nonce);\n      };\n    }\n\n    const d = new BN(seckey);\n    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1;\n    let sig;\n\n    try {\n      sig = ec.sign(message, seckey, {\n        canonical: true,\n        k: noncefn,\n        pers: data\n      });\n    } catch (err) {\n      return 1;\n    }\n\n    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0);\n    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32);\n    obj.recid = sig.recoveryParam;\n    return 0;\n  },\n\n  ecdsaVerify(sig, msg32, pubkey) {\n    const sigObj = {\n      r: sig.subarray(0, 32),\n      s: sig.subarray(32, 64)\n    };\n    const sigr = new BN(sigObj.r);\n    const sigs = new BN(sigObj.s);\n    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;\n    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3;\n    const pair = loadPublicKey(pubkey);\n    if (pair === null) return 2;\n    const point = pair.getPublic();\n    const isValid = ec.verify(msg32, sigObj, point);\n    return isValid ? 0 : 3;\n  },\n\n  ecdsaRecover(output, sig, recid, msg32) {\n    const sigObj = {\n      r: sig.slice(0, 32),\n      s: sig.slice(32, 64)\n    };\n    const sigr = new BN(sigObj.r);\n    const sigs = new BN(sigObj.s);\n    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;\n    if (sigr.isZero() || sigs.isZero()) return 2; // Can throw `throw new Error('Unable to find sencond key candinate');`\n\n    let point;\n\n    try {\n      point = ec.recoverPubKey(msg32, sigObj, recid);\n    } catch (err) {\n      return 2;\n    }\n\n    savePublicKey(output, point);\n    return 0;\n  },\n\n  ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {\n    const pair = loadPublicKey(pubkey);\n    if (pair === null) return 1;\n    const scalar = new BN(seckey);\n    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2;\n    const point = pair.getPublic().mul(scalar);\n\n    if (hashfn === undefined) {\n      const data = point.encode(null, true);\n      const sha256 = ec.hash().update(data).digest();\n\n      for (let i = 0; i < 32; ++i) output[i] = sha256[i];\n    } else {\n      if (!xbuf) xbuf = new Uint8Array(32);\n      const x = point.getX().toArray('be', 32);\n\n      for (let i = 0; i < 32; ++i) xbuf[i] = x[i];\n\n      if (!ybuf) ybuf = new Uint8Array(32);\n      const y = point.getY().toArray('be', 32);\n\n      for (let i = 0; i < 32; ++i) ybuf[i] = y[i];\n\n      const hash = hashfn(xbuf, ybuf, data);\n      const isValid = hash instanceof Uint8Array && hash.length === output.length;\n      if (!isValid) return 2;\n      output.set(hash);\n    }\n\n    return 0;\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}