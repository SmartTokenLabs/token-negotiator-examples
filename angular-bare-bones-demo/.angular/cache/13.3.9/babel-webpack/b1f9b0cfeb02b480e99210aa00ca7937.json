{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Point = exports.CURVE_BN256 = exports.CURVES = exports.CURVE_SECP256k1 = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst config_1 = require(\"../config\"); // curve SECP256k1\n\n\nexports.CURVE_SECP256k1 = {\n  P: 2n ** 256n - 2n ** 32n - 977n,\n  n: 2n ** 256n - 432420386565659656852420866394968145599n,\n  magicExp: (2n ** 256n - 2n ** 32n - 977n + 1n) / 4n,\n  A: 0n,\n  B: 7n\n};\nexports.CURVES = {\n  // secp256r1: {\n  //     P: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  //     A: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  //     B: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  //     n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  //     GX: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  //     GY: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n  //     h: 1n\n  // },\n  // P-256, also known as secp256r1 and prime256v1\n  p256: {\n    // prime: null,\n    P: BigInt('0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF'),\n    A: BigInt('0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC'),\n    B: BigInt('0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B'),\n    n: BigInt('0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551'),\n    GX: BigInt('0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296'),\n    GY: BigInt('0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5'),\n    h: 1n\n  },\n  secp256k1: {\n    P: 2n ** 256n - 2n ** 32n - 977n,\n    A: 0n,\n    B: 7n,\n    n: 2n ** 256n - 432420386565659656852420866394968145599n,\n    GX: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,\n    GY: 32670510020758816978083085130507043184471273380659243275938904335757337482424n\n  },\n  BN256: {\n    P: 115792089237314936872688561244471742058375878355761205198700409522629664518163n,\n    n: 115792089237314936872688561244471742058035595988840268584488757999429535617037n,\n    magicExp: 115792089237314936872688561244471742058375878355761205198700409522629664518164n >> 2n,\n    A: 0n,\n    B: 3n,\n    h: 1n\n  }\n}; // Updated parameters #60\n\nexports.CURVE_BN256 = {\n  P: 21888242871839275222246405745257275088696311157297823662689037894645226208583n,\n  n: 21888242871839275222246405745257275088548364400416034343698204186575808495617n,\n  // magicExp: 115792089237314936872688561244471742058375878355761205198700409522629664518164n >> 2n,\n  A: 0n,\n  B: 3n,\n  h: 1n\n};\n\nclass Point {\n  //static ZERO = new Point(0n, 0n); // Point at infinity aka identifier point aka zero\n  // constructor(public x: bigint, public y: bigint, public useCurve: {[index: string]:bigint} = CURVE_SECP256k1 ) {}\n  constructor(x, y, useCurve = exports.CURVES.secp256r1) {\n    this.x = x;\n    this.y = y;\n    this.useCurve = useCurve;\n  } // Adds point to itself. http://hyperelliptic.org/EFD/g1p/auto-shortw.html\n\n\n  double() {\n    const X1 = this.x;\n    const Y1 = this.y;\n    const lam = (0, utils_1.mod)(3n * X1 ** 2n * (0, utils_1.invert)(2n * Y1, this.useCurve.P), this.useCurve.P);\n    const X3 = (0, utils_1.mod)(lam * lam - 2n * X1, this.useCurve.P);\n    const Y3 = (0, utils_1.mod)(lam * (X1 - X3) - Y1, this.useCurve.P);\n    return new Point(X3, Y3, this.useCurve);\n  }\n\n  newZero() {\n    return new Point(0n, 0n, this.useCurve);\n  } // Adds point to other point. http://hyperelliptic.org/EFD/g1p/auto-shortw.html\n\n\n  add(other) {\n    const [a, b] = [this, other];\n    const [X1, Y1, X2, Y2] = [a.x, a.y, b.x, b.y];\n    if (X1 === 0n || Y1 === 0n) return b;\n    if (X2 === 0n || Y2 === 0n) return a;\n    if (X1 === X2 && Y1 === Y2) return this.double();\n    if (X1 === X2 && Y1 === -Y2) return this.newZero();\n    const lam = (0, utils_1.mod)((Y2 - Y1) * (0, utils_1.invert)(X2 - X1, this.useCurve.P), this.useCurve.P);\n    const X3 = (0, utils_1.mod)(lam * lam - X1 - X2, this.useCurve.P);\n    const Y3 = (0, utils_1.mod)(lam * (X1 - X3) - Y1, this.useCurve.P);\n    return new Point(X3, Y3, this.useCurve);\n  } // Elliptic curve point multiplication with double-and-add algo.\n\n\n  multiplyDA(n) {\n    let p = this.newZero();\n    let d = this;\n\n    while (n > 0n) {\n      if (n & 1n) p = p.add(d);\n      d = d.double();\n      n >>= 1n;\n    }\n\n    return p;\n  }\n\n  isInfinity() {\n    return this.x == null || this.y == null;\n  }\n\n  getEncoded(compressed = false) {\n    if (this.isInfinity()) {\n      return new Uint8Array(0);\n    }\n\n    let X = (0, utils_1.bnToBuf)(this.x, 32);\n\n    if (compressed) {\n      return (0, utils_1.uint8merge)([Uint8Array.from([2]), X]);\n    }\n\n    return (0, utils_1.uint8merge)([Uint8Array.from([4]), X, (0, utils_1.bnToBuf)(this.y, 32)]);\n  }\n\n  equals(other) {\n    if (null == other) {\n      return false;\n    }\n\n    let i1 = this.isInfinity();\n    let i2 = other.isInfinity();\n\n    if (i1 || i2) {\n      return i1 && i2;\n    }\n\n    let p1 = this;\n    let p2 = other;\n    return p1.x === p2.x && p1.y === p2.y;\n  }\n\n  static decodeFromHex(hex, useCurve = exports.CURVE_SECP256k1) {\n    if (hex.length != 130) {\n      throw new Error('only decompressed points allowed. 65 bytes.');\n    }\n\n    return Point.decodeFromUint8((0, utils_1.hexStringToUint8)(hex), useCurve); // let p;\n    // let type = hex.slice(0,2);\n    // switch (type) {\n    //     case '04':\n    //         let X = BigInt('0x' + hex.slice(2,66));\n    //         let Y = BigInt('0x' + hex.slice(66,130));\n    //         // logger(DEBUGLEVEL.HIGH, X,Y);\n    //         p = new Point(X, Y, useCurve);\n    //         break;\n    //     default:\n    //         throw new Error('only decompressed points allowed');\n    // }\n    // if (!p.validate()) {\n    //     let m = `Point is not valid (${p.x},${p.y})`;\n    //     logger(DEBUGLEVEL.HIGH, m);\n    //     logger(DEBUGLEVEL.HIGH, p);\n    //     throw new Error(m);\n    // }\n    // return p;\n  }\n\n  static decodeFromUint8(uint, useCurve = exports.CURVE_SECP256k1) {\n    if (uint.length != 65) {\n      throw new Error('only decompressed points allowed. 65 bytes.');\n    }\n\n    let p;\n    let type = uint[0];\n\n    switch (type) {\n      case 4:\n        let X = (0, utils_1.uint8ToBn)(uint.slice(1, 33));\n        let Y = (0, utils_1.uint8ToBn)(uint.slice(33));\n        p = new Point(X, Y, useCurve);\n        break;\n\n      default:\n        throw new Error('only decompressed points allowed');\n    }\n\n    if (!p.validate()) {\n      let m = `Point is not valid (` + p.x.toString(16) + ',' + p.y.toString(16) + `)`;\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, m);\n      throw new Error(m);\n    }\n\n    return p;\n  }\n\n  validate() {\n    let res = (0, utils_1.mod)((0, utils_1.mod)(this.y * this.y, this.useCurve.P) - (0, utils_1.mod)((0, utils_1.BnPowMod)(this.x, 3n, this.useCurve.P) + (0, utils_1.mod)(this.x * this.useCurve.A, this.useCurve.P) + this.useCurve.B, this.useCurve.P), this.useCurve.P);\n    return res == 0n;\n  }\n\n  negate() {\n    return new Point(this.x, this.useCurve.P - this.y, this.useCurve);\n  }\n\n  subtract(anotherPoint) {\n    return this.add(anotherPoint.negate());\n  }\n\n}\n\nexports.Point = Point; //# sourceMappingURL=Point.js.map","map":null,"metadata":{},"sourceType":"script"}