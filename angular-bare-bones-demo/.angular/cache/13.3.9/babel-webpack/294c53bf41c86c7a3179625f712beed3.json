{"ast":null,"code":"import * as asn1js from \"asn1js\";\nimport { AsnPropTypes, AsnTypeTypes } from \"./enums\";\nimport * as converters from \"./converters\";\nimport { AsnSchemaValidationError } from \"./errors\";\nimport { isConvertible, isTypeOfArray } from \"./helper\";\nimport { schemaStorage } from \"./storage\";\nexport class AsnParser {\n  static parse(data, target) {\n    const asn1Parsed = asn1js.fromBER(data);\n\n    if (asn1Parsed.result.error) {\n      throw new Error(asn1Parsed.result.error);\n    }\n\n    const res = this.fromASN(asn1Parsed.result, target);\n    return res;\n  }\n\n  static fromASN(asn1Schema, target) {\n    var _a;\n\n    try {\n      if (isConvertible(target)) {\n        const value = new target();\n        return value.fromASN(asn1Schema);\n      }\n\n      const schema = schemaStorage.get(target);\n      schemaStorage.cache(target);\n      let targetSchema = schema.schema;\n\n      if (asn1Schema.constructor === asn1js.Constructed && schema.type !== AsnTypeTypes.Choice) {\n        targetSchema = new asn1js.Constructed({\n          idBlock: {\n            tagClass: 3,\n            tagNumber: asn1Schema.idBlock.tagNumber\n          },\n          value: schema.schema.valueBlock.value\n        });\n\n        for (const key in schema.items) {\n          delete asn1Schema[key];\n        }\n      }\n\n      const asn1ComparedSchema = asn1js.compareSchema({}, asn1Schema, targetSchema);\n\n      if (!asn1ComparedSchema.verified) {\n        throw new AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);\n      }\n\n      const res = new target();\n\n      if (isTypeOfArray(target)) {\n        if (!(\"value\" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {\n          throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);\n        }\n\n        const itemType = schema.itemType;\n\n        if (typeof itemType === \"number\") {\n          const converter = converters.defaultConverter(itemType);\n\n          if (!converter) {\n            throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n          }\n\n          return target.from(asn1Schema.valueBlock.value, element => converter.fromASN(element));\n        } else {\n          return target.from(asn1Schema.valueBlock.value, element => this.fromASN(element, itemType));\n        }\n      }\n\n      for (const key in schema.items) {\n        const asn1SchemaValue = asn1ComparedSchema.result[key];\n\n        if (!asn1SchemaValue) {\n          continue;\n        }\n\n        const schemaItem = schema.items[key];\n        const schemaItemType = schemaItem.type;\n\n        if (typeof schemaItemType === \"number\" || isConvertible(schemaItemType)) {\n          const converter = (_a = schemaItem.converter) !== null && _a !== void 0 ? _a : isConvertible(schemaItemType) ? new schemaItemType() : null;\n\n          if (!converter) {\n            throw new Error(\"Converter is empty\");\n          }\n\n          if (schemaItem.repeated) {\n            if (schemaItem.implicit) {\n              const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n              const newItem = new Container();\n              newItem.valueBlock = asn1SchemaValue.valueBlock;\n              const newItemAsn = asn1js.fromBER(newItem.toBER(false));\n\n              if (newItemAsn.offset === -1) {\n                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);\n              }\n\n              if (!(\"value\" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {\n                throw new Error(\"Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.\");\n              }\n\n              const value = newItemAsn.result.valueBlock.value;\n              res[key] = Array.from(value, element => converter.fromASN(element));\n            } else {\n              res[key] = Array.from(asn1SchemaValue, element => converter.fromASN(element));\n            }\n          } else {\n            let value = asn1SchemaValue;\n\n            if (schemaItem.implicit) {\n              let newItem;\n\n              if (isConvertible(schemaItemType)) {\n                newItem = new schemaItemType().toSchema(\"\");\n              } else {\n                const Asn1TypeName = AsnPropTypes[schemaItemType];\n                const Asn1Type = asn1js[Asn1TypeName];\n\n                if (!Asn1Type) {\n                  throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);\n                }\n\n                newItem = new Asn1Type();\n              }\n\n              newItem.valueBlock = value.valueBlock;\n              value = asn1js.fromBER(newItem.toBER(false)).result;\n            }\n\n            res[key] = converter.fromASN(value);\n          }\n        } else {\n          if (schemaItem.repeated) {\n            if (!Array.isArray(asn1SchemaValue)) {\n              throw new Error(\"Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.\");\n            }\n\n            res[key] = Array.from(asn1SchemaValue, element => this.fromASN(element, schemaItemType));\n          } else {\n            res[key] = this.fromASN(asn1SchemaValue, schemaItemType);\n          }\n        }\n      }\n\n      return res;\n    } catch (error) {\n      if (error instanceof AsnSchemaValidationError) {\n        error.schemas.push(target.name);\n      }\n\n      throw error;\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}