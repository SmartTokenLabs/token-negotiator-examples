{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AttestedObject = void 0;\n\nconst AttestationCrypto_1 = require(\"./AttestationCrypto\");\n\nconst SignedIdentifierAttestation_1 = require(\"./SignedIdentifierAttestation\");\n\nconst utils_1 = require(\"./utils\");\n\nconst DerUtility_1 = require(\"./DerUtility\");\n\nconst asn1_schema_1 = require(\"@peculiar/asn1-schema\");\n\nconst UsageProofOfExponent_1 = require(\"./UsageProofOfExponent\");\n\nconst IdentifierAttestation_1 = require(\"./IdentifierAttestation\");\n\nconst config_1 = require(\"../config\");\n\nclass AttestedObject {\n  constructor() {}\n\n  create(attestableObject, att, attestationSecret, objectSecret) {\n    this.attestableObject = attestableObject;\n    this.att = att;\n    this.attestationSecret = attestationSecret;\n    this.objectSecret = objectSecret;\n    this.crypto = new AttestationCrypto_1.AttestationCrypto();\n    this.pok = this.makeProof(attestationSecret, objectSecret, this.crypto);\n    this.derEncodedProof = this.pok.getDerEncoding();\n    this.fillPresignData();\n  }\n\n  setWebDomain(domain) {\n    this.webDomain = domain;\n  }\n\n  fillPresignData() {\n    this.preSignEncoded = this.attestableObject.getDerEncoding() + this.att.getDerEncoding() + this.pok.getDerEncoding();\n    this.encoding = DerUtility_1.Asn1Der.encode('SEQUENCE_30', this.preSignEncoded);\n  }\n\n  fromDecodedData(attestableObject, att, pok) {\n    this.attestableObject = attestableObject;\n    this.att = att;\n    this.pok = pok;\n    this.fillPresignData();\n    this.userKeyPair = this.att.getUnsignedAttestation().getSubjectPublicKeyInfo();\n    this.constructorCheck();\n  } // async sign(){\n  //     let userData = {\n  //         payload: this.encoding,\n  //         description: AttestedObject.Eip712UserDataDescription,\n  //         timestamp: new Date().getTime()\n  //     };\n  //\n  //     return await SignatureUtility.signEIP712WithBrowserWallet(this.webDomain, userData, AttestedObject.Eip712UserDataTypes, AttestedObject.Eip712UserDataPrimaryName );\n  // }\n\n\n  verify() {\n    if (!this.attestableObject.verify()) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Could not verify attestable object\");\n      return false;\n    }\n\n    if (!this.att.verify()) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Could not verify attestation\");\n      return false;\n    }\n\n    if (!this.crypto.verifyEqualityProof(this.att.getUnsignedAttestation().getCommitment(), this.attestableObject.getCommitment(), this.pok)) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Could not verify the consistency between the commitment in the attestation and the attested object\");\n      return false;\n    }\n\n    return true;\n  }\n\n  static fromBytes(asn1, decoder, attestorKey, attestable, issuerKeys) {\n    let attested = asn1_schema_1.AsnParser.parse(asn1, decoder);\n    let me = new this();\n    me.attestableObject = new attestable();\n    me.attestableObject.fromBytes(attested.signedToken, issuerKeys);\n    me.att = SignedIdentifierAttestation_1.SignedIdentifierAttestation.fromBytes(new Uint8Array(attested.attestation), attestorKey);\n    let pok = new UsageProofOfExponent_1.UsageProofOfExponent();\n    pok.fromBytes(new Uint8Array(attested.proof));\n    me.pok = pok;\n    me.userKeyPair = me.att.getUnsignedAttestation().getSubjectPublicKeyInfo(); // TODO: Use getter to instantiate AttestationCrypto when required\n\n    me.crypto = new AttestationCrypto_1.AttestationCrypto();\n    me.constructorCheck();\n    return me;\n  }\n\n  makeProof(attestationSecret, objectSecret, crypto) {\n    // TODO Bob should actually verify the attestable object is valid before trying to cash it to avoid wasting gas\n    // Need to decode twice since the standard ASN1 encodes the octet string in an octet string\n    // TODO we dont parse that value, because its already parsed to this.riddle\n    // let extensions = this.att.getUnsignedAttestation().getExtensions();//.getObjectAt(0));\n    // Index in the second DER sequence is 2 since the third object in an extension is the actual value\n    // TODO we dont parse that value, because its already parsed to this.riddle\n    // let attCom: Uint8Array = new Uint8Array(extensions.extension.extnValue);\n    let attCom = this.att.getUnsignedAttestation().getCommitment();\n    let objCom = this.attestableObject.getCommitment();\n    let pok = crypto.computeEqualityProof((0, utils_1.uint8tohex)(attCom), (0, utils_1.uint8tohex)(objCom), attestationSecret, objectSecret);\n\n    if (!crypto.verifyEqualityProof(attCom, objCom, pok)) {\n      throw new Error(\"The redeem proof did not verify\");\n    }\n\n    return pok;\n  }\n\n  getAttestableObject() {\n    return this.attestableObject;\n  }\n\n  getAtt() {\n    return this.att;\n  }\n\n  getDerEncodeProof() {\n    return this.derEncodedProof;\n  }\n\n  getDerEncoding() {\n    return this.encoding;\n  }\n\n  constructorCheck() {\n    if (!this.verify()) {\n      throw new Error(\"The redeem request is not valid\");\n    }\n  }\n\n  checkValidity(ethAddress = null) {\n    // CHECK: that it is an identifier attestation otherwise not all the checks of validity needed gets carried out\n    try {\n      let attEncoded = this.att.getUnsignedAttestation().getDerEncoding();\n      let std = IdentifierAttestation_1.IdentifierAttestation.fromBytes(new Uint8Array((0, utils_1.hexStringToArray)(attEncoded))); // CHECK: perform the needed checks of an identifier attestation\n\n      if (!std.checkValidity()) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"The attestation is not a valid standard attestation\");\n        return false;\n      }\n    } catch (e) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"The attestation is invalid\");\n      return false;\n    }\n\n    try {\n      // CHECK: that the cheque is still valid\n      if (!this.getAttestableObject().checkValidity()) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Cheque is not valid\");\n        return false;\n      }\n    } catch (e) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Cheque validation failed\");\n      return false;\n    }\n\n    try {\n      // CHECK: the Ethereum address on the attestation matches receivers signing key\n      // let attestationEthereumAddress: string = this.getAtt().getUnsignedAttestation().getSubject().substring(3);\n      let attestationEthereumAddress = this.getAtt().getUnsignedAttestation().getAddress();\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, 'attestationEthereumAddress: ' + attestationEthereumAddress);\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, 'providedEthereumAddress: ' + ethAddress);\n\n      if (attestationEthereumAddress.toLowerCase() !== ethAddress.toLowerCase()) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"The attestation is not to the same Ethereum user who is sending this request\");\n        return false;\n      }\n    } catch (e) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Address validation failed\");\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.MEDIUM, e);\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nexports.AttestedObject = AttestedObject;\nAttestedObject.Eip712UserData = {\n  payload: '',\n  description: '',\n  timestamp: 0\n}; // static Eip712UserDataTypes: {[index: string]:string}[]  = [\n\nAttestedObject.Eip712UserDataTypes = [{\n  name: 'payload',\n  type: 'string'\n}, {\n  name: 'description',\n  type: 'string'\n}, {\n  name: 'timestamp',\n  type: 'uint256'\n}];\nAttestedObject.Eip712UserDataPrimaryName = \"Authentication\";\nAttestedObject.Eip712UserDataDescription = \"Single-use authentication\"; //# sourceMappingURL=AttestedObject.js.map","map":null,"metadata":{},"sourceType":"script"}