{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IdentifierAttestation = void 0;\n\nconst AttestationCrypto_1 = require(\"./AttestationCrypto\");\n\nconst Attestation_1 = require(\"./Attestation\");\n\nconst utils_1 = require(\"./utils\");\n\nconst config_1 = require(\"../config\");\n\nconst DerUtility_1 = require(\"./DerUtility\");\n\nclass IdentifierAttestation extends Attestation_1.Attestation {\n  constructor() {\n    super();\n  }\n\n  fromCommitment(commitment, keys) {\n    this.subjectKey = keys;\n    this.setVersion(IdentifierAttestation.HIDDEN_IDENTIFIER_VERSION);\n    this.setSubject(\"CN=\");\n    this.setSigningAlgorithm(IdentifierAttestation.DEFAULT_SIGNING_ALGORITHM);\n    this.setSubjectPublicKeyInfo(keys);\n    this.setCommitment(commitment);\n    this.type = IdentifierAttestation.HIDDEN_TYPE;\n    this.identifier = IdentifierAttestation.HIDDEN_IDENTIFIER;\n    this.setUnlimitedValidity();\n  }\n\n  setUnlimitedValidity() {\n    super.setNotValidBefore(Date.now()); // This is used to indicate unlimited validity, see https://tools.ietf.org/html/rfc5280#section-4.1.2.5\n\n    super.setNotValidAfter(Date.parse('31 Dec 9999 23:59:59'));\n  }\n\n  static fromData(identifier, type, keys, secret) {\n    let crypto = new AttestationCrypto_1.AttestationCrypto();\n    let commitment = crypto.makeCommitment(identifier, type, secret);\n    let me = new this();\n    me.fromCommitment(commitment, keys);\n    me.type = type.toString();\n    me.identifier = identifier;\n    return me;\n  }\n\n  static fromLabelAndUrl(label, URL, keys) {\n    let me = new this();\n    me.subjectKey = keys;\n    me.setVersion(IdentifierAttestation.NFT_VERSION);\n    me.setSubject(me.makeLabeledURI(label, URL));\n    me.setSigningAlgorithm(IdentifierAttestation.DEFAULT_SIGNING_ALGORITHM);\n    me.setIssuer(\"CN=attestation.id\");\n    me.setSerialNumber(1);\n    me.setSubjectPublicKeyInfo(keys);\n    me.setUnlimitedValidity();\n    me.type = label;\n    me.identifier = URL;\n    return me;\n  }\n  /**\n   * @param label the label of the URL, similar to what is inside <a>...</a>\n   * @param URL the URL itself, similar to what is in <a href=\"...\">, note that\n   * it should already be URLencoded therefore not containing space\n   */\n\n\n  makeLabeledURI(label, URL) {\n    // DERUTF8String labeledURLValue = new DERUTF8String(URL + \" \" + label);\n    // RDN rdn = new RDN(LABELED_URI, labeledURLValue);\n    // return new X500Name(new RDN[] {rdn});\n    // https://docs.microsoft.com/ru-ru/windows/win32/seccertenroll/about-introduction-to-asn-1-syntax-and-encoding\n    // let type = Asn1Der.encode(\"OBJECT_ID\", IdentifierAttestation.LABELED_URI);\n    // let value = Asn1Der.encode(\"UTF8STRING\", URL + \" \" + label);\n    //\n    // let rdn = Asn1Der.encode(\"SEQUENCE_30\", type + value);\n    // let set = Asn1Der.encode(\"SET\", rdn);\n    //\n    // return Asn1Der.encode(\"SEQUENCE_30\", set);\n    return `${IdentifierAttestation.LABELED_URI_LABEL}=\"${URL} ${label}\"`;\n  }\n\n  static fromBytes(bytes) {\n    let me = new this();\n    me.fromBytes(bytes);\n\n    if (!me.checkValidity()) {\n      throw new Error(\"Could not validate object\");\n    }\n\n    if (me.getVersion() == IdentifierAttestation.NFT_VERSION) {\n      let x500Arr = DerUtility_1.Asn1Der.parseX500Names(me.getSubject());\n      let found = false;\n      x500Arr.forEach(item => {\n        if (found) return;\n\n        if (item.type == IdentifierAttestation.LABELED_URI_LABEL) {\n          found = true;\n          let typeAndIdentifier = item.value.split(' ');\n\n          if (typeAndIdentifier.length != 2) {\n            throw new Error(\"LabeledURI values should be separated with space and 2 items only: \" + item.value);\n          }\n\n          me.type = typeAndIdentifier[0];\n          me.identifier = typeAndIdentifier[1];\n        }\n      });\n\n      if (!found) {\n        throw new Error(\"Cant find LABELED_URI\");\n      }\n    } else {\n      me.type = IdentifierAttestation.HIDDEN_TYPE;\n      me.identifier = IdentifierAttestation.HIDDEN_IDENTIFIER;\n    }\n\n    return me;\n  }\n\n  setSubjectPublicKeyInfo(keys) {\n    this.subjectKey = keys;\n  }\n\n  setCommitment(encodedRiddle) {\n    this.commitment = encodedRiddle;\n  }\n\n  checkValidity() {\n    if (!super.checkValidity()) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"IdentifierAttestation super.checkValidity() filed;\");\n      return false;\n    }\n\n    if (this.getVersion() != IdentifierAttestation.HIDDEN_IDENTIFIER_VERSION && this.getVersion() != IdentifierAttestation.NFT_VERSION) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"The version number is \" + this.getVersion() + \", it must be either \" + IdentifierAttestation.HIDDEN_IDENTIFIER_VERSION + \" or \" + IdentifierAttestation.NFT_VERSION);\n      return false;\n    }\n\n    if (this.getSigningAlgorithm() !== IdentifierAttestation.DEFAULT_SIGNING_ALGORITHM) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"The subject is supposed to only be an Ethereum address as the Common Name\");\n      return false;\n    }\n\n    if (this.getVersion() == IdentifierAttestation.NFT_VERSION) {\n      if (!this.subject.includes(IdentifierAttestation.LABELED_URI_LABEL + \"=\")) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"A NFT Identifier attestation must have a labeled uri as subject. subject = \" + this.getSubject());\n        return false;\n      }\n    }\n\n    if (this.getVersion() == IdentifierAttestation.HIDDEN_IDENTIFIER_VERSION) {\n      // Ensure that there is a commitment as part of the attestation\n      if (this.getCommitment().length < AttestationCrypto_1.AttestationCrypto.BYTES_IN_DIGEST) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"The attestation does not contain a valid commitment\");\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  setIssuer(issuer) {\n    this.issuer = issuer;\n  }\n\n  getSerialNumber() {\n    return this.serialNumber;\n  }\n\n  setSerialNumber(serialNumber) {\n    this.serialNumber = serialNumber;\n  }\n\n  getAddress() {\n    // Remove the \"CN=\" prefix\n    return this.subjectKey.getAddress();\n  }\n\n}\n\nexports.IdentifierAttestation = IdentifierAttestation;\nIdentifierAttestation.OID_OCTETSTRING = \"1.3.6.1.4.1.1466.115.121.1.40\"; // ECDSA with recommended (for use with keccak signing since there is no explicit standard OID for this)\n\nIdentifierAttestation.DEFAULT_SIGNING_ALGORITHM = \"1.2.840.10045.4.2\";\nIdentifierAttestation.HIDDEN_IDENTIFIER_VERSION = 18;\nIdentifierAttestation.NFT_VERSION = 19;\nIdentifierAttestation.HIDDEN_TYPE = \"HiddenType\";\nIdentifierAttestation.HIDDEN_IDENTIFIER = \"HiddenIdentifier\"; // SEE RFC 2079\n\nIdentifierAttestation.LABELED_URI = \"1.3.6.1.4.1.250.1.57\";\nIdentifierAttestation.LABELED_URI_LABEL = \"labeledURI\"; //# sourceMappingURL=IdentifierAttestation.js.map","map":null,"metadata":{},"sourceType":"script"}