{"ast":null,"code":"import * as asn1js from \"asn1js\";\nimport { BufferSourceConverter } from \"pvtsutils\";\nexport class BitString {\n  constructor(params, unusedBits = 0) {\n    this.unusedBits = 0;\n    this.value = new ArrayBuffer(0);\n\n    if (params) {\n      if (typeof params === \"number\") {\n        this.fromNumber(params);\n      } else if (BufferSourceConverter.isBufferSource(params)) {\n        this.unusedBits = unusedBits;\n        this.value = BufferSourceConverter.toArrayBuffer(params);\n      } else {\n        throw TypeError(\"Unsupported type of 'params' argument for BitString\");\n      }\n    }\n  }\n\n  fromASN(asn) {\n    if (!(asn instanceof asn1js.BitString)) {\n      throw new TypeError(\"Argument 'asn' is not instance of ASN.1 BitString\");\n    }\n\n    this.unusedBits = asn.valueBlock.unusedBits;\n    this.value = asn.valueBlock.valueHex;\n    return this;\n  }\n\n  toASN() {\n    return new asn1js.BitString({\n      unusedBits: this.unusedBits,\n      valueHex: this.value\n    });\n  }\n\n  toSchema(name) {\n    return new asn1js.BitString({\n      name\n    });\n  }\n\n  toNumber() {\n    let res = \"\";\n    const uintArray = new Uint8Array(this.value);\n\n    for (const octet of uintArray) {\n      res += octet.toString(2).padStart(8, \"0\");\n    }\n\n    res = res.split(\"\").reverse().join(\"\");\n\n    if (this.unusedBits) {\n      res = res.slice(this.unusedBits).padStart(this.unusedBits, \"0\");\n    }\n\n    return parseInt(res, 2);\n  }\n\n  fromNumber(value) {\n    let bits = value.toString(2);\n    const octetSize = bits.length + 7 >> 3;\n    this.unusedBits = (octetSize << 3) - bits.length;\n    const octets = new Uint8Array(octetSize);\n    bits = bits.padStart(octetSize << 3, \"0\").split(\"\").reverse().join(\"\");\n    let index = 0;\n\n    while (index < octetSize) {\n      octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);\n      index++;\n    }\n\n    this.value = octets.buffer;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}