{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SignatureUtility = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst ethers_1 = require(\"ethers\");\n\nconst utils_2 = require(\"ethers/lib/utils\");\n\nconst config_1 = require(\"../config\");\n\nlet EC = require(\"elliptic\");\n\nlet ec = new EC.ec('secp256k1');\n\nlet sha3 = require(\"js-sha3\");\n\nclass SignatureUtility {\n  static sign(str, keys) {\n    let ecKey = ec.keyFromPrivate(keys.getPrivateAsHexString(), 'hex');\n    let encodingHash = sha3.keccak256((0, utils_1.hexStringToArray)(str));\n    let signature = ecKey.sign(encodingHash);\n    return signature.toDER('hex');\n  }\n\n  static verify(str, signature, keys) {\n    return SignatureUtility.verifyArrayBuf((0, utils_1.hexStringToArray)(str), signature, keys);\n  }\n\n  static verifyArrayBuf(arr, signature, keys) {\n    let ecKey = ec.keyFromPublic(keys.getPublicKeyAsHexStr(), 'hex');\n    let encodingHash = sha3.keccak256(arr);\n    return ecKey.verify(encodingHash, signature);\n  }\n\n  static signMessageWithBrowserWallet(message) {\n    return _asyncToGenerator(function* () {\n      yield SignatureUtility.connectMetamaskAndGetAddress();\n      let provider = new ethers_1.ethers.providers.Web3Provider(window.ethereum);\n      let signer = provider.getSigner();\n      return yield signer.signMessage(message);\n    })();\n  }\n\n  static recoverPublicKeyFromMessageSignature(message, signature) {\n    return _asyncToGenerator(function* () {\n      const msgHash = ethers_1.ethers.utils.hashMessage(message);\n      const digest = ethers_1.ethers.utils.arrayify(msgHash);\n      return yield ethers_1.ethers.utils.recoverPublicKey(digest, signature);\n    })();\n  }\n  /*\n  recover public key in format 0x042f196ec33ad04c6... 132chars\n   */\n\n\n  static recoverPublicKeyFromTypedMessageSignature(messageObj, signature) {\n    let messageAsPrefixedHexString, pubKey;\n\n    try {\n      let rawPayload = messageObj.message.payload; // messageObj.message.payload = sha3.keccak256(rawPayload);\n      // same result:\n\n      messageObj.message.payload = ethers_1.ethers.utils.id(rawPayload).substr(2);\n      let types = messageObj.types;\n      delete types.EIP712Domain;\n      messageAsPrefixedHexString = utils_2._TypedDataEncoder.hash(messageObj.domain, types, messageObj.message);\n      messageObj.message.payload = rawPayload;\n    } catch (e) {\n      const m = 'Cant sign data, possibly wrong format. ' + e;\n      throw new Error(m);\n    }\n\n    try {\n      pubKey = (0, utils_2.recoverPublicKey)((0, utils_1.hexStringToUint8)(messageAsPrefixedHexString.substr(2)), signature);\n    } catch (e) {\n      const m = 'Cant recoverPublicKey. ' + e;\n      throw new Error(m);\n    }\n\n    return pubKey;\n  }\n\n  static signEIP712WithBrowserWallet(webDomain, userDataValues, userDataTypes, primaryName, userKey = null) {\n    return _asyncToGenerator(function* () {\n      // How its encoded at metamask ...\n      // All properties on a domain are optional\n      // const domain = {\n      //     name: 'Devcon Ticket',\n      //     version: '1',\n      //     chainId: 3,\n      //     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n      //     salt: \"0x64656667646667657267657274796a74796a6231000000000000000000000000\" // 32-byte value\n      // };\n      // const data = JSON.stringify({\n      //     types: {\n      //         EIP712Domain: domain,\n      //         Bid: bid,\n      //         Identifier: identifier,\n      //     },\n      //     domain: domainData,\n      //     primaryType: \"Bid\",\n      //     message: message\n      // });\n      // web3.currentProvider.sendAsync(\n      // {\n      //     method: \"eth_signTypedData_v3\",\n      //     params: [signer, data],\n      //     from: signer\n      // },\n      try {\n        let userAddress;\n        let signer;\n\n        if (userKey) {\n          // it should be node.js lets use defined KeyPair\n          signer = new ethers_1.ethers.Wallet('0x' + userKey.getPrivateAsHexString());\n        } else {\n          // it should be browser. use Metamask\n          //userAddress = await SignatureUtility.connectMetamaskAndGetAddress();\n          let provider = new ethers_1.ethers.providers.Web3Provider(window.ethereum); //let network = await provider.getNetwork();\n\n          signer = provider.getSigner();\n        }\n\n        if (!signer) throw new Error(\"Active Wallet required\"); // let ethAddress = await signer.getAddress();\n\n        let Eip712Data = SignatureUtility.Eip712Data; // All properties on a domain are optional\n\n        const domainData = {\n          // chainId: network.chainId,\n          name: webDomain,\n          // verifyingContract: userAddress,\n          // salt: AttestationCrypto.generateRandomHexString(32), // 32-byte value\n          version: Eip712Data['PROTOCOL_VERSION']\n        }; // The named list of all type definitions\n\n        const dataTypes = {};\n        dataTypes[primaryName] = userDataTypes; // hash payload string->hexString to make smaller message to sign\n\n        let userDataValuesWithHashedPayload = Object.assign({}, userDataValues);\n        userDataValuesWithHashedPayload.payload = sha3.keccak256(userDataValuesWithHashedPayload.payload); // this is internal logic, we can use it for debug\n        // logger(DEBUGLEVEL.HIGH, 'lets try to sign data directly');\n        // const populated = await _TypedDataEncoder.resolveNames(domainData, dataTypes, userDataValues, (name: string) => {\n        //     return window.ethereum.resolveName(name);\n        // });\n        // logger(DEBUGLEVEL.HIGH, '!!!!!!!!!!!!!!!!!!!!!!!!!!!');\n        // logger(DEBUGLEVEL.HIGH, domainData, dataTypes, userDataValues, populated);\n        //\n        // let typedMsg = _TypedDataEncoder.getPayload(populated.domain, dataTypes, populated.value);\n        // let msgParams = JSON.stringify(typedMsg);\n        // logger(DEBUGLEVEL.HIGH, 'msgParams');\n        // logger(DEBUGLEVEL.HIGH, msgParams);\n        // let directlySigned = await window.ethereum.send(\"eth_signTypedData_v4\", [\n        //      userAddresses[0].toLowerCase(), msgParams\n        // ]);\n        // let signatureD = directlySigned.result;\n        // sign eip712 with custom key\n        // let privateKey = \"0x0123456789012345678901234567890123456789012345678901234567890123\";\n        // let wallet = new ethers.Wallet(privateKey);\n        // let signature = await wallet._signTypedData(domainData, dataTypes, userDataValuesWithHashedPayload);\n        // Connect a wallet to mainnet\n        // let provider = ethers.getDefaultProvider();\n        // let walletWithProvider = new ethers.Wallet(privateKey, provider);\n\n        let signature = yield signer._signTypedData(domainData, dataTypes, userDataValuesWithHashedPayload);\n        let completeData = {\n          types: {\n            EIP712Domain: SignatureUtility.Eip712domainTypes\n          },\n          primaryType: primaryName,\n          message: userDataValues,\n          domain: domainData\n        };\n        completeData.types[primaryName] = dataTypes[primaryName];\n        let dataStringified = JSON.stringify(completeData);\n        let externalAuthenticationData = {\n          signatureInHex: signature,\n          // jsonRpc: Eip712Data['JSON_RPC_VER'],\n          // chainId: network.chainId,\n          jsonSigned: dataStringified\n        };\n        return JSON.stringify(externalAuthenticationData);\n      } catch (e) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'Cant sign eip712 data. Error: ' + e);\n        return '';\n      }\n    })();\n  }\n\n  static connectMetamaskAndGetAddress() {\n    return _asyncToGenerator(function* () {\n      if (!window.ethereum) {\n        throw new Error('Please install metamask before.');\n      } // const userAddresses = await window.ethereum.request({ method: 'eth_accounts' });\n\n\n      const userAddresses = yield window.ethereum.request({\n        method: 'eth_requestAccounts'\n      });\n\n      if (!userAddresses || !userAddresses.length) {\n        throw new Error(\"Active Wallet required\");\n      }\n\n      return userAddresses[0];\n    })();\n  }\n\n  static getChainIdFromSignature(signature) {\n    let recoveryByte = Number(\"0x\" + signature.substr(-2));\n\n    if (recoveryByte == 27 || recoveryByte == 28) {\n      return 0;\n    } // recovery byte is chainId * 2 + 35 for chainId >= 1\n\n\n    return recoveryByte - 35 >> 1;\n  }\n\n  static convertToPersonalEthMessage(message) {\n    return (0, utils_1.stringToArray)(this.ethereumPrefix + message.length + message);\n  }\n\n}\n\nexports.SignatureUtility = SignatureUtility;\nSignatureUtility.ethereumPrefix = \"\\u0019Ethereum Signed Message:\\n\";\nSignatureUtility.OID_ECDSA_PUBLICKEY = \"1.2.840.10045.2.1\"; // static Eip712Types: {[index: string]:string}  = {\n//     STRING: \"string\",\n//     BYTES32: \"bytes32\",\n//     UINT64: \"uint64\",\n//     UINT256: \"uint256\",\n//     ADDRESS: \"address\",\n// }\n\nSignatureUtility.Eip712Data = {\n  PROTOCOL_VERSION: \"0.1\"\n};\nSignatureUtility.Eip712domainTypes = [{\n  name: \"name\",\n  type: \"string\"\n}, {\n  name: \"version\",\n  type: \"string\"\n} // {name: \"chainId\", type: \"uint256\"},\n// {name: \"verifyingContract\", type: \"address\"},\n// {name: \"salt\", type: \"bytes32\"},\n]; //# sourceMappingURL=SignatureUtility.js.map","map":null,"metadata":{},"sourceType":"script"}