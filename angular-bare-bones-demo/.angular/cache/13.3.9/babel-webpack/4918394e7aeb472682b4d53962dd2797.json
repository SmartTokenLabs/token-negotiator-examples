{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Authenticator = void 0;\n\nconst Ticket_1 = require(\"./Ticket\");\n\nconst KeyPair_1 = require(\"./libs/KeyPair\");\n\nconst utils_1 = require(\"./libs/utils\");\n\nconst SignedIdentifierAttestation_1 = require(\"./libs/SignedIdentifierAttestation\");\n\nconst AttestedObject_1 = require(\"./libs/AttestedObject\");\n\nconst AttestationCrypto_1 = require(\"./libs/AttestationCrypto\");\n\nconst AttestationRequest_1 = require(\"./libs/AttestationRequest\");\n\nconst Nonce_1 = require(\"./libs/Nonce\");\n\nconst Eip712AttestationRequest_1 = require(\"./libs/Eip712AttestationRequest\");\n\nconst IdentifierAttestation_1 = require(\"./libs/IdentifierAttestation\");\n\nconst SignatureUtility_1 = require(\"./libs/SignatureUtility\");\n\nconst UseAttestation_1 = require(\"./libs/UseAttestation\");\n\nconst Eip712AttestationUsage_1 = require(\"./libs/Eip712AttestationUsage\");\n\nconst Eip712AttestationRequestWithUsage_1 = require(\"./libs/Eip712AttestationRequestWithUsage\");\n\nconst AttestationRequestWithUsage_1 = require(\"./libs/AttestationRequestWithUsage\");\n\nconst config_1 = require(\"./config\");\n\nconst UseToken_1 = require(\"./asn1/shemas/UseToken\");\n\nlet subtle;\n\nif (typeof crypto === \"object\" && crypto.subtle) {\n  subtle = crypto.subtle;\n} else {\n  subtle = require('crypto').webcrypto.subtle;\n}\n\nconst ALPHA_CONFIG = {\n  indexedDBname: \"AlphaDB\",\n  indexedDBobject: \"AlphaKeyStore\",\n  indexedDBid: \"TK\",\n  keysAlgorithm: {\n    name: \"ECDSA\",\n    // namedCurve: \"P-384\"\n    namedCurve: \"P-256\"\n  },\n  signAlgorithm: {\n    name: \"ECDSA\",\n    // hash: {name: \"SHA-384\"},\n    hash: {\n      name: \"SHA-256\"\n    }\n  }\n};\n\nclass Authenticator {\n  static decodePublicKey(file) {\n    return KeyPair_1.KeyPair.publicFromBase64orPEM(file);\n  } // TODO: Pass in Ticket schema object\n\n\n  static getUseTicket(ticketSecret, attestationSecret, base64ticket, base64attestation, base64attestationPublicKey, base64senderPublicKeys) {\n    return _asyncToGenerator(function* () {\n      let ticket;\n      let att;\n\n      try {\n        base64senderPublicKeys = KeyPair_1.KeyPair.parseKeyArrayStrings(base64senderPublicKeys);\n      } catch (e) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, e);\n        throw new Error(\"Issuer key error\");\n      }\n\n      if (!base64ticket) {\n        throw new Error(\"Ticket is empty\");\n      }\n\n      ticket = Ticket_1.Ticket.fromBase64(base64ticket, base64senderPublicKeys);\n\n      if (!ticket.checkValidity()) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Could not validate ticket\");\n        throw new Error(\"Ticket Validation failed\");\n      }\n\n      if (!ticket.verify()) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Could not verify ticket\");\n        throw new Error(\"Ticket Verification failed\");\n      }\n\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.MEDIUM, 'ticked valid (signature OK)');\n\n      if (!base64attestationPublicKey) {\n        throw new Error(\"Attesator key not defined\");\n      }\n\n      let attestorKey;\n\n      try {\n        attestorKey = KeyPair_1.KeyPair.publicFromBase64orPEM(base64attestationPublicKey);\n      } catch (e) {\n        throw new Error(\"Attesator key read error\");\n      }\n\n      try {\n        att = SignedIdentifierAttestation_1.SignedIdentifierAttestation.fromBytes((0, utils_1.base64ToUint8array)(base64attestation), attestorKey);\n      } catch (e) {\n        throw new Error(\"IDAttestation decode error\");\n      }\n\n      if (!att.checkValidity()) {\n        throw new Error(\"IDAttestation Validation failed\");\n      }\n\n      if (!att.verify()) {\n        throw new Error(\"IDAttestation Verification failed\");\n      }\n\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, 'attestation valid');\n\n      try {\n        let redeem = new AttestedObject_1.AttestedObject();\n        redeem.create(ticket, att, BigInt(attestationSecret), BigInt(ticketSecret));\n        let unSigned = redeem.getDerEncoding();\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, unSigned);\n        return (0, utils_1.hexStringToBase64)(unSigned); // return unSigned;\n      } catch (e) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.MEDIUM, 'getUseTicket: redeem failed', e);\n        throw new Error(\"Attestation doesnt fit Ticket: \" + e.message);\n      }\n    })();\n  } // TODO: Pass in Ticket schema object\n\n\n  static validateUseTicket(proof, base64attestorPublicKey, base64issuerPublicKeys, userEthKey) {\n    let attestorKey = KeyPair_1.KeyPair.publicFromBase64orPEM(base64attestorPublicKey);\n    let issuerKeys = KeyPair_1.KeyPair.parseKeyArrayStrings(base64issuerPublicKeys);\n\n    try {\n      let decodedAttestedObject = AttestedObject_1.AttestedObject.fromBytes((0, utils_1.base64ToUint8array)(proof), UseToken_1.UseToken, attestorKey, Ticket_1.Ticket, issuerKeys);\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Verified attested object\");\n\n      if (!decodedAttestedObject.checkValidity(userEthKey)) {\n        throw new Error(\"Ticket validity check failed!\");\n      }\n    } catch (e) {\n      let message = \"Ticket proof validation failed! \" + e.message;\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.MEDIUM, message);\n      throw new Error(message);\n    }\n  }\n  /*\n   * get ticket attestation from wallet, or issuer site's local storage through iframe\n   *  - Open an Iframe and obtain the data object (in this case SignedDevonTicket)\n   */\n  // function\n  // getTokenAttestation(tokenObj) {\n  // }\n\n\n  static requestAttest(receiverId, type, attestorDomain, secret, userKey = null) {\n    return _asyncToGenerator(function* () {\n      let crypto = new AttestationCrypto_1.AttestationCrypto();\n      let userAddress;\n\n      if (userKey) {\n        userAddress = userKey.getAddress();\n      } else {\n        try {\n          userAddress = yield SignatureUtility_1.SignatureUtility.connectMetamaskAndGetAddress();\n        } catch (e) {\n          (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'Cant find user Ethereum Address. Please check Metamask. ' + e);\n          (0, utils_1.logger)(config_1.DEBUGLEVEL.MEDIUM, e);\n          return;\n        }\n      }\n\n      let nonce = yield Nonce_1.Nonce.makeNonce(userAddress, attestorDomain);\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, 'nonce = ' + (0, utils_1.uint8tohex)(nonce));\n      let pok = crypto.computeAttestationProof(secret, nonce);\n      let attRequest = AttestationRequest_1.AttestationRequest.fromData(crypto.getType(type), pok);\n      let attest = new Eip712AttestationRequest_1.Eip712AttestationRequest(userKey);\n      yield attest.addData(attestorDomain, 20 * 1000, receiverId, attRequest);\n      let attestJson = attest.getJsonEncoding();\n      return attestJson;\n    })();\n  } // static async constructAttest(\n  //     attestorKey: KeyPair,\n  //     receiverId: string,\n  //     type: string,\n  //     ATTESTOR_DOMAIN: string,\n  //     attestationSecretBase64: string,\n  //     sessionKey: KeyPair,\n  // ){\n  //\n  // }\n\n\n  static constructAttest(attestorKey, issuerName, validityInMilliseconds, attestRequestJson, attestorDomain, usageValue = \"\") {\n    let att;\n    let crypto = new AttestationCrypto_1.AttestationCrypto();\n    let attestationRequest;\n    let commitment;\n\n    try {\n      // decode JSON and fill publicKey\n      // set usageValue as \"Creating email attestation\"\n      attestationRequest = new Eip712AttestationRequest_1.Eip712AttestationRequest();\n      attestationRequest.setDomain(attestorDomain);\n\n      if (usageValue) {\n        attestationRequest.setUsageValue(usageValue);\n      }\n\n      attestationRequest.fillJsonData(attestRequestJson);\n      Authenticator.checkAttestRequestVerifiability(attestationRequest);\n      Authenticator.checkAttestRequestValidity(attestationRequest);\n    } catch (e) {\n      let m = \"Failed to fill attestation data from json. \" + e + \"\\nRestores as an Eip712AttestationRequestWithUsage object instead\";\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.MEDIUM, m);\n\n      try {\n        attestationRequest = new Eip712AttestationRequestWithUsage_1.Eip712AttestationRequestWithUsage();\n        attestationRequest.setDomain(attestorDomain);\n        attestationRequest.fillJsonData(attestRequestJson);\n        Authenticator.checkAttestRequestVerifiability(attestationRequest);\n        Authenticator.checkAttestRequestValidity(attestationRequest);\n      } catch (e) {\n        let m = \"Failed to parse Eip712AttestationRequestWithUsage. \" + e;\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, m);\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.MEDIUM, e);\n        throw new Error(m);\n      }\n    }\n\n    commitment = crypto.makeCommitmentFromHiding(attestationRequest.getIdentifier(), attestationRequest.getType(), attestationRequest.getPok().getRiddle());\n    att = new IdentifierAttestation_1.IdentifierAttestation();\n    att.fromCommitment(commitment, attestationRequest.getUserPublicKey());\n    att.setIssuer(\"CN=\" + issuerName);\n    att.setSerialNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER));\n    let now = Date.now();\n    att.setNotValidBefore(now);\n    att.setNotValidAfter(now + validityInMilliseconds);\n    let signed = SignedIdentifierAttestation_1.SignedIdentifierAttestation.fromData(att, attestorKey);\n    return signed.getDerEncoding();\n  } // PREFIX + \"user-priv.pem\", PREFIX + \"attestation.crt\", PREFIX + \"attestation-secret.pem\", PREFIX + \"attestor-pub.pem\", \"test@test.ts\", \"mail\", PREFIX + \"session-priv.pem\", PREFIX + \"use-attestation.json\"\n\n\n  static useAttest(attestationBase64, attestationSecretBase64, attestorKey, receiverId, type, webDomain, sessionKey = null, userKey = null) {\n    return _asyncToGenerator(function* () {\n      const attestationUint8 = (0, utils_1.base64ToUint8array)(attestationBase64);\n      let att = SignedIdentifierAttestation_1.SignedIdentifierAttestation.fromBytes(attestationUint8, attestorKey);\n      let attestationSecretDerUint8 = (0, utils_1.base64ToUint8array)(attestationSecretBase64); // remove first 4 bytes because us der encoding\n\n      let attestationSecret = (0, utils_1.uint8ToBn)(attestationSecretDerUint8.slice(4));\n      let crypto = new AttestationCrypto_1.AttestationCrypto();\n      let address;\n\n      if (userKey) {\n        address = userKey.getAddress();\n      } else {\n        address = yield SignatureUtility_1.SignatureUtility.connectMetamaskAndGetAddress();\n      }\n\n      let nonce = yield Nonce_1.Nonce.makeNonce(address, webDomain);\n      let pok = crypto.computeAttestationProof(attestationSecret, nonce);\n\n      try {\n        let attUsage = UseAttestation_1.UseAttestation.fromData(att, crypto.getType(type), pok, sessionKey);\n        let usageRequest = new Eip712AttestationUsage_1.Eip712AttestationUsage(userKey);\n        let res = yield usageRequest.addData(webDomain, receiverId, attUsage);\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, 'usageRequest ready state = ' + res);\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, 'usageRequest.getJsonEncoding() = ' + usageRequest.getJsonEncoding());\n        return usageRequest.getJsonEncoding();\n      } catch (e) {\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, e);\n      }\n    })();\n  }\n\n  static checkAttestRequestVerifiability(input) {\n    if (!input.verify()) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.MEDIUM, \"Could not verify attestation signing request\");\n      throw new Error(\"Verification failed\");\n    }\n  }\n\n  static checkAttestRequestValidity(input) {\n    if (!input.checkValidity()) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, \"Could not validate attestation signing request\");\n      throw new Error(\"Validation failed\");\n    }\n  }\n\n  static checkUsageVerifiability(input) {\n    if (!input.verify()) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Could not verify usage request\");\n      throw new Error(\"Verification failed\");\n    }\n  }\n\n  static checkUsageValidity(input) {\n    if (!input.checkTokenValidity()) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Could not validate usage request\");\n      throw new Error(\"Validation failed\");\n    }\n  }\n\n  static verifyUsage(jsonRequest, attestorKey, message, WEB_DOMAIN, signature) {\n    return _asyncToGenerator(function* () {\n      let sessionPublicKey;\n\n      try {\n        let usageRequest = new Eip712AttestationUsage_1.Eip712AttestationUsage();\n        usageRequest.setDomain(WEB_DOMAIN);\n        usageRequest.fillJsonData(jsonRequest, attestorKey);\n        Authenticator.checkUsageVerifiability(usageRequest);\n        Authenticator.checkUsageValidity(usageRequest);\n        sessionPublicKey = usageRequest.getSessionPublicKey();\n      } catch (e) {\n        // Try as an  Eip712AttestationRequestWithUsage object instead, which is NOT linked to a specific website\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.MEDIUM, 'Eip712AttestationUsage failed. ' + e + '. Lets try to verify Eip712AttestationRequestWithUsage');\n        let usageRequest = new Eip712AttestationRequestWithUsage_1.Eip712AttestationRequestWithUsage();\n        usageRequest.setDomain(WEB_DOMAIN);\n        usageRequest.fillJsonData(jsonRequest);\n        Authenticator.checkUsageVerifiability(usageRequest);\n        Authenticator.checkUsageValidity(usageRequest);\n        sessionPublicKey = usageRequest.getSessionPublicKey();\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, 'sessionPublicKey from Eip712AttestationRequestWithUsage = ' + sessionPublicKey.getAddress());\n      } // Validate signature\n\n\n      try {\n        let res = yield sessionPublicKey.verifyStringWithSubtle(KeyPair_1.KeyPair.anySignatureToRawUint8(signature), message);\n\n        if (!res) {\n          (0, utils_1.logger)(config_1.DEBUGLEVEL.MEDIUM, \"Could not verify message signature\");\n          throw new Error(\"Signature verification failed\");\n        }\n\n        return \"SUCCESSFULLY validated usage request!\";\n      } catch (e) {\n        let m = \"Cant verify session with subtle. \" + e;\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, m);\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.MEDIUM, e);\n      }\n    })();\n  }\n\n  static requestAttestAndUsage(userKey, receiverId, type, ATTESTOR_DOMAIN, attestationSecretBase64, sessionKey) {\n    return _asyncToGenerator(function* () {\n      try {\n        let attestationSecret = (0, utils_1.uint8ToBn)((0, utils_1.base64ToUint8array)(attestationSecretBase64));\n        let address;\n\n        if (userKey) {\n          address = userKey.getAddress();\n        } else {\n          address = yield SignatureUtility_1.SignatureUtility.connectMetamaskAndGetAddress();\n        }\n\n        let nonce = yield Nonce_1.Nonce.makeNonce(address, ATTESTOR_DOMAIN, new Uint8Array(0), Date.now());\n        let crypto = new AttestationCrypto_1.AttestationCrypto();\n        let pok = crypto.computeAttestationProof(attestationSecret, nonce);\n        let attRequest = AttestationRequestWithUsage_1.AttestationRequestWithUsage.fromData(crypto.getType(type), pok, sessionKey);\n        let request = new Eip712AttestationRequestWithUsage_1.Eip712AttestationRequestWithUsage(userKey);\n        yield request.fromData(ATTESTOR_DOMAIN, undefined, undefined, receiverId, attRequest);\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, 'request.getJsonEncoding() = ' + request.getJsonEncoding());\n        return request.getJsonEncoding();\n      } catch (e) {\n        let m = \"requestAttestAndUsage error. \" + e;\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, m);\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.MEDIUM, e);\n      }\n    })();\n  }\n  /*\n      static async signMessageWithSessionKey(message: Uint8Array, sessionKey: Uint8Array = new Uint8Array(0)){\n          let privKey, signature;\n          // logger(DEBUGLEVEL.HIGH, \"message = \" + uint8tohex(message));\n  \n          try {\n              if (sessionKey && sessionKey.length) {\n                  // its nodejs and session primary key received in Uint8Array\n                  logger(DEBUGLEVEL.HIGH, \"sessionKey = \" + uint8tohex(sessionKey));\n                  logger(DEBUGLEVEL.HIGH, sessionKey);\n  \n              } else {\n                  // TODO read key from local storage\n              }\n              // signature = await crypto.subtle.sign(ALPHA_CONFIG.signAlgorithm, privKey, message);\n          } catch (e){\n              logger(DEBUGLEVEL.HIGH, e);\n              // throw new Error(e);\n          }\n          // let signatureHex = uint8tohex(new Uint8Array(signature));\n          // return signatureHex;\n      }\n  \n      static async verifyMessageSignatureWithSessionKey(message: Uint8Array, signature: string, sessionKey: Uint8Array = new Uint8Array(0)){\n          let privKey;\n          if (sessionKey && sessionKey.length) {\n              // its nodejs and session primary key received in Uint8Array\n              privKey = await subtle.importKey(\n                  'raw',\n                  sessionKey,\n                  {\n                      name: \"ECDSA\",\n                      namedCurve: \"P-256\"\n                  },\n                  true,\n                  ['sign', 'verify']\n              );\n          } else {\n              // TODO read key from local storage\n          }\n  \n          let signatureUint8 = hexStringToUint8(signature);\n  \n          const result = await crypto.subtle.verify(ALPHA_CONFIG.keysAlgorithm, privKey.publicKey, signatureUint8, message );\n      }\n  \n   */\n\n\n  static validateTicket(ticketBase64, confernceId, publicKeyPEM) {\n    let keys = {};\n\n    try {\n      keys[confernceId] = KeyPair_1.KeyPair.publicFromBase64orPEM(publicKeyPEM);\n    } catch (e) {\n      return {\n        valid: false,\n        massage: \"Broken Public Key\"\n      };\n    }\n\n    let ticket;\n\n    try {\n      ticket = Ticket_1.Ticket.fromBase64(ticketBase64, keys);\n    } catch (e) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, e);\n      return {\n        valid: false,\n        massage: \"Wrong Ticket\"\n      };\n    }\n\n    return {\n      valid: true,\n      ticketId: ticket.getTicketId(),\n      ticketClass: ticket.getTicketClass()\n    };\n  }\n\n}\n\nexports.Authenticator = Authenticator; //# sourceMappingURL=Authenticator.js.map","map":null,"metadata":{},"sourceType":"script"}