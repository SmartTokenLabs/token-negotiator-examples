{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AttestationRequestWithUsage = void 0;\n\nconst KeyPair_1 = require(\"./KeyPair\");\n\nconst FullProofOfExponent_1 = require(\"./FullProofOfExponent\");\n\nconst AttestationRequestWithUsage_1 = require(\"../asn1/shemas/AttestationRequestWithUsage\");\n\nconst asn1_schema_1 = require(\"@peculiar/asn1-schema\");\n\nconst utils_1 = require(\"./utils\");\n\nconst Point_1 = require(\"./Point\");\n\nconst AttestationCrypto_1 = require(\"./AttestationCrypto\");\n\nconst DerUtility_1 = require(\"./DerUtility\");\n\nconst config_1 = require(\"../config\");\n\nclass AttestationRequestWithUsage {\n  constructor() {}\n\n  static fromData(type, pok, sessionPublicKey) {\n    let me = new this();\n    me.type = type;\n    me.pok = pok;\n    me.sessionPublicKey = sessionPublicKey;\n\n    if (!me.verify()) {\n      throw new Error(\"Could not verify the proof\");\n    }\n\n    return me;\n  }\n\n  static fromBytes(asn1) {\n    let me = new this();\n    let identifier;\n\n    try {\n      identifier = asn1_schema_1.AsnParser.parse(asn1, AttestationRequestWithUsage_1.Identifier);\n      me.type = identifier.type;\n      me.sessionPublicKey = KeyPair_1.KeyPair.publicFromSubjectPublicKeyValue(identifier.sessionKey);\n    } catch (e) {\n      throw new Error('Cant parse AttestationRequest Identifier');\n    }\n\n    try {\n      let riddleEnc = new Uint8Array(identifier.proof.riddle);\n      let challengeEnc = new Uint8Array(identifier.proof.challengePoint);\n      let tPointEnc = new Uint8Array(identifier.proof.responseValue);\n      let nonce = new Uint8Array(identifier.proof.nonce);\n      let riddle = Point_1.Point.decodeFromHex((0, utils_1.uint8tohex)(riddleEnc), Point_1.CURVE_BN256);\n      let challenge = (0, utils_1.uint8ToBn)(challengeEnc);\n      let tPoint = Point_1.Point.decodeFromHex((0, utils_1.uint8tohex)(tPointEnc), Point_1.CURVE_BN256);\n      me.pok = FullProofOfExponent_1.FullProofOfExponent.fromData(riddle, tPoint, challenge, nonce);\n    } catch (e) {\n      throw new Error('Cant create FullProofOfExponent');\n    }\n\n    if (!me.verify()) {\n      throw new Error(\"Could not verify the proof\");\n    }\n\n    (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, 'proof OK');\n    return me;\n  }\n\n  verify() {\n    let AttestationCryptoInstance = new AttestationCrypto_1.AttestationCrypto();\n\n    if (!AttestationCryptoInstance.verifyFullProof(this.pok)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  getDerEncoding() {\n    let res = DerUtility_1.Asn1Der.encode('INTEGER', this.type) + this.pok.getDerEncoding() + this.sessionPublicKey.getAsnDerPublic();\n    return DerUtility_1.Asn1Der.encode('SEQUENCE_30', res);\n  }\n\n  getPok() {\n    return this.pok;\n  }\n\n  getType() {\n    return this.type;\n  }\n\n  getSessionPublicKey() {\n    return this.sessionPublicKey;\n  }\n\n}\n\nexports.AttestationRequestWithUsage = AttestationRequestWithUsage; //# sourceMappingURL=AttestationRequestWithUsage.js.map","map":null,"metadata":{},"sourceType":"script"}