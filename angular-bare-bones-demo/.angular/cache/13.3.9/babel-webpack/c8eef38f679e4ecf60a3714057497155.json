{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Timestamp = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst config_1 = require(\"../config\");\n\nclass Timestamp {\n  constructor(timeSinceEpochInMs = null) {\n    this.ALLOWED_ROUNDING = 10000; // 10 sec, since we are always rounding to the nearest second in the string representation\n\n    this.validity = 0;\n    if (!timeSinceEpochInMs) this.time = Date.now();\n\n    if (typeof timeSinceEpochInMs === 'number') {\n      this.time = timeSinceEpochInMs;\n    }\n\n    if (typeof timeSinceEpochInMs === 'string') {\n      this.time = Timestamp.stringTimestampToLong(timeSinceEpochInMs);\n    }\n\n    this.time = this.time - this.time % 1000;\n  }\n\n  fromString(timeAsString) {\n    this.time = Timestamp.stringTimestampToLong(timeAsString);\n  }\n\n  getValidity() {\n    return this.validity;\n  }\n\n  setValidity(validity) {\n    this.validity = validity;\n  }\n\n  getTime() {\n    return this.time;\n  }\n\n  getTimeAsString() {\n    let preTime = new Date(this.time).toString(); //.replace('GMT',' GMT');\n\n    return preTime.substr(0, preTime.indexOf('(') - 1);\n  }\n\n  validateTimestamp() {\n    let currentTime = this.getCurrentTime();\n\n    if (this.time > currentTime + this.ALLOWED_ROUNDING) {\n      return false;\n    } // Slack only goes into the future\n\n\n    if (this.time + this.ALLOWED_ROUNDING + this.validity < currentTime) {\n      return false;\n    }\n\n    return true;\n  }\n\n  validateAgainstExpiration(expirationTimeInMs) {\n    let currentTime = this.getCurrentTime(); // If timestamp is in the future\n\n    if (this.time > currentTime + this.ALLOWED_ROUNDING) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Object still not valid. Details: not valid before = \" + this.time + \", currentTime = \" + currentTime);\n      return false;\n    } // If token has expired\n\n\n    if (expirationTimeInMs < currentTime - this.ALLOWED_ROUNDING) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Object is not longer valid. Details: attNotAfter = \" + expirationTimeInMs + \", currentTime = \" + currentTime);\n      return false;\n    } // If the token is valid for too long\n\n\n    if (expirationTimeInMs - this.time > this.validity + this.ALLOWED_ROUNDING) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, expirationTimeInMs + \"\\n\" + this.time + \"\\n\" + this.validity + \"\\n\" + this.ALLOWED_ROUNDING + \"\\n\" + (expirationTimeInMs - this.time) + \"\\n\" + (this.validity + this.ALLOWED_ROUNDING) + \"\\n\");\n      return false;\n    }\n\n    return true;\n  }\n\n  static stringTimestampToLong(timestamp) {\n    return Date.parse(timestamp);\n  }\n\n  getCurrentTime() {\n    return Date.now();\n  }\n\n}\n\nexports.Timestamp = Timestamp; // Timestamp with millisecond accuracy and timezone info\n// Date.parse('Thu, 01 Jan 1970 00:00:00 GMT-0400');\n// Tue Mar 30 2021 21:14:22 GMT+0300\n\nTimestamp.TIMESTAMP_FORMAT = \"EEE MMM d yyyy HH:mm:ss 'GMT'Z\";\nTimestamp.ALLOWED_ROUNDING = 10000; // 10 sec, since we are always rounding to the nearest second in the string representation\n\nTimestamp.UNLIMITED = 253402297199000;\nTimestamp.DEFAULT_TOKEN_TIME_LIMIT = 1000 * 60 * 60 * 24 * 365; // 1 year\n\nTimestamp.DEFAULT_TIME_LIMIT_MS = 1000 * 60 * 20; // 20 minutes\n//# sourceMappingURL=Timestamp.js.map","map":null,"metadata":{},"sourceType":"script"}