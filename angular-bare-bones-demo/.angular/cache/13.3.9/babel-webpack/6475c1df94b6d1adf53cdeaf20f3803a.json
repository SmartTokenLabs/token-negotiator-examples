{"ast":null,"code":"/*\n * Emulate 'eth_accounts' / 'eth_sendTransaction' using 'eth_sendRawTransaction'\n *\n * The two callbacks a user needs to implement are:\n * - getAccounts() -- array of addresses supported\n * - signTransaction(tx) -- sign a raw transaction object\n */\nconst waterfall = require('async/waterfall');\n\nconst parallel = require('async/parallel');\n\nconst inherits = require('util').inherits;\n\nconst ethUtil = require('ethereumjs-util');\n\nconst sigUtil = require('eth-sig-util');\n\nconst extend = require('xtend');\n\nconst Semaphore = require('semaphore');\n\nconst Subprovider = require('./subprovider.js');\n\nconst estimateGas = require('../util/estimate-gas.js');\n\nconst hexRegex = /^[0-9A-Fa-f]+$/g;\nmodule.exports = HookedWalletSubprovider; // handles the following RPC methods:\n//   eth_coinbase\n//   eth_accounts\n//   eth_sendTransaction\n//   eth_sign\n//   eth_signTypedData\n//   eth_signTypedData_v3\n//   eth_signTypedData_v4\n//   personal_sign\n//   eth_decryptMessage\n//   encryption_public_key\n//   personal_ecRecover\n//   parity_postTransaction\n//   parity_checkRequest\n//   parity_defaultAccount\n//\n// Tx Signature Flow\n//\n// handleRequest: eth_sendTransaction\n//   validateTransaction (basic validity check)\n//     validateSender (checks that sender is in accounts)\n//   processTransaction (sign tx and submit to network)\n//     approveTransaction (UI approval hook)\n//     checkApproval\n//     finalizeAndSubmitTx (tx signing)\n//       nonceLock.take (bottle neck to ensure atomic nonce)\n//         fillInTxExtras (set fallback gasPrice, nonce, etc)\n//         signTransaction (perform the signature)\n//         publishTransaction (publish signed tx to network)\n//\n\ninherits(HookedWalletSubprovider, Subprovider);\n\nfunction HookedWalletSubprovider(opts) {\n  const self = this; // control flow\n\n  self.nonceLock = Semaphore(1); // data lookup\n\n  if (opts.getAccounts) self.getAccounts = opts.getAccounts; // high level override\n\n  if (opts.processTransaction) self.processTransaction = opts.processTransaction;\n  if (opts.processMessage) self.processMessage = opts.processMessage;\n  if (opts.processPersonalMessage) self.processPersonalMessage = opts.processPersonalMessage;\n  if (opts.processTypedMessage) self.processTypedMessage = opts.processTypedMessage; // approval hooks\n\n  self.approveTransaction = opts.approveTransaction || self.autoApprove;\n  self.approveMessage = opts.approveMessage || self.autoApprove;\n  self.approvePersonalMessage = opts.approvePersonalMessage || self.autoApprove;\n  self.approveDecryptMessage = opts.approveDecryptMessage || self.autoApprove;\n  self.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self.autoApprove;\n  self.approveTypedMessage = opts.approveTypedMessage || self.autoApprove; // actually perform the signature\n\n  if (opts.signTransaction) self.signTransaction = opts.signTransaction || mustProvideInConstructor('signTransaction');\n  if (opts.signMessage) self.signMessage = opts.signMessage || mustProvideInConstructor('signMessage');\n  if (opts.signPersonalMessage) self.signPersonalMessage = opts.signPersonalMessage || mustProvideInConstructor('signPersonalMessage');\n  if (opts.decryptMessage) self.decryptMessage = opts.decryptMessage || mustProvideInConstructor('decryptMessage');\n  if (opts.encryptionPublicKey) self.encryptionPublicKey = opts.encryptionPublicKey || mustProvideInConstructor('encryptionPublicKey');\n  if (opts.signTypedMessage) self.signTypedMessage = opts.signTypedMessage || mustProvideInConstructor('signTypedMessage');\n  if (opts.recoverPersonalSignature) self.recoverPersonalSignature = opts.recoverPersonalSignature; // publish to network\n\n  if (opts.publishTransaction) self.publishTransaction = opts.publishTransaction; // gas options\n\n  self.estimateGas = opts.estimateGas || self.estimateGas;\n  self.getGasPrice = opts.getGasPrice || self.getGasPrice;\n}\n\nHookedWalletSubprovider.prototype.handleRequest = function (payload, next, end) {\n  const self = this;\n  self._parityRequests = {};\n  self._parityRequestCount = 0; // switch statement is not block scoped\n  // sp we cant repeat var declarations\n\n  let txParams, msgParams, extraParams;\n  let message, address;\n\n  switch (payload.method) {\n    case 'eth_coinbase':\n      // process normally\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        let result = accounts[0] || null;\n        end(null, result);\n      });\n      return;\n\n    case 'eth_accounts':\n      // process normally\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        end(null, accounts);\n      });\n      return;\n\n    case 'eth_sendTransaction':\n      txParams = payload.params[0];\n      waterfall([cb => self.validateTransaction(txParams, cb), cb => self.processTransaction(txParams, cb)], end);\n      return;\n\n    case 'eth_signTransaction':\n      txParams = payload.params[0];\n      waterfall([cb => self.validateTransaction(txParams, cb), cb => self.processSignTransaction(txParams, cb)], end);\n      return;\n\n    case 'eth_sign':\n      // process normally\n      address = payload.params[0];\n      message = payload.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n      // good place for metadata\n\n      extraParams = payload.params[2] || {};\n      msgParams = extend(extraParams, {\n        from: address,\n        data: message\n      });\n      waterfall([cb => self.validateMessage(msgParams, cb), cb => self.processMessage(msgParams, cb)], end);\n      return;\n\n    case 'personal_sign':\n      return function () {\n        // process normally\n        const first = payload.params[0];\n        const second = payload.params[1]; // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_personalSign method requires params ordered `;\n          warning += `[message, address]. This was previously handled incorrectly, `;\n          warning += `and has been corrected automatically. `;\n          warning += `Please switch this param order for smooth behavior in the future.`;\n          console.warn(warning);\n          address = payload.params[0];\n          message = payload.params[1];\n        } else {\n          message = payload.params[0];\n          address = payload.params[1];\n        } // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n\n\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message\n        });\n        waterfall([cb => self.validatePersonalMessage(msgParams, cb), cb => self.processPersonalMessage(msgParams, cb)], end);\n      }();\n\n    case 'eth_decryptMessage':\n      return function () {\n        // process normally\n        const first = payload.params[0];\n        const second = payload.params[1]; // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_decryptMessage method requires params ordered `;\n          warning += `[message, address]. This was previously handled incorrectly, `;\n          warning += `and has been corrected automatically. `;\n          warning += `Please switch this param order for smooth behavior in the future.`;\n          console.warn(warning);\n          address = payload.params[0];\n          message = payload.params[1];\n        } else {\n          message = payload.params[0];\n          address = payload.params[1];\n        } // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n\n\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message\n        });\n        waterfall([cb => self.validateDecryptMessage(msgParams, cb), cb => self.processDecryptMessage(msgParams, cb)], end);\n      }();\n\n    case 'encryption_public_key':\n      return function () {\n        const address = payload.params[0];\n        waterfall([cb => self.validateEncryptionPublicKey(address, cb), cb => self.processEncryptionPublicKey(address, cb)], end);\n      }();\n\n    case 'personal_ecRecover':\n      return function () {\n        message = payload.params[0];\n        let signature = payload.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          sig: signature,\n          data: message\n        });\n        self.recoverPersonalSignature(msgParams, end);\n      }();\n\n    case 'eth_signTypedData':\n    case 'eth_signTypedData_v3':\n    case 'eth_signTypedData_v4':\n      return function () {\n        // process normally\n        const first = payload.params[0];\n        const second = payload.params[1];\n\n        if (resemblesAddress(first)) {\n          address = first;\n          message = second;\n        } else {\n          message = first;\n          address = second;\n        }\n\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message\n        });\n        waterfall([cb => self.validateTypedMessage(msgParams, cb), cb => self.processTypedMessage(msgParams, cb)], end);\n      }();\n\n    case 'parity_postTransaction':\n      txParams = payload.params[0];\n      self.parityPostTransaction(txParams, end);\n      return;\n\n    case 'parity_postSign':\n      address = payload.params[0];\n      message = payload.params[1];\n      self.parityPostSign(address, message, end);\n      return;\n\n    case 'parity_checkRequest':\n      return function () {\n        const requestId = payload.params[0];\n        self.parityCheckRequest(requestId, end);\n      }();\n\n    case 'parity_defaultAccount':\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        const account = accounts[0] || null;\n        end(null, account);\n      });\n      return;\n\n    default:\n      next();\n      return;\n  }\n}; //\n// data lookup\n//\n\n\nHookedWalletSubprovider.prototype.getAccounts = function (cb) {\n  cb(null, []);\n}; //\n// \"process\" high level flow\n//\n\n\nHookedWalletSubprovider.prototype.processTransaction = function (txParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveTransaction(txParams, cb), (didApprove, cb) => self.checkApproval('transaction', didApprove, cb), cb => self.finalizeAndSubmitTx(txParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processSignTransaction = function (txParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveTransaction(txParams, cb), (didApprove, cb) => self.checkApproval('transaction', didApprove, cb), cb => self.finalizeTx(txParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('message', didApprove, cb), cb => self.signMessage(msgParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processPersonalMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approvePersonalMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('message', didApprove, cb), cb => self.signPersonalMessage(msgParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processDecryptMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveDecryptMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('decryptMessage', didApprove, cb), cb => self.decryptMessage(msgParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processEncryptionPublicKey = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveEncryptionPublicKey(msgParams, cb), (didApprove, cb) => self.checkApproval('encryptionPublicKey', didApprove, cb), cb => self.encryptionPublicKey(msgParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processTypedMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveTypedMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('message', didApprove, cb), cb => self.signTypedMessage(msgParams, cb)], cb);\n}; //\n// approval\n//\n\n\nHookedWalletSubprovider.prototype.autoApprove = function (txParams, cb) {\n  cb(null, true);\n};\n\nHookedWalletSubprovider.prototype.checkApproval = function (type, didApprove, cb) {\n  cb(didApprove ? null : new Error('User denied ' + type + ' signature.'));\n}; //\n// parity\n//\n\n\nHookedWalletSubprovider.prototype.parityPostTransaction = function (txParams, cb) {\n  const self = this; // get next id\n\n  const count = self._parityRequestCount;\n  const reqId = `0x${count.toString(16)}`;\n  self._parityRequestCount++;\n  self.emitPayload({\n    method: 'eth_sendTransaction',\n    params: [txParams]\n  }, function (error, res) {\n    if (error) {\n      self._parityRequests[reqId] = {\n        error\n      };\n      return;\n    }\n\n    const txHash = res.result;\n    self._parityRequests[reqId] = txHash;\n  });\n  cb(null, reqId);\n};\n\nHookedWalletSubprovider.prototype.parityPostSign = function (address, message, cb) {\n  const self = this; // get next id\n\n  const count = self._parityRequestCount;\n  const reqId = `0x${count.toString(16)}`;\n  self._parityRequestCount++;\n  self.emitPayload({\n    method: 'eth_sign',\n    params: [address, message]\n  }, function (error, res) {\n    if (error) {\n      self._parityRequests[reqId] = {\n        error\n      };\n      return;\n    }\n\n    const result = res.result;\n    self._parityRequests[reqId] = result;\n  });\n  cb(null, reqId);\n};\n\nHookedWalletSubprovider.prototype.parityCheckRequest = function (reqId, cb) {\n  const self = this;\n  const result = self._parityRequests[reqId] || null; // tx not handled yet\n\n  if (!result) return cb(null, null); // tx was rejected (or other error)\n\n  if (result.error) return cb(result.error); // tx sent\n\n  cb(null, result);\n}; //\n// signature and recovery\n//\n\n\nHookedWalletSubprovider.prototype.recoverPersonalSignature = function (msgParams, cb) {\n  let senderHex;\n\n  try {\n    senderHex = sigUtil.recoverPersonalSignature(msgParams);\n  } catch (err) {\n    return cb(err);\n  }\n\n  cb(null, senderHex);\n}; //\n// validation\n//\n\n\nHookedWalletSubprovider.prototype.validateTransaction = function (txParams, cb) {\n  const self = this; // shortcut: undefined sender is invalid\n\n  if (txParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign transaction.`));\n  self.validateSender(txParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign transaction for this address: \"${txParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateMessage = function (msgParams, cb) {\n  const self = this;\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign message.`));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validatePersonalMessage = function (msgParams, cb) {\n  const self = this;\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign personal message.`));\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to sign personal message.`));\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateDecryptMessage = function (msgParams, cb) {\n  const self = this;\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to decrypt message.`));\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to decrypt message.`));\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.`));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to decrypt message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateEncryptionPublicKey = function (address, cb) {\n  const self = this;\n  self.validateSender(address, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to obtain encryption public key for this address: \"${address}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateTypedMessage = function (msgParams, cb) {\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign typed data.`));\n  if (msgParams.data === undefined) return cb(new Error(`Undefined data - message required to sign typed data.`));\n  this.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateSender = function (senderAddress, cb) {\n  const self = this; // shortcut: undefined sender is invalid\n\n  if (!senderAddress) return cb(null, false);\n  self.getAccounts(function (err, accounts) {\n    if (err) return cb(err);\n    const senderIsValid = accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1;\n    cb(null, senderIsValid);\n  });\n}; //\n// tx helpers\n//\n\n\nHookedWalletSubprovider.prototype.finalizeAndSubmitTx = function (txParams, cb) {\n  const self = this; // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n\n  self.nonceLock.take(function () {\n    waterfall([self.fillInTxExtras.bind(self, txParams), self.signTransaction.bind(self), self.publishTransaction.bind(self)], function (err, txHash) {\n      self.nonceLock.leave();\n      if (err) return cb(err);\n      cb(null, txHash);\n    });\n  });\n};\n\nHookedWalletSubprovider.prototype.finalizeTx = function (txParams, cb) {\n  const self = this; // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n\n  self.nonceLock.take(function () {\n    waterfall([self.fillInTxExtras.bind(self, txParams), self.signTransaction.bind(self)], function (err, signedTx) {\n      self.nonceLock.leave();\n      if (err) return cb(err);\n      cb(null, {\n        raw: signedTx,\n        tx: txParams\n      });\n    });\n  });\n};\n\nHookedWalletSubprovider.prototype.publishTransaction = function (rawTx, cb) {\n  const self = this;\n  self.emitPayload({\n    method: 'eth_sendRawTransaction',\n    params: [rawTx]\n  }, function (err, res) {\n    if (err) return cb(err);\n    cb(null, res.result);\n  });\n};\n\nHookedWalletSubprovider.prototype.estimateGas = function (txParams, cb) {\n  const self = this;\n  estimateGas(self.engine, txParams, cb);\n};\n\nHookedWalletSubprovider.prototype.getGasPrice = function (cb) {\n  const self = this;\n  self.emitPayload({\n    method: 'eth_gasPrice',\n    params: []\n  }, function (err, res) {\n    if (err) return cb(err);\n    cb(null, res.result);\n  });\n};\n\nHookedWalletSubprovider.prototype.fillInTxExtras = function (txParams, cb) {\n  const self = this;\n  const address = txParams.from; // console.log('fillInTxExtras - address:', address)\n\n  const tasks = {};\n\n  if (txParams.gasPrice === undefined) {\n    // console.log(\"need to get gasprice\")\n    tasks.gasPrice = self.getGasPrice.bind(self);\n  }\n\n  if (txParams.nonce === undefined) {\n    // console.log(\"need to get nonce\")\n    tasks.nonce = self.emitPayload.bind(self, {\n      method: 'eth_getTransactionCount',\n      params: [address, 'pending']\n    });\n  }\n\n  if (txParams.gas === undefined) {\n    // console.log(\"need to get gas\")\n    tasks.gas = self.estimateGas.bind(self, cloneTxParams(txParams));\n  }\n\n  parallel(tasks, function (err, taskResults) {\n    if (err) return cb(err);\n    const result = {};\n    if (taskResults.gasPrice) result.gasPrice = taskResults.gasPrice;\n    if (taskResults.nonce) result.nonce = taskResults.nonce.result;\n    if (taskResults.gas) result.gas = taskResults.gas;\n    cb(null, extend(txParams, result));\n  });\n}; // util\n// we use this to clean any custom params from the txParams\n\n\nfunction cloneTxParams(txParams) {\n  return {\n    from: txParams.from,\n    to: txParams.to,\n    value: txParams.value,\n    data: txParams.data,\n    gas: txParams.gas,\n    gasPrice: txParams.gasPrice,\n    nonce: txParams.nonce\n  };\n}\n\nfunction toLowerCase(string) {\n  return string.toLowerCase();\n}\n\nfunction resemblesAddress(string) {\n  const fixed = ethUtil.addHexPrefix(string);\n  const isValid = ethUtil.isValidAddress(fixed);\n  return isValid;\n} // Returns true if resembles hex data\n// but definitely not a valid address.\n\n\nfunction resemblesData(string) {\n  const fixed = ethUtil.addHexPrefix(string);\n  const isValidAddress = ethUtil.isValidAddress(fixed);\n  return !isValidAddress && isValidHex(string);\n}\n\nfunction isValidHex(data) {\n  const isString = typeof data === 'string';\n  if (!isString) return false;\n  const isHexPrefixed = data.slice(0, 2) === '0x';\n  if (!isHexPrefixed) return false;\n  const nonPrefixed = data.slice(2);\n  const isValid = nonPrefixed.match(hexRegex);\n  return isValid;\n}\n\nfunction mustProvideInConstructor(methodName) {\n  return function (params, cb) {\n    cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide \"' + methodName + '\" fn in constructor options'));\n  };\n}","map":null,"metadata":{},"sourceType":"script"}