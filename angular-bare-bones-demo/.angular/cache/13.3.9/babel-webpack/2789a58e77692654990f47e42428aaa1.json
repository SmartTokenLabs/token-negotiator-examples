{"ast":null,"code":"\"use strict\";\n\nvar EC = require(\"elliptic\").ec;\n\nvar ec = new EC(\"secp256k1\");\nvar browserCrypto = global.crypto || global.msCrypto || {};\nvar subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n\nvar nodeCrypto = require('crypto');\n\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst ZERO32 = Buffer.alloc(32, 0);\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n\n  return privateKey.compare(ZERO32) > 0 && // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n} // Compare two buffers in constant time to prevent timing attacks.\n\n\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  var res = 0;\n\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\n\n\nfunction randomBytes(size) {\n  var arr = new Uint8Array(size);\n\n  if (typeof browserCrypto.getRandomValues === 'undefined') {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  } else {\n    browserCrypto.getRandomValues(arr);\n  }\n\n  return Buffer.from(arr);\n}\n\nfunction sha512(msg) {\n  return new Promise(function (resolve) {\n    var hash = nodeCrypto.createHash('sha512');\n    var result = hash.update(msg).digest();\n    resolve(new Uint8Array(result));\n  });\n}\n\nfunction getAes(op) {\n  return function (iv, key, data) {\n    return new Promise(function (resolve) {\n      if (subtle) {\n        var importAlgorithm = {\n          name: \"AES-CBC\"\n        };\n        var keyp = subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n        return keyp.then(function (cryptoKey) {\n          var encAlgorithm = {\n            name: \"AES-CBC\",\n            iv: iv\n          };\n          return subtle[op](encAlgorithm, cryptoKey, data);\n        }).then(function (result) {\n          resolve(Buffer.from(new Uint8Array(result)));\n        });\n      } else {\n        if (op === 'encrypt') {\n          var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n          let firstChunk = cipher.update(data);\n          let secondChunk = cipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        } else if (op === 'decrypt') {\n          var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n          let firstChunk = decipher.update(data);\n          let secondChunk = decipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n      }\n    });\n  };\n}\n\nvar aesCbcEncrypt = getAes(\"encrypt\");\nvar aesCbcDecrypt = getAes(\"decrypt\");\n\nfunction hmacSha256Sign(key, msg) {\n  return new Promise(function (resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var result = hmac.digest();\n    resolve(result);\n  });\n}\n\nfunction hmacSha256Verify(key, msg, sig) {\n  return new Promise(function (resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var expectedSig = hmac.digest();\n    resolve(equalConstTime(expectedSig, sig));\n  });\n}\n/**\n  * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n  * depending on your browser.\n  * @return {Buffer} A 32-byte private key.\n  * @function\n  */\n\n\nexports.generatePrivate = function () {\n  var privateKey = randomBytes(32);\n\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n\n  return privateKey;\n};\n\nvar getPublic = exports.getPublic = function (privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\"); // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n/**\n * Get compressed version of public key.\n */\n\n\nvar getPublicCompressed = exports.getPublicCompressed = function (privateKey) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\"); // See https://github.com/wanderer/secp256k1-node/issues/46\n\n  let compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n}; // NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\n\n\nexports.sign = function (privateKey, msg) {\n  return new Promise(function (resolve) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    resolve(Buffer.from(ec.sign(msg, privateKey, {\n      canonical: true\n    }).toDER()));\n  });\n};\n\nexports.verify = function (publicKey, msg, sig) {\n  return new Promise(function (resolve, reject) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n\n    if (publicKey.length === 65) {\n      assert(publicKey[0] === 4, \"Bad public key\");\n    }\n\n    if (publicKey.length === 33) {\n      assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n\n    if (ec.verify(msg, sig, publicKey)) {\n      resolve(null);\n    } else {\n      reject(new Error(\"Bad signature\"));\n    }\n  });\n};\n\nvar derive = exports.derive = function (privateKeyA, publicKeyB) {\n  return new Promise(function (resolve) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n\n    if (publicKeyB.length === 65) {\n      assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n\n    if (publicKeyB.length === 33) {\n      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n\n    var keyA = ec.keyFromPrivate(privateKeyA);\n    var keyB = ec.keyFromPublic(publicKeyB);\n    var Px = keyA.derive(keyB.getPublic()); // BN instance\n\n    resolve(Buffer.from(Px.toArray()));\n  });\n};\n\nexports.encrypt = function (publicKeyTo, msg, opts) {\n  opts = opts || {}; // Tmp variables to save context from flat promises;\n\n  var iv, ephemPublicKey, ciphertext, macKey;\n  return new Promise(function (resolve) {\n    var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32); // There is a very unlikely possibility that it is not a valid key\n\n    while (!isValidPrivateKey(ephemPrivateKey)) {\n      ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n\n    ephemPublicKey = getPublic(ephemPrivateKey);\n    resolve(derive(ephemPrivateKey, publicKeyTo));\n  }).then(function (Px) {\n    return sha512(Px);\n  }).then(function (hash) {\n    iv = opts.iv || randomBytes(16);\n    var encryptionKey = hash.slice(0, 32);\n    macKey = hash.slice(32);\n    return aesCbcEncrypt(iv, encryptionKey, msg);\n  }).then(function (data) {\n    ciphertext = data;\n    var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n    return hmacSha256Sign(macKey, dataToMac);\n  }).then(function (mac) {\n    return {\n      iv: iv,\n      ephemPublicKey: ephemPublicKey,\n      ciphertext: ciphertext,\n      mac: mac\n    };\n  });\n};\n\nexports.decrypt = function (privateKey, opts) {\n  // Tmp variable to save context from flat promises;\n  var encryptionKey;\n  return derive(privateKey, opts.ephemPublicKey).then(function (Px) {\n    return sha512(Px);\n  }).then(function (hash) {\n    encryptionKey = hash.slice(0, 32);\n    var macKey = hash.slice(32);\n    var dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n    return hmacSha256Verify(macKey, dataToMac, opts.mac);\n  }).then(function (macGood) {\n    assert(macGood, \"Bad MAC\");\n    return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n  }).then(function (msg) {\n    return Buffer.from(new Uint8Array(msg));\n  });\n};","map":null,"metadata":{},"sourceType":"script"}