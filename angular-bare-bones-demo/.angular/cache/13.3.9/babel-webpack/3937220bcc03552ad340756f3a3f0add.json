{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Ticket = void 0;\n\nconst AttestationCrypto_1 = require(\"./libs/AttestationCrypto\");\n\nconst DerUtility_1 = require(\"./libs/DerUtility\");\n\nconst AttestableObject_1 = require(\"./libs/AttestableObject\");\n\nconst utils_1 = require(\"./libs/utils\");\n\nconst SignedDevconTicket_1 = require(\"./asn1/shemas/SignedDevconTicket\");\n\nconst asn1_schema_1 = require(\"@peculiar/asn1-schema\");\n\nclass Ticket extends AttestableObject_1.AttestableObject {\n  // protected encoded: string;\n  constructor() {\n    super();\n    this.magicLinkURLPrefix = \"https://ticket.devcon.org/\";\n    this.isLegasy = false;\n  }\n\n  fromData(devconId, ticketId, ticketClass, keys) {\n    this.ticketId = ticketId;\n    this.ticketClass = ticketClass;\n    this.devconId = devconId;\n    this.keys = keys;\n    this.key = keys[devconId];\n  }\n\n  createWithCommitment(devconId, ticketId, ticketClass, commitment, signature, keys) {\n    this.fromData(devconId, ticketId, ticketClass, keys);\n    this.commitment = commitment;\n    this.signature = signature;\n    this.encoded = this.encodeSignedTicket(this.makeTicket());\n\n    if (!this.verify()) {\n      throw new Error(\"Ticket Signature is invalid\");\n    }\n  }\n\n  static createWithMail(mail, devconId, ticketId, ticketClass, keys, secret) {\n    let me = new this();\n    me.fromData(devconId, ticketId, ticketClass, keys);\n    let crypto = new AttestationCrypto_1.AttestationCrypto();\n    let signature;\n\n    try {\n      me.commitment = crypto.makeCommitment(mail, crypto.getType('mail'), secret);\n      let asn1Tic = me.makeTicket(); // signature = KeyPair.publicFromSubjectPublicKeyInfo( keys[me.devconId] ).signRawBytesWithEthereum(hexStringToArray(asn1Tic));\n\n      signature = me.key.signRawBytesWithEthereum((0, utils_1.hexStringToArray)(asn1Tic));\n    } catch (e) {\n      throw new Error(e);\n    }\n\n    me.createWithCommitment(devconId, ticketId, ticketClass, me.commitment, signature, keys);\n    return me;\n  }\n\n  makeTicket() {\n    let ticketId;\n\n    try {\n      const asBN = BigInt(this.ticketId);\n      ticketId = DerUtility_1.Asn1Der.encode('INTEGER', asBN);\n    } catch (e) {\n      ticketId = DerUtility_1.Asn1Der.encode('UTF8STRING', this.ticketId);\n    }\n\n    let ticket = DerUtility_1.Asn1Der.encode('UTF8STRING', this.devconId) + ticketId + DerUtility_1.Asn1Der.encode('INTEGER', this.ticketClass);\n\n    if (!this.isLegasy) {\n      ticket += DerUtility_1.Asn1Der.encode('OCTET_STRING', (0, utils_1.uint8tohex)(this.commitment));\n    }\n\n    return DerUtility_1.Asn1Der.encode('SEQUENCE_30', ticket);\n  }\n\n  encodeSignedTicket(ticket) {\n    if (this.isLegasy) {\n      ticket += DerUtility_1.Asn1Der.encode('OCTET_STRING', (0, utils_1.uint8tohex)(this.commitment));\n    }\n\n    ticket += DerUtility_1.Asn1Der.encode('BIT_STRING', this.signature);\n    return DerUtility_1.Asn1Der.encode('SEQUENCE_30', ticket);\n  }\n\n  getDerEncodingWithPK() {\n    let ticket = this.makeTicket();\n    let signedTicket = ticket + DerUtility_1.Asn1Der.encode('OCTET_STRING', (0, utils_1.uint8tohex)(this.commitment)) + this.key.getAsnDerPublic() + DerUtility_1.Asn1Der.encode('BIT_STRING', this.signature);\n    return DerUtility_1.Asn1Der.encode('SEQUENCE_30', signedTicket);\n  }\n\n  getDerEncoding() {\n    return this.encoded;\n  }\n\n  verify() {\n    return this.key.verifyBytesWithEthereum((0, utils_1.hexStringToArray)(this.makeTicket()), this.signature);\n  }\n\n  checkValidity() {\n    // The ticket is always valid on its own. It depends on which conference it is used\n    // and whether it has been revoked that decides if it can be used\n    return true;\n  }\n\n  getTicketId() {\n    return this.ticketId;\n  }\n\n  getTicketClass() {\n    return this.ticketClass;\n  }\n\n  getSignature() {\n    return this.signature;\n  }\n\n  static fromBase64(base64str, keys) {\n    let me = new this();\n    me.fromBytes((0, utils_1.base64ToUint8array)(base64str), keys);\n    return me;\n  }\n\n  fromBytes(bytes, keys) {\n    const signedDevconTicket = asn1_schema_1.AsnParser.parse(bytes, SignedDevconTicket_1.SignedDevconTicket);\n    let devconId = signedDevconTicket.ticket.devconId;\n\n    if (!keys || !keys[devconId]) {\n      throw new Error(\"Issuer key not defined.\");\n    }\n\n    this.key = keys[devconId];\n    let idAsNumber = signedDevconTicket.ticket.ticketIdNumber;\n    let ticketId = idAsNumber ? idAsNumber.toString() : signedDevconTicket.ticket.ticketIdString;\n    let ticketClassInt = signedDevconTicket.ticket.ticketClass;\n    let commitment;\n\n    if (signedDevconTicket.ticket.commitment) {\n      commitment = signedDevconTicket.ticket.commitment;\n    } else {\n      commitment = signedDevconTicket.commitment;\n      this.isLegasy = true;\n    }\n\n    let signature = signedDevconTicket.signatureValue;\n    this.createWithCommitment(devconId, ticketId, ticketClassInt, new Uint8Array(commitment), (0, utils_1.uint8tohex)(new Uint8Array(signature)), keys);\n  }\n\n  getCommitment() {\n    return this.commitment;\n  }\n\n  getKey() {\n    return this.key;\n  }\n\n  getUrlEncoding() {// TODO implement\n    // SubjectPublicKeyInfo keyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(this.publicKey);\n    // return URLUtility.encodeList(Arrays.asList(this.encoded, keyInfo.getPublicKeyData().getEncoded()));\n  }\n\n}\n\nexports.Ticket = Ticket; //# sourceMappingURL=Ticket.js.map","map":null,"metadata":{},"sourceType":"script"}