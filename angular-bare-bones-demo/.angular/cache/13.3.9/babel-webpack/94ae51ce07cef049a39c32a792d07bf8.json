{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SignedIdentifierAttestation = void 0;\n\nconst asn1_schema_1 = require(\"@peculiar/asn1-schema\");\n\nconst AttestationFramework_1 = require(\"../asn1/shemas/AttestationFramework\");\n\nconst KeyPair_1 = require(\"./KeyPair\");\n\nconst utils_1 = require(\"./utils\");\n\nconst DerUtility_1 = require(\"./DerUtility\");\n\nconst IdentifierAttestation_1 = require(\"./IdentifierAttestation\");\n\nconst config_1 = require(\"../config\");\n\nclass SignedIdentifierAttestation {\n  constructor() {}\n\n  static fromBytes(uint8data, attestorKeys) {\n    const myAttestation = asn1_schema_1.AsnParser.parse(uint8data, AttestationFramework_1.MyAttestation);\n    return this.fromASNType(myAttestation, attestorKeys, uint8data);\n  }\n\n  static fromASNType(myAttestation, attestorKeys, uint8data = new Uint8Array(0)) {\n    let me = new this();\n    me.uint8data = uint8data;\n    me.attestorKeys = attestorKeys;\n    let algorithmEncoded = myAttestation.signatureAlgorithm.algorithm;\n    me.att = IdentifierAttestation_1.IdentifierAttestation.fromBytes(myAttestation.signedInfo); // me.signature = myAttestation.signatureValue;\n\n    me.signature = (0, utils_1.uint8tohex)(new Uint8Array(myAttestation.signatureValue));\n\n    if (algorithmEncoded !== me.att.getSigningAlgorithm()) {\n      throw new Error(\"Algorithm specified is not consistent\");\n    }\n\n    me.constructorCheck();\n    return me;\n  }\n\n  static fromData(att, attestationSigningKey) {\n    let me = new this();\n    me.attestorKeys = attestationSigningKey;\n    me.att = att; // me.att.setSigningAlgorithm(SignedIdentifierAttestation.ECDSA_WITH_SHA256);\n    // me.signature = attestationSigningKey.signDeterministicSHA256( Array.from(me.att.getPrehash()));\n\n    me.signature = me.attestorKeys.signRawBytesWithEthereum(Array.from(me.att.getPrehash()));\n    me.constructorCheck();\n    return me;\n  }\n\n  verify() {\n    try {\n      let res = this.attestorKeys.verifyBytesWithEthereum((0, utils_1.hexStringToArray)(this.att.getDerEncoding()), this.signature);\n      return res;\n    } catch (e) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, e);\n      return false;\n    }\n  }\n\n  checkValidity() {\n    return this.getUnsignedAttestation().checkValidity();\n  }\n\n  getUnsignedAttestation() {\n    return this.att;\n  }\n\n  getDerEncoding() {\n    if (this.uint8data && this.uint8data.length) {\n      return (0, utils_1.uint8tohex)(new Uint8Array(this.uint8data));\n    } else {\n      return this.constructSignedAttestation(this.getUnsignedAttestation(), this.signature);\n    }\n  }\n\n  constructSignedAttestation(unsignedAtt, signature) {\n    let rawAtt = unsignedAtt.getPrehash();\n    let alg = DerUtility_1.Asn1Der.encode('OBJECT_ID', unsignedAtt.getSigningAlgorithm());\n    let res = (0, utils_1.uint8tohex)(rawAtt) + DerUtility_1.Asn1Der.encode('SEQUENCE_30', alg) + DerUtility_1.Asn1Der.encode('BIT_STRING', (0, utils_1.uint8tohex)(KeyPair_1.KeyPair.anySignatureToRawUint8(signature)));\n    return DerUtility_1.Asn1Der.encode('SEQUENCE_30', res);\n  }\n\n  constructorCheck() {\n    // TODO implement\n    // if (!(verificationKey instanceof ECPublicKeyParameters)) {\n    //     throw new UnsupportedOperationException(\"Attestations must be signed with ECDSA key\");\n    // }\n    if (!this.verify()) {\n      throw new Error(\"The signature is not valid\");\n    }\n  }\n\n}\n\nexports.SignedIdentifierAttestation = SignedIdentifierAttestation;\nSignedIdentifierAttestation.ECDSA_WITH_SHA256 = \"1.2.840.10045.4.3.2\"; //# sourceMappingURL=SignedIdentifierAttestation.js.map","map":null,"metadata":{},"sourceType":"script"}