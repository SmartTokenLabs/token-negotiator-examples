{"ast":null,"code":"/*!\n * MIT License\n * \n * Copyright (c) 2017-2022 Peculiar Ventures, LLC\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * \n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nconst ARRAY_BUFFER_NAME = \"[object ArrayBuffer]\";\n\nclass BufferSourceConverter {\n  static isArrayBuffer(data) {\n    return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;\n  }\n\n  static toArrayBuffer(data) {\n    if (this.isArrayBuffer(data)) {\n      return data;\n    }\n\n    if (data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n\n    return this.toUint8Array(data).slice().buffer;\n  }\n\n  static toUint8Array(data) {\n    return this.toView(data, Uint8Array);\n  }\n\n  static toView(data, type) {\n    if (data.constructor === type) {\n      return data;\n    }\n\n    if (this.isArrayBuffer(data)) {\n      return new type(data);\n    }\n\n    if (this.isArrayBufferView(data)) {\n      return new type(data.buffer, data.byteOffset, data.byteLength);\n    }\n\n    throw new TypeError(\"The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\");\n  }\n\n  static isBufferSource(data) {\n    return this.isArrayBufferView(data) || this.isArrayBuffer(data);\n  }\n\n  static isArrayBufferView(data) {\n    return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);\n  }\n\n  static isEqual(a, b) {\n    const aView = BufferSourceConverter.toUint8Array(a);\n    const bView = BufferSourceConverter.toUint8Array(b);\n\n    if (aView.length !== bView.byteLength) {\n      return false;\n    }\n\n    for (let i = 0; i < aView.length; i++) {\n      if (aView[i] !== bView[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static concat(...args) {\n    if (Array.isArray(args[0])) {\n      const buffers = args[0];\n      let size = 0;\n\n      for (const buffer of buffers) {\n        size += buffer.byteLength;\n      }\n\n      const res = new Uint8Array(size);\n      let offset = 0;\n\n      for (const buffer of buffers) {\n        const view = this.toUint8Array(buffer);\n        res.set(view, offset);\n        offset += view.length;\n      }\n\n      if (args[1]) {\n        return this.toView(res, args[1]);\n      }\n\n      return res.buffer;\n    } else {\n      return this.concat(args);\n    }\n  }\n\n}\n\nclass Utf8Converter {\n  static fromString(text) {\n    const s = unescape(encodeURIComponent(text));\n    const uintArray = new Uint8Array(s.length);\n\n    for (let i = 0; i < s.length; i++) {\n      uintArray[i] = s.charCodeAt(i);\n    }\n\n    return uintArray.buffer;\n  }\n\n  static toString(buffer) {\n    const buf = BufferSourceConverter.toUint8Array(buffer);\n    let encodedString = \"\";\n\n    for (let i = 0; i < buf.length; i++) {\n      encodedString += String.fromCharCode(buf[i]);\n    }\n\n    const decodedString = decodeURIComponent(escape(encodedString));\n    return decodedString;\n  }\n\n}\n\nclass Utf16Converter {\n  static toString(buffer, littleEndian = false) {\n    const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);\n    const dataView = new DataView(arrayBuffer);\n    let res = \"\";\n\n    for (let i = 0; i < arrayBuffer.byteLength; i += 2) {\n      const code = dataView.getUint16(i, littleEndian);\n      res += String.fromCharCode(code);\n    }\n\n    return res;\n  }\n\n  static fromString(text, littleEndian = false) {\n    const res = new ArrayBuffer(text.length * 2);\n    const dataView = new DataView(res);\n\n    for (let i = 0; i < text.length; i++) {\n      dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);\n    }\n\n    return res;\n  }\n\n}\n\nlet Convert = /*#__PURE__*/(() => {\n  class Convert {\n    static isHex(data) {\n      return typeof data === \"string\" && /^[a-z0-9]+$/i.test(data);\n    }\n\n    static isBase64(data) {\n      return typeof data === \"string\" && /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(data);\n    }\n\n    static isBase64Url(data) {\n      return typeof data === \"string\" && /^[a-zA-Z0-9-_]+$/i.test(data);\n    }\n\n    static ToString(buffer, enc = \"utf8\") {\n      const buf = BufferSourceConverter.toUint8Array(buffer);\n\n      switch (enc.toLowerCase()) {\n        case \"utf8\":\n          return this.ToUtf8String(buf);\n\n        case \"binary\":\n          return this.ToBinary(buf);\n\n        case \"hex\":\n          return this.ToHex(buf);\n\n        case \"base64\":\n          return this.ToBase64(buf);\n\n        case \"base64url\":\n          return this.ToBase64Url(buf);\n\n        case \"utf16le\":\n          return Utf16Converter.toString(buf, true);\n\n        case \"utf16\":\n        case \"utf16be\":\n          return Utf16Converter.toString(buf);\n\n        default:\n          throw new Error(`Unknown type of encoding '${enc}'`);\n      }\n    }\n\n    static FromString(str, enc = \"utf8\") {\n      if (!str) {\n        return new ArrayBuffer(0);\n      }\n\n      switch (enc.toLowerCase()) {\n        case \"utf8\":\n          return this.FromUtf8String(str);\n\n        case \"binary\":\n          return this.FromBinary(str);\n\n        case \"hex\":\n          return this.FromHex(str);\n\n        case \"base64\":\n          return this.FromBase64(str);\n\n        case \"base64url\":\n          return this.FromBase64Url(str);\n\n        case \"utf16le\":\n          return Utf16Converter.fromString(str, true);\n\n        case \"utf16\":\n        case \"utf16be\":\n          return Utf16Converter.fromString(str);\n\n        default:\n          throw new Error(`Unknown type of encoding '${enc}'`);\n      }\n    }\n\n    static ToBase64(buffer) {\n      const buf = BufferSourceConverter.toUint8Array(buffer);\n\n      if (typeof btoa !== \"undefined\") {\n        const binary = this.ToString(buf, \"binary\");\n        return btoa(binary);\n      } else {\n        return Buffer.from(buf).toString(\"base64\");\n      }\n    }\n\n    static FromBase64(base64) {\n      const formatted = this.formatString(base64);\n\n      if (!formatted) {\n        return new ArrayBuffer(0);\n      }\n\n      if (!Convert.isBase64(formatted)) {\n        throw new TypeError(\"Argument 'base64Text' is not Base64 encoded\");\n      }\n\n      if (typeof atob !== \"undefined\") {\n        return this.FromBinary(atob(formatted));\n      } else {\n        return new Uint8Array(Buffer.from(formatted, \"base64\")).buffer;\n      }\n    }\n\n    static FromBase64Url(base64url) {\n      const formatted = this.formatString(base64url);\n\n      if (!formatted) {\n        return new ArrayBuffer(0);\n      }\n\n      if (!Convert.isBase64Url(formatted)) {\n        throw new TypeError(\"Argument 'base64url' is not Base64Url encoded\");\n      }\n\n      return this.FromBase64(this.Base64Padding(formatted.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\")));\n    }\n\n    static ToBase64Url(data) {\n      return this.ToBase64(data).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n    }\n\n    static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n      switch (encoding) {\n        case \"ascii\":\n          return this.FromBinary(text);\n\n        case \"utf8\":\n          return Utf8Converter.fromString(text);\n\n        case \"utf16\":\n        case \"utf16be\":\n          return Utf16Converter.fromString(text);\n\n        case \"utf16le\":\n        case \"usc2\":\n          return Utf16Converter.fromString(text, true);\n\n        default:\n          throw new Error(`Unknown type of encoding '${encoding}'`);\n      }\n    }\n\n    static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n      switch (encoding) {\n        case \"ascii\":\n          return this.ToBinary(buffer);\n\n        case \"utf8\":\n          return Utf8Converter.toString(buffer);\n\n        case \"utf16\":\n        case \"utf16be\":\n          return Utf16Converter.toString(buffer);\n\n        case \"utf16le\":\n        case \"usc2\":\n          return Utf16Converter.toString(buffer, true);\n\n        default:\n          throw new Error(`Unknown type of encoding '${encoding}'`);\n      }\n    }\n\n    static FromBinary(text) {\n      const stringLength = text.length;\n      const resultView = new Uint8Array(stringLength);\n\n      for (let i = 0; i < stringLength; i++) {\n        resultView[i] = text.charCodeAt(i);\n      }\n\n      return resultView.buffer;\n    }\n\n    static ToBinary(buffer) {\n      const buf = BufferSourceConverter.toUint8Array(buffer);\n      let res = \"\";\n\n      for (let i = 0; i < buf.length; i++) {\n        res += String.fromCharCode(buf[i]);\n      }\n\n      return res;\n    }\n\n    static ToHex(buffer) {\n      const buf = BufferSourceConverter.toUint8Array(buffer);\n      const splitter = \"\";\n      const res = [];\n      const len = buf.length;\n\n      for (let i = 0; i < len; i++) {\n        const char = buf[i].toString(16).padStart(2, \"0\");\n        res.push(char);\n      }\n\n      return res.join(splitter);\n    }\n\n    static FromHex(hexString) {\n      let formatted = this.formatString(hexString);\n\n      if (!formatted) {\n        return new ArrayBuffer(0);\n      }\n\n      if (!Convert.isHex(formatted)) {\n        throw new TypeError(\"Argument 'hexString' is not HEX encoded\");\n      }\n\n      if (formatted.length % 2) {\n        formatted = `0${formatted}`;\n      }\n\n      const res = new Uint8Array(formatted.length / 2);\n\n      for (let i = 0; i < formatted.length; i = i + 2) {\n        const c = formatted.slice(i, i + 2);\n        res[i / 2] = parseInt(c, 16);\n      }\n\n      return res.buffer;\n    }\n\n    static ToUtf16String(buffer, littleEndian = false) {\n      return Utf16Converter.toString(buffer, littleEndian);\n    }\n\n    static FromUtf16String(text, littleEndian = false) {\n      return Utf16Converter.fromString(text, littleEndian);\n    }\n\n    static Base64Padding(base64) {\n      const padCount = 4 - base64.length % 4;\n\n      if (padCount < 4) {\n        for (let i = 0; i < padCount; i++) {\n          base64 += \"=\";\n        }\n      }\n\n      return base64;\n    }\n\n    static formatString(data) {\n      return (data === null || data === void 0 ? void 0 : data.replace(/[\\n\\r\\t ]/g, \"\")) || \"\";\n    }\n\n  }\n\n  Convert.DEFAULT_UTF8_ENCODING = \"utf8\";\n  return Convert;\n})();\n\nfunction assign(target, ...sources) {\n  const res = arguments[0];\n\n  for (let i = 1; i < arguments.length; i++) {\n    const obj = arguments[i];\n\n    for (const prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n\n  return res;\n}\n\nfunction combine(...buf) {\n  const totalByteLength = buf.map(item => item.byteLength).reduce((prev, cur) => prev + cur);\n  const res = new Uint8Array(totalByteLength);\n  let currentPos = 0;\n  buf.map(item => new Uint8Array(item)).forEach(arr => {\n    for (const item2 of arr) {\n      res[currentPos++] = item2;\n    }\n  });\n  return res.buffer;\n}\n\nfunction isEqual(bytes1, bytes2) {\n  if (!(bytes1 && bytes2)) {\n    return false;\n  }\n\n  if (bytes1.byteLength !== bytes2.byteLength) {\n    return false;\n  }\n\n  const b1 = new Uint8Array(bytes1);\n  const b2 = new Uint8Array(bytes2);\n\n  for (let i = 0; i < bytes1.byteLength; i++) {\n    if (b1[i] !== b2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.BufferSourceConverter = BufferSourceConverter;\nexports.Convert = Convert;\nexports.assign = assign;\nexports.combine = combine;\nexports.isEqual = isEqual;","map":null,"metadata":{},"sourceType":"script"}