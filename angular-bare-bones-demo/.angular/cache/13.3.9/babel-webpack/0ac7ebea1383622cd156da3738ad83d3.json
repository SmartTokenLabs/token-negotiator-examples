{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AttestationRequest = void 0;\n\nconst Point_1 = require(\"./Point\");\n\nconst DerUtility_1 = require(\"./DerUtility\");\n\nconst utils_1 = require(\"./utils\");\n\nconst AttestationCrypto_1 = require(\"./AttestationCrypto\");\n\nconst FullProofOfExponent_1 = require(\"./FullProofOfExponent\");\n\nconst asn1_schema_1 = require(\"@peculiar/asn1-schema\");\n\nconst AttestationRequest_1 = require(\"../asn1/shemas/AttestationRequest\");\n\nconst config_1 = require(\"../config\");\n\nclass AttestationRequest {\n  constructor() {}\n\n  static fromData(type, pok) {\n    let me = new this();\n    me.type = type;\n    me.pok = pok;\n\n    if (!me.verify()) {\n      throw new Error(\"The proof is not valid\");\n    }\n\n    return me;\n  }\n\n  getDerEncoding() {\n    let res = DerUtility_1.Asn1Der.encode('INTEGER', this.type) + this.pok.getDerEncoding();\n    return DerUtility_1.Asn1Der.encode('SEQUENCE_30', res);\n  }\n\n  static fromBytes(asn1) {\n    let me = new this();\n    let identifier;\n\n    try {\n      identifier = asn1_schema_1.AsnParser.parse(asn1, AttestationRequest_1.Identifier);\n      me.type = identifier.type;\n    } catch (e) {\n      throw new Error('Cant parse AttestationRequest Identifier');\n    }\n\n    try {\n      let riddleEnc = new Uint8Array(identifier.proof.riddle);\n      let challengeEnc = new Uint8Array(identifier.proof.challengePoint);\n      let tPointEnc = new Uint8Array(identifier.proof.responseValue);\n      let nonce = new Uint8Array(identifier.proof.nonce);\n      let riddle = Point_1.Point.decodeFromHex((0, utils_1.uint8tohex)(riddleEnc), Point_1.CURVE_BN256);\n      let challenge = (0, utils_1.uint8ToBn)(challengeEnc);\n      let tPoint = Point_1.Point.decodeFromHex((0, utils_1.uint8tohex)(tPointEnc), Point_1.CURVE_BN256);\n      me.pok = FullProofOfExponent_1.FullProofOfExponent.fromData(riddle, tPoint, challenge, nonce);\n    } catch (e) {\n      throw new Error('Cant create FullProofOfExponent');\n    }\n\n    if (!me.verify()) {\n      throw new Error(\"Could not verify the proof\");\n    }\n\n    (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, 'proof OK');\n    return me;\n  }\n\n  verify() {\n    let AttestationCryptoInstance = new AttestationCrypto_1.AttestationCrypto();\n\n    if (!AttestationCryptoInstance.verifyFullProof(this.pok)) {\n      return false;\n    }\n\n    (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, 'VerifyAttestationRequestProof OK');\n    return true;\n  }\n\n  getPok() {\n    return this.pok;\n  }\n\n  getType() {\n    return this.type;\n  }\n\n  getAsn() {\n    const pok = this.getPok().getAsnType();\n    const identity = new AttestationRequest_1.Identifier();\n    identity.type = this.getType();\n    identity.proof = pok;\n    return identity;\n  }\n\n  getAsnEncoded() {\n    return asn1_schema_1.AsnSerializer.serialize(this.getAsn());\n  }\n\n}\n\nexports.AttestationRequest = AttestationRequest; //# sourceMappingURL=AttestationRequest.js.map","map":null,"metadata":{},"sourceType":"script"}