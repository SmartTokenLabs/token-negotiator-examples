{"ast":null,"code":"import _asyncToGenerator from \"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as crypto from \"@walletconnect/crypto\";\nimport * as encoding from \"@walletconnect/encoding\";\nimport { convertArrayBufferToBuffer, convertBufferToArrayBuffer } from \"@walletconnect/utils\";\nexport function generateKey(_x) {\n  return _generateKey.apply(this, arguments);\n}\n\nfunction _generateKey() {\n  _generateKey = _asyncToGenerator(function* (length) {\n    const _length = (length || 256) / 8;\n\n    const bytes = crypto.randomBytes(_length);\n    const result = convertBufferToArrayBuffer(encoding.arrayToBuffer(bytes));\n    return result;\n  });\n  return _generateKey.apply(this, arguments);\n}\n\nexport function verifyHmac(_x2, _x3) {\n  return _verifyHmac.apply(this, arguments);\n}\n\nfunction _verifyHmac() {\n  _verifyHmac = _asyncToGenerator(function* (payload, key) {\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const hmac = encoding.hexToArray(payload.hmac);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const chmac = yield crypto.hmacSha256Sign(key, unsigned);\n    const chmacHex = encoding.arrayToHex(chmac, false);\n\n    if (encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex)) {\n      return true;\n    }\n\n    return false;\n  });\n  return _verifyHmac.apply(this, arguments);\n}\n\nexport function encrypt(_x4, _x5, _x6) {\n  return _encrypt.apply(this, arguments);\n}\n\nfunction _encrypt() {\n  _encrypt = _asyncToGenerator(function* (data, key, providedIv) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n\n    const ivArrayBuffer = providedIv || (yield generateKey(128));\n    const iv = encoding.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));\n    const ivHex = encoding.arrayToHex(iv, false);\n    const contentString = JSON.stringify(data);\n    const content = encoding.utf8ToArray(contentString);\n    const cipherText = yield crypto.aesCbcEncrypt(iv, _key, content);\n    const cipherTextHex = encoding.arrayToHex(cipherText, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const hmac = yield crypto.hmacSha256Sign(_key, unsigned);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    return {\n      data: cipherTextHex,\n      hmac: hmacHex,\n      iv: ivHex\n    };\n  });\n  return _encrypt.apply(this, arguments);\n}\n\nexport function decrypt(_x7, _x8) {\n  return _decrypt.apply(this, arguments);\n} //# sourceMappingURL=index.js.map\n\nfunction _decrypt() {\n  _decrypt = _asyncToGenerator(function* (payload, key) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n\n    if (!_key) {\n      throw new Error(\"Missing key: required for decryption\");\n    }\n\n    const verified = yield verifyHmac(payload, _key);\n\n    if (!verified) {\n      return null;\n    }\n\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const buffer = yield crypto.aesCbcDecrypt(iv, _key, cipherText);\n    const utf8 = encoding.arrayToUtf8(buffer);\n    let data;\n\n    try {\n      data = JSON.parse(utf8);\n    } catch (error) {\n      return null;\n    }\n\n    return data;\n  });\n  return _decrypt.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}