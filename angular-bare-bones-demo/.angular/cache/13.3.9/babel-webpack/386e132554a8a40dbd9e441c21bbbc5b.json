{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractLinkedAttestation = void 0;\n\nconst asn1_schema_1 = require(\"@peculiar/asn1-schema\");\n\nconst SignedLinkedAttestation_1 = require(\"../asn1/shemas/SignedLinkedAttestation\");\n\nconst utils_1 = require(\"../libs/utils\");\n\nconst ethers_1 = require(\"ethers\");\n\nconst AuthenticationFramework_1 = require(\"../asn1/shemas/AuthenticationFramework\");\n\nclass AbstractLinkedAttestation {\n  fromObject(attestation) {\n    this.linkedAttestation = attestation;\n  }\n\n  fromBytes(asnBytes) {\n    this.linkedAttestation = asn1_schema_1.AsnParser.parse(asnBytes, SignedLinkedAttestation_1.SignedLinkedAttestation);\n  }\n\n  fromBase64(base64Attestation) {\n    this.fromBytes((0, utils_1.base64ToUint8array)(base64Attestation));\n  }\n\n  getAttestationData() {\n    return this.linkedAttestation.attestation[this.TYPE];\n  }\n\n  getSubjectPublicKey() {\n    return this.getAttestationData().subjectPublicKey;\n  }\n\n  getEncoded() {\n    return new Uint8Array(asn1_schema_1.AsnSerializer.serialize(this.linkedAttestation));\n  }\n\n  getBase64() {\n    return (0, utils_1.uint8arrayToBase64)(this.getEncoded());\n  }\n\n  sign(attestorKeys) {\n    const encodedAttest = asn1_schema_1.AsnSerializer.serialize(this.linkedAttestation.attestation[this.TYPE]);\n    this.linkedAttestation.signingAlgorithm = new AuthenticationFramework_1.AlgorithmIdentifierASN();\n    this.linkedAttestation.signingAlgorithm.algorithm = \"1.2.840.10045.4.2\"; // Our own internal identifier for ECDSA with keccak256\n\n    this.linkedAttestation.signatureValue = (0, utils_1.hexStringToUint8)(attestorKeys.signRawBytesWithEthereum(Array.from(new Uint8Array(encodedAttest))));\n  }\n\n  verify(attestorKeys) {\n    const encAttestation = asn1_schema_1.AsnSerializer.serialize(this.getAttestationData());\n    let payloadHash = (0, utils_1.hexStringToUint8)(ethers_1.ethers.utils.keccak256(new Uint8Array(encAttestation))); // TODO: Optionally use address like smart contract validation\n    //let address = ethers.utils.recoverAddress(payloadHash, ethers.utils.splitSignature(new Uint8Array(this.linkedAttestation.signatureValue)));\n\n    let pubKey = ethers_1.ethers.utils.recoverPublicKey(payloadHash, ethers_1.ethers.utils.splitSignature(new Uint8Array(this.linkedAttestation.signatureValue)));\n    if (pubKey.substring(2) !== attestorKeys.getPublicKeyAsHexStr()) throw new Error(\"Attestor public key does not match, expected \" + attestorKeys.getPublicKeyAsHexStr() + \" got \" + pubKey.substring(2));\n    let now = Math.round(Date.now() / 1000);\n    let data = this.getAttestationData();\n    if (data.validity.notBefore > now) throw new Error(\"Linked attestation is not yet valid\");\n    if (data.validity.notAfter < now) throw new Error(\"Linked attestation has expired\");\n  }\n\n}\n\nexports.AbstractLinkedAttestation = AbstractLinkedAttestation; //# sourceMappingURL=AbstractLinkedAttestation.js.map","map":null,"metadata":{},"sourceType":"script"}