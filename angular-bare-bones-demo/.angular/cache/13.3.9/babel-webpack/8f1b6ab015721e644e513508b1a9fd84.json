{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst EthQuery = require('eth-query');\n\nconst pify = require('pify');\n\nconst BaseFilterWithHistory = require('./base-filter-history');\n\nconst {\n  bnToHex,\n  hexToInt,\n  incrementHexInt,\n  minBlockRef,\n  blockRefIsNumber\n} = require('./hexUtils');\n\nclass LogFilter extends BaseFilterWithHistory {\n  constructor({\n    provider,\n    params\n  }) {\n    super();\n    this.type = 'log';\n    this.ethQuery = new EthQuery(provider);\n    this.params = Object.assign({\n      fromBlock: 'latest',\n      toBlock: 'latest',\n      address: undefined,\n      topics: []\n    }, params); // normalize address parameter\n\n    if (this.params.address) {\n      // ensure array\n      if (!Array.isArray(this.params.address)) {\n        this.params.address = [this.params.address];\n      } // ensure lowercase\n\n\n      this.params.address = this.params.address.map(address => address.toLowerCase());\n    }\n  }\n\n  initialize({\n    currentBlock\n  }) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // resolve params.fromBlock\n      let fromBlock = _this.params.fromBlock;\n      if (['latest', 'pending'].includes(fromBlock)) fromBlock = currentBlock;\n      if ('earliest' === fromBlock) fromBlock = '0x0';\n      _this.params.fromBlock = fromBlock; // set toBlock for initial lookup\n\n      const toBlock = minBlockRef(_this.params.toBlock, currentBlock);\n      const params = Object.assign({}, _this.params, {\n        toBlock\n      }); // fetch logs and add to results\n\n      const newLogs = yield _this._fetchLogs(params);\n\n      _this.addInitialResults(newLogs);\n    })();\n  }\n\n  update({\n    oldBlock,\n    newBlock\n  }) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // configure params for this update\n      const toBlock = newBlock;\n      let fromBlock; // oldBlock is empty on first sync\n\n      if (oldBlock) {\n        fromBlock = incrementHexInt(oldBlock);\n      } else {\n        fromBlock = newBlock;\n      } // fetch logs\n\n\n      const params = Object.assign({}, _this2.params, {\n        fromBlock,\n        toBlock\n      });\n      const newLogs = yield _this2._fetchLogs(params);\n      const matchingLogs = newLogs.filter(log => _this2.matchLog(log)); // add to results\n\n      _this2.addResults(matchingLogs);\n    })();\n  }\n\n  _fetchLogs(params) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const newLogs = yield pify(cb => _this3.ethQuery.getLogs(params, cb))(); // add to results\n\n      return newLogs;\n    })();\n  }\n\n  matchLog(log) {\n    // check if block number in bounds:\n    if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber)) return false;\n    if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber)) return false; // address is correct:\n\n    const normalizedLogAddress = log.address && log.address.toLowerCase();\n    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress)) return false; // topics match:\n    // topics are position-dependant\n    // topics can be nested to represent `or` [[a || b], c]\n    // topics can be null, representing a wild card for that position\n\n    const topicsMatch = this.params.topics.every((topicPattern, index) => {\n      // pattern is longer than actual topics\n      let logTopic = log.topics[index];\n      if (!logTopic) return false;\n      logTopic = logTopic.toLowerCase(); // normalize subTopics\n\n      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern]; // check for wild card\n\n      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);\n      if (subtopicsIncludeWildcard) return true;\n      subtopicsToMatch = subtopicsToMatch.map(topic => topic.toLowerCase()); // check each possible matching topic\n\n      const topicDoesMatch = subtopicsToMatch.includes(logTopic);\n      return topicDoesMatch;\n    });\n    return topicsMatch;\n  }\n\n}\n\nmodule.exports = LogFilter;","map":null,"metadata":{},"sourceType":"script"}