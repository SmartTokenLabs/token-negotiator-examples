{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst SafeEventEmitter = require('@metamask/safe-event-emitter').default;\n\nconst createScaffoldMiddleware = require('eth-json-rpc-middleware/scaffold');\n\nconst {\n  createAsyncMiddleware\n} = require('json-rpc-engine');\n\nconst createFilterMiddleware = require('./index.js');\n\nconst {\n  unsafeRandomBytes,\n  incrementHexInt\n} = require('./hexUtils.js');\n\nconst getBlocksForRange = require('./getBlocksForRange.js');\n\nmodule.exports = createSubscriptionMiddleware;\n\nfunction createSubscriptionMiddleware({\n  blockTracker,\n  provider\n}) {\n  // state and utilities for handling subscriptions\n  const subscriptions = {};\n  const filterManager = createFilterMiddleware({\n    blockTracker,\n    provider\n  }); // internal flag\n\n  let isDestroyed = false; // create subscriptionManager api object\n\n  const events = new SafeEventEmitter();\n  const middleware = createScaffoldMiddleware({\n    eth_subscribe: createAsyncMiddleware(subscribe),\n    eth_unsubscribe: createAsyncMiddleware(unsubscribe)\n  });\n  middleware.destroy = destroy;\n  return {\n    events,\n    middleware\n  };\n\n  function subscribe(_x, _x2) {\n    return _subscribe.apply(this, arguments);\n  }\n\n  function _subscribe() {\n    _subscribe = _asyncToGenerator(function* (req, res) {\n      if (isDestroyed) throw new Error('SubscriptionManager - attempting to use after destroying');\n      const subscriptionType = req.params[0]; // subId is 16 byte hex string\n\n      const subId = unsafeRandomBytes(16); // create sub\n\n      let sub;\n\n      switch (subscriptionType) {\n        case 'newHeads':\n          sub = createSubNewHeads({\n            subId\n          });\n          break;\n\n        case 'logs':\n          const filterParams = req.params[1];\n          const filter = yield filterManager.newLogFilter(filterParams);\n          sub = createSubFromFilter({\n            subId,\n            filter\n          });\n          break;\n\n        default:\n          throw new Error(`SubscriptionManager - unsupported subscription type \"${subscriptionType}\"`);\n      }\n\n      subscriptions[subId] = sub;\n      res.result = subId;\n      return;\n\n      function createSubNewHeads({\n        subId\n      }) {\n        const sub = {\n          type: subscriptionType,\n          destroy: function () {\n            var _ref = _asyncToGenerator(function* () {\n              blockTracker.removeListener('sync', sub.update);\n            });\n\n            return function destroy() {\n              return _ref.apply(this, arguments);\n            };\n          }(),\n          update: function () {\n            var _ref2 = _asyncToGenerator(function* ({\n              oldBlock,\n              newBlock\n            }) {\n              // for newHeads\n              const toBlock = newBlock;\n              const fromBlock = incrementHexInt(oldBlock);\n              const rawBlocks = yield getBlocksForRange({\n                provider,\n                fromBlock,\n                toBlock\n              });\n              const results = rawBlocks.map(normalizeBlock);\n              results.forEach(value => {\n                _emitSubscriptionResult(subId, value);\n              });\n            });\n\n            return function update(_x5) {\n              return _ref2.apply(this, arguments);\n            };\n          }()\n        }; // check for subscription updates on new block\n\n        blockTracker.on('sync', sub.update);\n        return sub;\n      }\n\n      function createSubFromFilter({\n        subId,\n        filter\n      }) {\n        filter.on('update', result => _emitSubscriptionResult(subId, result));\n        const sub = {\n          type: subscriptionType,\n          destroy: function () {\n            var _ref3 = _asyncToGenerator(function* () {\n              return yield filterManager.uninstallFilter(filter.idHex);\n            });\n\n            return function destroy() {\n              return _ref3.apply(this, arguments);\n            };\n          }()\n        };\n        return sub;\n      }\n    });\n    return _subscribe.apply(this, arguments);\n  }\n\n  function unsubscribe(_x3, _x4) {\n    return _unsubscribe.apply(this, arguments);\n  }\n\n  function _unsubscribe() {\n    _unsubscribe = _asyncToGenerator(function* (req, res) {\n      if (isDestroyed) throw new Error('SubscriptionManager - attempting to use after destroying');\n      const id = req.params[0];\n      const subscription = subscriptions[id]; // if missing, return \"false\" to indicate it was not removed\n\n      if (!subscription) {\n        res.result = false;\n        return;\n      } // cleanup subscription\n\n\n      delete subscriptions[id];\n      yield subscription.destroy();\n      res.result = true;\n    });\n    return _unsubscribe.apply(this, arguments);\n  }\n\n  function _emitSubscriptionResult(filterIdHex, value) {\n    events.emit('notification', {\n      jsonrpc: '2.0',\n      method: 'eth_subscription',\n      params: {\n        subscription: filterIdHex,\n        result: value\n      }\n    });\n  }\n\n  function destroy() {\n    events.removeAllListeners();\n\n    for (const id in subscriptions) {\n      subscriptions[id].destroy();\n      delete subscriptions[id];\n    }\n\n    isDestroyed = true;\n  }\n}\n\nfunction normalizeBlock(block) {\n  return {\n    hash: block.hash,\n    parentHash: block.parentHash,\n    sha3Uncles: block.sha3Uncles,\n    miner: block.miner,\n    stateRoot: block.stateRoot,\n    transactionsRoot: block.transactionsRoot,\n    receiptsRoot: block.receiptsRoot,\n    logsBloom: block.logsBloom,\n    difficulty: block.difficulty,\n    number: block.number,\n    gasLimit: block.gasLimit,\n    gasUsed: block.gasUsed,\n    nonce: block.nonce,\n    mixHash: block.mixHash,\n    timestamp: block.timestamp,\n    extraData: block.extraData\n  };\n}","map":null,"metadata":{},"sourceType":"script"}