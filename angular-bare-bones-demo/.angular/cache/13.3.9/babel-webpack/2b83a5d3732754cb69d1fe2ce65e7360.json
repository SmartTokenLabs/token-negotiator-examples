{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FullProofOfExponent = void 0;\n\nconst Point_1 = require(\"./Point\");\n\nconst ProofOfExponentASN_1 = require(\"../asn1/shemas/ProofOfExponentASN\");\n\nconst asn1_schema_1 = require(\"@peculiar/asn1-schema\");\n\nconst utils_1 = require(\"./utils\");\n\nconst DerUtility_1 = require(\"./DerUtility\");\n\nconst UsageProofOfExponent_1 = require(\"./UsageProofOfExponent\");\n\nclass FullProofOfExponent {\n  constructor() {}\n\n  static fromData(riddle, tPoint, challengeResponse, nonce = new Uint8Array([])) {\n    let me = new this();\n    me.riddle = riddle;\n    me.tPoint = tPoint;\n    me.challengeResponse = challengeResponse;\n    me.nonce = nonce;\n    me.encoding = me.makeEncoding(riddle, tPoint, challengeResponse, nonce);\n    return me;\n  }\n\n  static fromBytes(uint8data) {\n    let proof = asn1_schema_1.AsnParser.parse(uint8data, ProofOfExponentASN_1.Proof);\n    return this.fromASNType(proof);\n  }\n\n  static fromASNType(proof) {\n    let riddleEnc = new Uint8Array(proof.riddle);\n    let riddle = Point_1.Point.decodeFromUint8(riddleEnc, Point_1.CURVE_BN256);\n    let challengeEnc = new Uint8Array(proof.challengePoint);\n    let challengeResponse = (0, utils_1.uint8ToBn)(challengeEnc);\n    let tPointEnc = new Uint8Array(proof.responseValue);\n    let tPoint = Point_1.Point.decodeFromUint8(tPointEnc, Point_1.CURVE_BN256);\n    let nonce = new Uint8Array(proof.nonce);\n    return this.fromData(riddle, tPoint, challengeResponse, nonce);\n  }\n\n  static fromBase64(base64DerEncoded) {\n    return FullProofOfExponent.fromBytes((0, utils_1.base64ToUint8array)(base64DerEncoded));\n  }\n\n  makeEncoding(riddle, tPoint, challengeResponse, nonce = new Uint8Array([])) {\n    let proof = DerUtility_1.Asn1Der.encode('OCTET_STRING', (0, utils_1.uint8tohex)(riddle.getEncoded())) + DerUtility_1.Asn1Der.encode('OCTET_STRING', challengeResponse.toString(16)) + DerUtility_1.Asn1Der.encode('OCTET_STRING', (0, utils_1.uint8tohex)(tPoint.getEncoded())) + DerUtility_1.Asn1Der.encode('OCTET_STRING', (0, utils_1.uint8tohex)(nonce));\n    return DerUtility_1.Asn1Der.encode('SEQUENCE_30', proof);\n  }\n\n  getRiddle() {\n    return this.riddle;\n  }\n\n  getPoint() {\n    return this.tPoint;\n  }\n\n  getChallengeResponse() {\n    return this.challengeResponse;\n  }\n\n  getNonce() {\n    return this.nonce;\n  }\n\n  getUsageProofOfExponent() {\n    return UsageProofOfExponent_1.UsageProofOfExponent.fromData(this.tPoint, this.challengeResponse, this.nonce);\n  }\n\n  getDerEncoding() {\n    return this.encoding;\n  }\n\n  getAsnType() {\n    const proof = new ProofOfExponentASN_1.Proof();\n    proof.nonce = this.getNonce();\n    proof.challengePoint = (0, utils_1.bnToUint8)(this.getChallengeResponse());\n    proof.riddle = this.getRiddle().getEncoded();\n    proof.responseValue = this.getPoint().getEncoded();\n    return proof;\n  }\n\n}\n\nexports.FullProofOfExponent = FullProofOfExponent; //# sourceMappingURL=FullProofOfExponent.js.map","map":null,"metadata":{},"sourceType":"script"}