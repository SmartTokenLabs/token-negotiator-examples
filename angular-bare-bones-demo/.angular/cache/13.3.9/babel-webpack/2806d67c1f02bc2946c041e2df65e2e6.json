{"ast":null,"code":"/*!\n Copyright (c) Peculiar Ventures, LLC\n*/\nfunction getUTCDate(date) {\n  return new Date(date.getTime() + date.getTimezoneOffset() * 60000);\n}\n\nfunction getParametersValue(parameters, name, defaultValue) {\n  var _a;\n\n  if (parameters instanceof Object === false) {\n    return defaultValue;\n  }\n\n  return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;\n}\n\nfunction bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = inputBuffer.byteLength - inputOffset, insertSpace = false) {\n  let result = \"\";\n\n  for (const item of new Uint8Array(inputBuffer, inputOffset, inputLength)) {\n    const str = item.toString(16).toUpperCase();\n\n    if (str.length === 1) {\n      result += \"0\";\n    }\n\n    result += str;\n\n    if (insertSpace) {\n      result += \" \";\n    }\n  }\n\n  return result.trim();\n}\n\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\n  if (!(inputBuffer instanceof ArrayBuffer)) {\n    baseBlock.error = \"Wrong parameter: inputBuffer must be \\\"ArrayBuffer\\\"\";\n    return false;\n  }\n\n  if (!inputBuffer.byteLength) {\n    baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\n    return false;\n  }\n\n  if (inputOffset < 0) {\n    baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\n    return false;\n  }\n\n  if (inputLength < 0) {\n    baseBlock.error = \"Wrong parameter: inputLength less than zero\";\n    return false;\n  }\n\n  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {\n    baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n    return false;\n  }\n\n  return true;\n}\n\nfunction utilFromBase(inputBuffer, inputBase) {\n  let result = 0;\n\n  if (inputBuffer.length === 1) {\n    return inputBuffer[0];\n  }\n\n  for (let i = inputBuffer.length - 1; i >= 0; i--) {\n    result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);\n  }\n\n  return result;\n}\n\nfunction utilToBase(value, base, reserved = -1) {\n  const internalReserved = reserved;\n  let internalValue = value;\n  let result = 0;\n  let biggest = Math.pow(2, base);\n\n  for (let i = 1; i < 8; i++) {\n    if (value < biggest) {\n      let retBuf;\n\n      if (internalReserved < 0) {\n        retBuf = new ArrayBuffer(i);\n        result = i;\n      } else {\n        if (internalReserved < i) {\n          return new ArrayBuffer(0);\n        }\n\n        retBuf = new ArrayBuffer(internalReserved);\n        result = internalReserved;\n      }\n\n      const retView = new Uint8Array(retBuf);\n\n      for (let j = i - 1; j >= 0; j--) {\n        const basis = Math.pow(2, j * base);\n        retView[result - j - 1] = Math.floor(internalValue / basis);\n        internalValue -= retView[result - j - 1] * basis;\n      }\n\n      return retBuf;\n    }\n\n    biggest *= Math.pow(2, base);\n  }\n\n  return new ArrayBuffer(0);\n}\n\nfunction utilConcatBuf(...buffers) {\n  let outputLength = 0;\n  let prevLength = 0;\n\n  for (const buffer of buffers) {\n    outputLength += buffer.byteLength;\n  }\n\n  const retBuf = new ArrayBuffer(outputLength);\n  const retView = new Uint8Array(retBuf);\n\n  for (const buffer of buffers) {\n    retView.set(new Uint8Array(buffer), prevLength);\n    prevLength += buffer.byteLength;\n  }\n\n  return retBuf;\n}\n\nfunction utilConcatView(...views) {\n  let outputLength = 0;\n  let prevLength = 0;\n\n  for (const view of views) {\n    outputLength += view.length;\n  }\n\n  const retBuf = new ArrayBuffer(outputLength);\n  const retView = new Uint8Array(retBuf);\n\n  for (const view of views) {\n    retView.set(view, prevLength);\n    prevLength += view.length;\n  }\n\n  return retView;\n}\n\nfunction utilDecodeTC() {\n  const buf = new Uint8Array(this.valueHex);\n\n  if (this.valueHex.byteLength >= 2) {\n    const condition1 = buf[0] === 0xFF && buf[1] & 0x80;\n    const condition2 = buf[0] === 0x00 && (buf[1] & 0x80) === 0x00;\n\n    if (condition1 || condition2) {\n      this.warnings.push(\"Needlessly long format\");\n    }\n  }\n\n  const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\n  const bigIntView = new Uint8Array(bigIntBuffer);\n\n  for (let i = 0; i < this.valueHex.byteLength; i++) {\n    bigIntView[i] = 0;\n  }\n\n  bigIntView[0] = buf[0] & 0x80;\n  const bigInt = utilFromBase(bigIntView, 8);\n  const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\n  const smallIntView = new Uint8Array(smallIntBuffer);\n\n  for (let j = 0; j < this.valueHex.byteLength; j++) {\n    smallIntView[j] = buf[j];\n  }\n\n  smallIntView[0] &= 0x7F;\n  const smallInt = utilFromBase(smallIntView, 8);\n  return smallInt - bigInt;\n}\n\nfunction utilEncodeTC(value) {\n  const modValue = value < 0 ? value * -1 : value;\n  let bigInt = 128;\n\n  for (let i = 1; i < 8; i++) {\n    if (modValue <= bigInt) {\n      if (value < 0) {\n        const smallInt = bigInt - modValue;\n        const retBuf = utilToBase(smallInt, 8, i);\n        const retView = new Uint8Array(retBuf);\n        retView[0] |= 0x80;\n        return retBuf;\n      }\n\n      let retBuf = utilToBase(modValue, 8, i);\n      let retView = new Uint8Array(retBuf);\n\n      if (retView[0] & 0x80) {\n        const tempBuf = retBuf.slice(0);\n        const tempView = new Uint8Array(tempBuf);\n        retBuf = new ArrayBuffer(retBuf.byteLength + 1);\n        retView = new Uint8Array(retBuf);\n\n        for (let k = 0; k < tempBuf.byteLength; k++) {\n          retView[k + 1] = tempView[k];\n        }\n\n        retView[0] = 0x00;\n      }\n\n      return retBuf;\n    }\n\n    bigInt *= Math.pow(2, 8);\n  }\n\n  return new ArrayBuffer(0);\n}\n\nfunction isEqualBuffer(inputBuffer1, inputBuffer2) {\n  if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {\n    return false;\n  }\n\n  const view1 = new Uint8Array(inputBuffer1);\n  const view2 = new Uint8Array(inputBuffer2);\n\n  for (let i = 0; i < view1.length; i++) {\n    if (view1[i] !== view2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction padNumber(inputNumber, fullLength) {\n  const str = inputNumber.toString(10);\n\n  if (fullLength < str.length) {\n    return \"\";\n  }\n\n  const dif = fullLength - str.length;\n  const padding = new Array(dif);\n\n  for (let i = 0; i < dif; i++) {\n    padding[i] = \"0\";\n  }\n\n  const paddingString = padding.join(\"\");\n  return paddingString.concat(str);\n}\n\nconst base64Template = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nconst base64UrlTemplate = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\";\n\nfunction toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {\n  let i = 0;\n  let flag1 = 0;\n  let flag2 = 0;\n  let output = \"\";\n  const template = useUrlTemplate ? base64UrlTemplate : base64Template;\n\n  if (skipLeadingZeros) {\n    let nonZeroPosition = 0;\n\n    for (let i = 0; i < input.length; i++) {\n      if (input.charCodeAt(i) !== 0) {\n        nonZeroPosition = i;\n        break;\n      }\n    }\n\n    input = input.slice(nonZeroPosition);\n  }\n\n  while (i < input.length) {\n    const chr1 = input.charCodeAt(i++);\n\n    if (i >= input.length) {\n      flag1 = 1;\n    }\n\n    const chr2 = input.charCodeAt(i++);\n\n    if (i >= input.length) {\n      flag2 = 1;\n    }\n\n    const chr3 = input.charCodeAt(i++);\n    const enc1 = chr1 >> 2;\n    const enc2 = (chr1 & 0x03) << 4 | chr2 >> 4;\n    let enc3 = (chr2 & 0x0F) << 2 | chr3 >> 6;\n    let enc4 = chr3 & 0x3F;\n\n    if (flag1 === 1) {\n      enc3 = enc4 = 64;\n    } else {\n      if (flag2 === 1) {\n        enc4 = 64;\n      }\n    }\n\n    if (skipPadding) {\n      if (enc3 === 64) {\n        output += `${template.charAt(enc1)}${template.charAt(enc2)}`;\n      } else {\n        if (enc4 === 64) {\n          output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;\n        } else {\n          output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\n        }\n      }\n    } else {\n      output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\n    }\n  }\n\n  return output;\n}\n\nfunction fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {\n  const template = useUrlTemplate ? base64UrlTemplate : base64Template;\n\n  function indexOf(toSearch) {\n    for (let i = 0; i < 64; i++) {\n      if (template.charAt(i) === toSearch) return i;\n    }\n\n    return 64;\n  }\n\n  function test(incoming) {\n    return incoming === 64 ? 0x00 : incoming;\n  }\n\n  let i = 0;\n  let output = \"\";\n\n  while (i < input.length) {\n    const enc1 = indexOf(input.charAt(i++));\n    const enc2 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));\n    const enc3 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));\n    const enc4 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));\n    const chr1 = test(enc1) << 2 | test(enc2) >> 4;\n    const chr2 = (test(enc2) & 0x0F) << 4 | test(enc3) >> 2;\n    const chr3 = (test(enc3) & 0x03) << 6 | test(enc4);\n    output += String.fromCharCode(chr1);\n\n    if (enc3 !== 64) {\n      output += String.fromCharCode(chr2);\n    }\n\n    if (enc4 !== 64) {\n      output += String.fromCharCode(chr3);\n    }\n  }\n\n  if (cutTailZeros) {\n    const outputLength = output.length;\n    let nonZeroStart = -1;\n\n    for (let i = outputLength - 1; i >= 0; i--) {\n      if (output.charCodeAt(i) !== 0) {\n        nonZeroStart = i;\n        break;\n      }\n    }\n\n    if (nonZeroStart !== -1) {\n      output = output.slice(0, nonZeroStart + 1);\n    } else {\n      output = \"\";\n    }\n  }\n\n  return output;\n}\n\nfunction arrayBufferToString(buffer) {\n  let resultString = \"\";\n  const view = new Uint8Array(buffer);\n\n  for (const element of view) {\n    resultString += String.fromCharCode(element);\n  }\n\n  return resultString;\n}\n\nfunction stringToArrayBuffer(str) {\n  const stringLength = str.length;\n  const resultBuffer = new ArrayBuffer(stringLength);\n  const resultView = new Uint8Array(resultBuffer);\n\n  for (let i = 0; i < stringLength; i++) {\n    resultView[i] = str.charCodeAt(i);\n  }\n\n  return resultBuffer;\n}\n\nconst log2 = Math.log(2);\n\nfunction nearestPowerOf2(length) {\n  const base = Math.log(length) / log2;\n  const floor = Math.floor(base);\n  const round = Math.round(base);\n  return floor === round ? floor : round;\n}\n\nfunction clearProps(object, propsArray) {\n  for (const prop of propsArray) {\n    delete object[prop];\n  }\n}\n\nexport { arrayBufferToString, bufferToHexCodes, checkBufferParams, clearProps, fromBase64, getParametersValue, getUTCDate, isEqualBuffer, nearestPowerOf2, padNumber, stringToArrayBuffer, toBase64, utilConcatBuf, utilConcatView, utilDecodeTC, utilEncodeTC, utilFromBase, utilToBase };","map":null,"metadata":{},"sourceType":"module"}