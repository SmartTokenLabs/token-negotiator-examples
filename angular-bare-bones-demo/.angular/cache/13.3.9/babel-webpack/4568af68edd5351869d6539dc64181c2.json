{"ast":null,"code":"import _asyncToGenerator from \"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport WalletConnect from \"@walletconnect/client\";\nimport QRCodeModal from \"@walletconnect/qrcode-modal\";\nimport HttpConnection from \"@walletconnect/http-connection\";\nimport { payloadId, signingMethods, parsePersonalSign, getRpcUrl } from \"@walletconnect/utils\";\n\nconst ProviderEngine = require(\"web3-provider-engine\");\n\nconst CacheSubprovider = require(\"web3-provider-engine/subproviders/cache\");\n\nconst FixtureSubprovider = require(\"web3-provider-engine/subproviders/fixture\");\n\nconst FilterSubprovider = require(\"web3-provider-engine/subproviders/filters\");\n\nconst HookedWalletSubprovider = require(\"web3-provider-engine/subproviders/hooked-wallet\");\n\nconst NonceSubprovider = require(\"web3-provider-engine/subproviders/nonce-tracker\");\n\nconst SubscriptionsSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\n\nclass WalletConnectProvider extends ProviderEngine {\n  constructor(opts) {\n    var _this;\n\n    super({\n      pollingInterval: opts.pollingInterval || 8000\n    });\n    _this = this;\n    this.bridge = \"https://bridge.walletconnect.org\";\n    this.qrcode = true;\n    this.qrcodeModal = QRCodeModal;\n    this.qrcodeModalOptions = undefined;\n    this.rpc = null;\n    this.infuraId = \"\";\n    this.http = null;\n    this.isConnecting = false;\n    this.connected = false;\n    this.connectCallbacks = [];\n    this.accounts = [];\n    this.chainId = 1;\n    this.rpcUrl = \"\";\n    this.enable = /*#__PURE__*/_asyncToGenerator(function* () {\n      const wc = yield _this.getWalletConnector();\n\n      if (wc) {\n        _this.start();\n\n        _this.subscribeWalletConnector();\n\n        return wc.accounts;\n      } else {\n        throw new Error(\"Failed to connect to WalleConnect\");\n      }\n    });\n\n    this.request = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (payload) {\n        return _this.send(payload);\n      });\n\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    this.send = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (payload, callback) {\n        var _a;\n\n        if (typeof payload === \"string\") {\n          const method = payload;\n          let params = callback;\n\n          if (method === \"personal_sign\") {\n            params = parsePersonalSign(params);\n          }\n\n          return _this.sendAsyncPromise(method, params);\n        }\n\n        payload = Object.assign({\n          id: payloadId(),\n          jsonrpc: \"2.0\"\n        }, payload);\n\n        if (payload.method === \"personal_sign\") {\n          payload.params = parsePersonalSign(payload.params);\n        }\n\n        if (callback) {\n          _this.sendAsync(payload, callback);\n\n          return;\n        }\n\n        if (payload.method === \"eth_signTypedData_v4\" && ((_a = _this.walletMeta) === null || _a === void 0 ? void 0 : _a.name) === \"MetaMask\") {\n          const {\n            result\n          } = yield _this.handleOtherRequests(payload);\n          return result;\n        } else {\n          return _this.sendAsyncPromise(payload.method, payload.params);\n        }\n      });\n\n      return function (_x2, _x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    this.onConnect = callback => {\n      this.connectCallbacks.push(callback);\n    };\n\n    this.triggerConnect = result => {\n      if (this.connectCallbacks && this.connectCallbacks.length) {\n        this.connectCallbacks.forEach(callback => callback(result));\n      }\n    };\n\n    this.bridge = opts.connector ? opts.connector.bridge : opts.bridge || \"https://bridge.walletconnect.org\";\n    this.qrcode = typeof opts.qrcode === \"undefined\" || opts.qrcode !== false;\n    this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;\n    this.qrcodeModalOptions = opts.qrcodeModalOptions;\n    this.wc = opts.connector || new WalletConnect({\n      bridge: this.bridge,\n      qrcodeModal: this.qrcode ? this.qrcodeModal : undefined,\n      qrcodeModalOptions: this.qrcodeModalOptions,\n      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,\n      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,\n      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta\n    });\n    this.rpc = opts.rpc || null;\n\n    if (!this.rpc && (!opts.infuraId || typeof opts.infuraId !== \"string\" || !opts.infuraId.trim())) {\n      throw new Error(\"Missing one of the required parameters: rpc or infuraId\");\n    }\n\n    this.infuraId = opts.infuraId || \"\";\n    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;\n    this.initialize();\n  }\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  get connector() {\n    return this.wc;\n  }\n\n  get walletMeta() {\n    return this.wc.peerMeta;\n  }\n\n  disconnect() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2.close();\n    })();\n  }\n\n  close() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const wc = yield _this3.getWalletConnector({\n        disableSessionCreation: true\n      });\n      yield wc.killSession();\n      yield _this3.onDisconnect();\n    })();\n  }\n\n  handleRequest(payload) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        let response;\n        let result = null;\n        const wc = yield _this4.getWalletConnector();\n\n        switch (payload.method) {\n          case \"wc_killSession\":\n            yield _this4.close();\n            result = null;\n            break;\n\n          case \"eth_accounts\":\n            result = wc.accounts;\n            break;\n\n          case \"eth_coinbase\":\n            result = wc.accounts[0];\n            break;\n\n          case \"eth_chainId\":\n            result = wc.chainId;\n            break;\n\n          case \"net_version\":\n            result = wc.chainId;\n            break;\n\n          case \"eth_uninstallFilter\":\n            _this4.sendAsync(payload, _ => _);\n\n            result = true;\n            break;\n\n          default:\n            response = yield _this4.handleOtherRequests(payload);\n        }\n\n        if (response) {\n          return response;\n        }\n\n        return _this4.formatResponse(payload, result);\n      } catch (error) {\n        _this4.emit(\"error\", error);\n\n        throw error;\n      }\n    })();\n  }\n\n  handleOtherRequests(payload) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!signingMethods.includes(payload.method) && payload.method.startsWith(\"eth_\")) {\n        return _this5.handleReadRequests(payload);\n      }\n\n      const wc = yield _this5.getWalletConnector();\n      const result = yield wc.sendCustomRequest(payload);\n      return _this5.formatResponse(payload, result);\n    })();\n  }\n\n  handleReadRequests(payload) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this6.http) {\n        const error = new Error(\"HTTP Connection not available\");\n\n        _this6.emit(\"error\", error);\n\n        throw error;\n      }\n\n      return _this6.http.send(payload);\n    })();\n  }\n\n  formatResponse(payload, result) {\n    return {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      result: result\n    };\n  }\n\n  getWalletConnector(opts = {}) {\n    const {\n      disableSessionCreation = false\n    } = opts;\n    return new Promise((resolve, reject) => {\n      const wc = this.wc;\n\n      if (this.isConnecting) {\n        this.onConnect(x => resolve(x));\n      } else if (!wc.connected && !disableSessionCreation) {\n        this.isConnecting = true;\n        wc.on(\"modal_closed\", () => {\n          reject(new Error(\"User closed modal\"));\n        });\n        wc.createSession({\n          chainId: this.chainId\n        }).then(() => {\n          wc.on(\"connect\", (error, payload) => {\n            if (error) {\n              this.isConnecting = false;\n              return reject(error);\n            }\n\n            this.isConnecting = false;\n            this.connected = true;\n\n            if (payload) {\n              this.updateState(payload.params[0]);\n            }\n\n            this.emit(\"connect\");\n            this.triggerConnect(wc);\n            resolve(wc);\n          });\n        }).catch(error => {\n          this.isConnecting = false;\n          reject(error);\n        });\n      } else {\n        if (!this.connected) {\n          this.connected = true;\n          this.updateState(wc.session);\n        }\n\n        resolve(wc);\n      }\n    });\n  }\n\n  subscribeWalletConnector() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const wc = yield _this7.getWalletConnector();\n      wc.on(\"disconnect\", error => {\n        if (error) {\n          _this7.emit(\"error\", error);\n\n          return;\n        }\n\n        _this7.onDisconnect();\n      });\n      wc.on(\"session_update\", (error, payload) => {\n        if (error) {\n          _this7.emit(\"error\", error);\n\n          return;\n        }\n\n        _this7.updateState(payload.params[0]);\n      });\n    })();\n  }\n\n  onDisconnect() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this8.stop();\n\n      _this8.emit(\"close\", 1000, \"Connection closed\");\n\n      _this8.emit(\"disconnect\", 1000, \"Connection disconnected\");\n\n      _this8.connected = false;\n    })();\n  }\n\n  updateState(sessionParams) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        accounts,\n        chainId,\n        networkId,\n        rpcUrl\n      } = sessionParams;\n\n      if (!_this9.accounts || accounts && _this9.accounts !== accounts) {\n        _this9.accounts = accounts;\n\n        _this9.emit(\"accountsChanged\", accounts);\n      }\n\n      if (!_this9.chainId || chainId && _this9.chainId !== chainId) {\n        _this9.chainId = chainId;\n\n        _this9.emit(\"chainChanged\", chainId);\n      }\n\n      if (!_this9.networkId || networkId && _this9.networkId !== networkId) {\n        _this9.networkId = networkId;\n\n        _this9.emit(\"networkChanged\", networkId);\n      }\n\n      _this9.updateRpcUrl(_this9.chainId, rpcUrl || \"\");\n    })();\n  }\n\n  updateRpcUrl(chainId, rpcUrl = \"\") {\n    const rpc = {\n      infuraId: this.infuraId,\n      custom: this.rpc || undefined\n    };\n    rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);\n\n    if (rpcUrl) {\n      this.rpcUrl = rpcUrl;\n      this.updateHttpConnection();\n    } else {\n      this.emit(\"error\", new Error(`No RPC Url available for chainId: ${chainId}`));\n    }\n  }\n\n  updateHttpConnection() {\n    if (this.rpcUrl) {\n      this.http = new HttpConnection(this.rpcUrl);\n      this.http.on(\"payload\", payload => this.emit(\"payload\", payload));\n      this.http.on(\"error\", error => this.emit(\"error\", error));\n    }\n  }\n\n  sendAsyncPromise(method, params) {\n    return new Promise((resolve, reject) => {\n      this.sendAsync({\n        id: payloadId(),\n        jsonrpc: \"2.0\",\n        method,\n        params: params || []\n      }, (error, response) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(response.result);\n      });\n    });\n  }\n\n  initialize() {\n    var _this10 = this;\n\n    this.updateRpcUrl(this.chainId);\n    this.addProvider(new FixtureSubprovider({\n      eth_hashrate: \"0x00\",\n      eth_mining: false,\n      eth_syncing: true,\n      net_listening: true,\n      web3_clientVersion: `WalletConnect/v1.x.x/javascript`\n    }));\n    this.addProvider(new CacheSubprovider());\n    this.addProvider(new SubscriptionsSubprovider());\n    this.addProvider(new FilterSubprovider());\n    this.addProvider(new NonceSubprovider());\n    this.addProvider(new HookedWalletSubprovider(this.configWallet()));\n    this.addProvider({\n      handleRequest: function () {\n        var _ref4 = _asyncToGenerator(function* (payload, next, end) {\n          try {\n            const {\n              error,\n              result\n            } = yield _this10.handleRequest(payload);\n            end(error, result);\n          } catch (error) {\n            end(error);\n          }\n        });\n\n        return function handleRequest(_x4, _x5, _x6) {\n          return _ref4.apply(this, arguments);\n        };\n      }(),\n      setEngine: _ => _\n    });\n  }\n\n  configWallet() {\n    var _this11 = this;\n\n    return {\n      getAccounts: function () {\n        var _ref5 = _asyncToGenerator(function* (cb) {\n          try {\n            const wc = yield _this11.getWalletConnector();\n            const accounts = wc.accounts;\n\n            if (accounts && accounts.length) {\n              cb(null, accounts);\n            } else {\n              cb(new Error(\"Failed to get accounts\"));\n            }\n          } catch (error) {\n            cb(error);\n          }\n        });\n\n        return function getAccounts(_x7) {\n          return _ref5.apply(this, arguments);\n        };\n      }(),\n      processMessage: function () {\n        var _ref6 = _asyncToGenerator(function* (msgParams, cb) {\n          try {\n            const wc = yield _this11.getWalletConnector();\n            const result = yield wc.signMessage([msgParams.from, msgParams.data]);\n            cb(null, result);\n          } catch (error) {\n            cb(error);\n          }\n        });\n\n        return function processMessage(_x8, _x9) {\n          return _ref6.apply(this, arguments);\n        };\n      }(),\n      processPersonalMessage: function () {\n        var _ref7 = _asyncToGenerator(function* (msgParams, cb) {\n          try {\n            const wc = yield _this11.getWalletConnector();\n            const result = yield wc.signPersonalMessage([msgParams.data, msgParams.from]);\n            cb(null, result);\n          } catch (error) {\n            cb(error);\n          }\n        });\n\n        return function processPersonalMessage(_x10, _x11) {\n          return _ref7.apply(this, arguments);\n        };\n      }(),\n      processSignTransaction: function () {\n        var _ref8 = _asyncToGenerator(function* (txParams, cb) {\n          try {\n            const wc = yield _this11.getWalletConnector();\n            const result = yield wc.signTransaction(txParams);\n            cb(null, result);\n          } catch (error) {\n            cb(error);\n          }\n        });\n\n        return function processSignTransaction(_x12, _x13) {\n          return _ref8.apply(this, arguments);\n        };\n      }(),\n      processTransaction: function () {\n        var _ref9 = _asyncToGenerator(function* (txParams, cb) {\n          try {\n            const wc = yield _this11.getWalletConnector();\n            const result = yield wc.sendTransaction(txParams);\n            cb(null, result);\n          } catch (error) {\n            cb(error);\n          }\n        });\n\n        return function processTransaction(_x14, _x15) {\n          return _ref9.apply(this, arguments);\n        };\n      }(),\n      processTypedMessage: function () {\n        var _ref10 = _asyncToGenerator(function* (msgParams, cb) {\n          try {\n            const wc = yield _this11.getWalletConnector();\n            const result = yield wc.signTypedData([msgParams.from, msgParams.data]);\n            cb(null, result);\n          } catch (error) {\n            cb(error);\n          }\n        });\n\n        return function processTypedMessage(_x16, _x17) {\n          return _ref10.apply(this, arguments);\n        };\n      }()\n    };\n  }\n\n}\n\nexport default WalletConnectProvider; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module"}