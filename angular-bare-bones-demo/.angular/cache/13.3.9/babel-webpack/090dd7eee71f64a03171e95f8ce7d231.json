{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Eip712Validator = void 0;\n\nconst AttestedObject_1 = require(\"./AttestedObject\");\n\nconst UseToken_1 = require(\"../asn1/shemas/UseToken\");\n\nconst tokenData_1 = require(\"../data/tokenData\");\n\nconst KeyPair_1 = require(\"./KeyPair\");\n\nconst Ticket_1 = require(\"../Ticket\");\n\nconst SignatureUtility_1 = require(\"./SignatureUtility\");\n\nconst utils_1 = require(\"./utils\");\n\nconst config_1 = require(\"../config\");\n\nclass Eip712Validator {\n  constructor() {\n    this.XMLConfig = tokenData_1.XMLconfigData;\n  }\n\n  static stringIsAValidUrl(domain) {\n    let parsedUrl;\n\n    try {\n      parsedUrl = new URL(domain);\n    } catch (e) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'cant construct url. Error:', e);\n      return false;\n    }\n\n    return parsedUrl.protocol === \"http:\" || parsedUrl.protocol === \"https:\";\n  }\n\n  setDomainAndTimout(domain) {\n    if (!Eip712Validator.stringIsAValidUrl(domain)) throw new Error('wrong domain');\n    this.domain = domain;\n  }\n\n  setDomain(domain) {\n    if (!Eip712Validator.stringIsAValidUrl(domain)) throw new Error('wrong domain');\n    this.domain = domain;\n  }\n\n  getDomain() {\n    return this.domain;\n  }\n\n  validateRequest(jsonInput) {\n    try {\n      let authenticationData = JSON.parse(jsonInput);\n      let authenticationRootNode = JSON.parse(authenticationData.jsonSigned);\n      let eip712Domain = authenticationRootNode.domain;\n      let eip712Message = authenticationRootNode.message;\n      let attestedObject = this.retrieveAttestedObject(eip712Message); // TODO implement\n\n      return this.validateDomain(eip712Domain); // && this.validateAuthentication(auth);\n      // accept &= verifySignature(authenticationData, attestedObject.getUserPublicKey());\n      // accept &= validateAttestedObject(attestedObject);\n      // return accept;\n    } catch (e) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'Validate error!', e);\n      return false;\n    }\n  } // TODO\n  // public boolean verifyTimeStamp(String timestamp) {\n\n\n  validateDomain(domainToCheck) {\n    if (domainToCheck.name.toLowerCase() !== this.domain.toLowerCase()) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Domain name is not valid\");\n      return false;\n    }\n\n    if (domainToCheck.version !== SignatureUtility_1.SignatureUtility.Eip712Data['PROTOCOL_VERSION']) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Protocol version is wrong\");\n      return false;\n    } // we dont use that fields at the moment. maybe have to uncomment and fix in the future\n    // if (domainToCheck.chainId !== encoder.getChainId())) {\n    //     logger(DEBUGLEVEL.LOW, \"Chain ID is wrong\");\n    //     return false;\n    // }\n    // if (domainToCheck.verifyingContract !== encoder.getVerifyingContract()) {\n    //     logger(DEBUGLEVEL.LOW, \"Verifying contract is wrong\");\n    //     return false;\n    // }\n    // if (domainToCheck.salt !== encoder.getSalt()) {\n    //     logger(DEBUGLEVEL.LOW, \"Salt is wrong\");\n    //     return false;\n    // }\n\n\n    return true;\n  }\n\n  retrieveAttestedObject(auth) {\n    let attestedObjectHex = auth.payload;\n    let attestorKey = KeyPair_1.KeyPair.publicFromBase64orPEM(tokenData_1.XMLconfigData.base64attestorPubKey);\n    let issuerKeys = tokenData_1.XMLconfigData.base64senderPublicKeys;\n    let decodedAttestedObject = AttestedObject_1.AttestedObject.fromBytes((0, utils_1.hexStringToUint8)(attestedObjectHex), UseToken_1.UseToken, attestorKey, Ticket_1.Ticket, issuerKeys);\n    return decodedAttestedObject;\n  }\n\n  verifySignature(signedJsonInput, pkAddress) {\n    let tokenData = JSON.parse(signedJsonInput);\n    let signatureInHex = tokenData.signatureInHex;\n    let jsonSigned = JSON.parse(tokenData.jsonSigned);\n    let publicKey = SignatureUtility_1.SignatureUtility.recoverPublicKeyFromTypedMessageSignature(jsonSigned, signatureInHex);\n    let userKey = KeyPair_1.KeyPair.fromPublicHex(publicKey.substr(2));\n\n    if (pkAddress.toLowerCase() !== jsonSigned.message.address.toLowerCase()) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'message.address is not equal pkAddress');\n      return false;\n    }\n\n    if (pkAddress.toLowerCase() !== userKey.getAddress().toLowerCase()) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'Recovered address is not equal pkAddress');\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nexports.Eip712Validator = Eip712Validator; //# sourceMappingURL=Eip712Validator.js.map","map":null,"metadata":{},"sourceType":"script"}