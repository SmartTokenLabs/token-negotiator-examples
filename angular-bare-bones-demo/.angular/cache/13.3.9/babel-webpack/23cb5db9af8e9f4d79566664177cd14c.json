{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { base64ToUint8array, compareObjects } from \"../utils/index\";\nexport var filterTokens = function (decodedTokens, filter) {\n  if (filter === void 0) {\n    filter = [];\n  }\n\n  var res = [];\n\n  if (decodedTokens.length && typeof filter === \"object\" && Object.keys(filter).length) {\n    var filterKeys_1 = Object.keys(filter);\n    decodedTokens.forEach(function (token) {\n      var fitFilter = 1;\n      filterKeys_1.forEach(function (key) {\n        if (token[key] && token[key].toString() !== filter[key].toString()) fitFilter = 0;\n      });\n      if (fitFilter) res.push(token);\n    });\n    return res;\n  } else {\n    return decodedTokens;\n  }\n};\nexport var readTokens = function (itemStorageKey) {\n  var storageTickets = localStorage.getItem(itemStorageKey);\n  var tokens = [];\n  var output = {\n    tokens: [],\n    noTokens: true,\n    success: true\n  };\n\n  try {\n    if (storageTickets && storageTickets.length) {\n      tokens = JSON.parse(storageTickets);\n\n      if (tokens.length !== 0) {\n        tokens.forEach(function (item) {\n          if (item.token && item.secret) output.tokens.push(item);\n        });\n      }\n\n      if (output.tokens.length) {\n        output.noTokens = false;\n      }\n    }\n  } catch (e) {\n    output.success = false;\n  }\n\n  return output;\n};\nexport var decodeTokens = function (rawTokens, tokenParser, unsignedTokenDataName) {\n  var x = JSON.parse(rawTokens);\n\n  if (x.length) {\n    return x.map(function (tokenData) {\n      if (tokenData.token) {\n        var decodedToken = new tokenParser(base64ToUint8array(tokenData.token).buffer);\n\n        if (decodedToken && decodedToken[unsignedTokenDataName]) {\n          var token = decodedToken[unsignedTokenDataName];\n          return propsArrayBufferToArray(token);\n        }\n      }\n    });\n  } else {\n    return [];\n  }\n};\n\nfunction propsArrayBufferToArray(obj) {\n  Object.keys(obj).forEach(function (key) {\n    if (obj[key] instanceof ArrayBuffer) {\n      obj[key] = Array.from(new Uint8Array(obj[key]));\n    }\n  });\n  return obj;\n}\n\nexport var storeMagicURL = function (tokens, itemStorageKey) {\n  if (tokens) {\n    localStorage.setItem(itemStorageKey, JSON.stringify(tokens));\n  }\n};\nexport var readMagicUrl = function (tokenUrlName, tokenSecretName, tokenIdName, itemStorageKey, urlParams) {\n  if (urlParams === void 0) {\n    urlParams = null;\n  }\n\n  if (urlParams === null) urlParams = new URLSearchParams(window.location.search);\n  var tokenFromQuery = urlParams.get(tokenUrlName);\n  var secretFromQuery = urlParams.get(tokenSecretName);\n  var tmp = urlParams.get(tokenIdName);\n  var idFromQuery = tmp ? tmp : \"\";\n  if (!(tokenFromQuery && secretFromQuery)) throw new Error(\"Incomplete token params in URL.\");\n  var tokensOutput = readTokens(itemStorageKey);\n  var isNewQueryTicket = true;\n  var tokens = tokensOutput.tokens.map(function (tokenData) {\n    if (tokenData.token === tokenFromQuery) {\n      isNewQueryTicket = false;\n    }\n\n    return tokenData;\n  });\n\n  if (isNewQueryTicket) {\n    tokens.push({\n      token: tokenFromQuery,\n      secret: secretFromQuery,\n      id: decodeURIComponent(idFromQuery),\n      magic_link: window.location.href\n    });\n    return tokens;\n  }\n\n  throw new Error(\"Token already added.\");\n};\nexport var rawTokenCheck = function (unsignedToken, tokenIssuer) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var rawTokenData, base64ticket, ticketSecret, tokenObj;\n    return __generator(this, function (_a) {\n      rawTokenData = getRawToken(unsignedToken, tokenIssuer);\n      if (!rawTokenData) return [2, null];\n      base64ticket = rawTokenData.token;\n      ticketSecret = rawTokenData.secret;\n      tokenObj = {\n        ticketBlob: base64ticket,\n        ticketSecret: ticketSecret,\n        attestationOrigin: tokenIssuer.attestationOrigin\n      };\n      if (rawTokenData && rawTokenData.id) tokenObj.email = rawTokenData.id;\n\n      if (rawTokenData && rawTokenData.magic_link) {\n        tokenObj.magicLink = rawTokenData.magic_link;\n      }\n\n      return [2, tokenObj];\n    });\n  });\n};\nexport var getRawToken = function (unsignedToken, tokenIssuer) {\n  if (!unsignedToken || !Object.keys(unsignedToken).length) return;\n  var tokensOutput = readTokens(tokenIssuer.itemStorageKey);\n\n  if (tokensOutput.success && !tokensOutput.noTokens) {\n    var rawTokens = tokensOutput.tokens;\n    var token_1 = {};\n\n    if (rawTokens.length) {\n      rawTokens.forEach(function (tokenData) {\n        if (tokenData.token) {\n          var _tokenParser = tokenIssuer.tokenParser;\n          var decodedToken = new _tokenParser(base64ToUint8array(tokenData.token).buffer);\n\n          if (decodedToken && decodedToken[tokenIssuer.unsignedTokenDataName]) {\n            var decodedTokenData = decodedToken[tokenIssuer.unsignedTokenDataName];\n            decodedTokenData = propsArrayBufferToArray(decodedTokenData);\n\n            if (compareObjects(decodedTokenData, unsignedToken)) {\n              token_1 = tokenData;\n            }\n          }\n        }\n      });\n    }\n\n    return token_1;\n  } else {\n    return null;\n  }\n}; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module"}