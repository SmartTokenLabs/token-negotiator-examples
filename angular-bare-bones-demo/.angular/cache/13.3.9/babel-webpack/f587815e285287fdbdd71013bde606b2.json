{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar hasSymbols = require('has-symbols')();\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar IteratorPrototype = GetIntrinsic('%IteratorPrototype%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\n\nvar AdvanceStringIndex = require('./AdvanceStringIndex');\n\nvar CreateIterResultObject = require('./CreateIterResultObject');\n\nvar CreateMethodProperty = require('./CreateMethodProperty');\n\nvar Get = require('./Get');\n\nvar OrdinaryObjectCreate = require('./OrdinaryObjectCreate');\n\nvar RegExpExec = require('./RegExpExec');\n\nvar Set = require('./Set');\n\nvar ToLength = require('./ToLength');\n\nvar ToString = require('./ToString');\n\nvar Type = require('./Type');\n\nvar SLOT = require('internal-slot');\n\nvar RegExpStringIterator = function RegExpStringIterator(R, S, global, fullUnicode) {\n  if (Type(S) !== 'String') {\n    throw new $TypeError('`S` must be a string');\n  }\n\n  if (Type(global) !== 'Boolean') {\n    throw new $TypeError('`global` must be a boolean');\n  }\n\n  if (Type(fullUnicode) !== 'Boolean') {\n    throw new $TypeError('`fullUnicode` must be a boolean');\n  }\n\n  SLOT.set(this, '[[IteratingRegExp]]', R);\n  SLOT.set(this, '[[IteratedString]]', S);\n  SLOT.set(this, '[[Global]]', global);\n  SLOT.set(this, '[[Unicode]]', fullUnicode);\n  SLOT.set(this, '[[Done]]', false);\n};\n\nif (IteratorPrototype) {\n  RegExpStringIterator.prototype = OrdinaryObjectCreate(IteratorPrototype);\n}\n\nvar RegExpStringIteratorNext = function next() {\n  var O = this; // eslint-disable-line no-invalid-this\n\n  if (Type(O) !== 'Object') {\n    throw new $TypeError('receiver must be an object');\n  }\n\n  if (!(O instanceof RegExpStringIterator) || !SLOT.has(O, '[[IteratingRegExp]]') || !SLOT.has(O, '[[IteratedString]]') || !SLOT.has(O, '[[Global]]') || !SLOT.has(O, '[[Unicode]]') || !SLOT.has(O, '[[Done]]')) {\n    throw new $TypeError('\"this\" value must be a RegExpStringIterator instance');\n  }\n\n  if (SLOT.get(O, '[[Done]]')) {\n    return CreateIterResultObject(undefined, true);\n  }\n\n  var R = SLOT.get(O, '[[IteratingRegExp]]');\n  var S = SLOT.get(O, '[[IteratedString]]');\n  var global = SLOT.get(O, '[[Global]]');\n  var fullUnicode = SLOT.get(O, '[[Unicode]]');\n  var match = RegExpExec(R, S);\n\n  if (match === null) {\n    SLOT.set(O, '[[Done]]', true);\n    return CreateIterResultObject(undefined, true);\n  }\n\n  if (global) {\n    var matchStr = ToString(Get(match, '0'));\n\n    if (matchStr === '') {\n      var thisIndex = ToLength(Get(R, 'lastIndex'));\n      var nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);\n      Set(R, 'lastIndex', nextIndex, true);\n    }\n\n    return CreateIterResultObject(match, false);\n  }\n\n  SLOT.set(O, '[[Done]]', true);\n  return CreateIterResultObject(match, false);\n};\n\nCreateMethodProperty(RegExpStringIterator.prototype, 'next', RegExpStringIteratorNext);\n\nif (hasSymbols) {\n  if (Symbol.toStringTag) {\n    if ($defineProperty) {\n      $defineProperty(RegExpStringIterator.prototype, Symbol.toStringTag, {\n        configurable: true,\n        enumerable: false,\n        value: 'RegExp String Iterator',\n        writable: false\n      });\n    } else {\n      RegExpStringIterator.prototype[Symbol.toStringTag] = 'RegExp String Iterator';\n    }\n  }\n\n  if (Symbol.iterator && typeof RegExpStringIterator.prototype[Symbol.iterator] !== 'function') {\n    var iteratorFn = function SymbolIterator() {\n      return this;\n    };\n\n    CreateMethodProperty(RegExpStringIterator.prototype, Symbol.iterator, iteratorFn);\n  }\n} // https://262.ecma-international.org/11.0/#sec-createregexpstringiterator\n\n\nmodule.exports = function CreateRegExpStringIterator(R, S, global, fullUnicode) {\n  // assert R.global === global && R.unicode === fullUnicode?\n  return new RegExpStringIterator(R, S, global, fullUnicode);\n};","map":null,"metadata":{},"sourceType":"script"}