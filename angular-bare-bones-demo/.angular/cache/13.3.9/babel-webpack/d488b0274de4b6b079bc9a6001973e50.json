{"ast":null,"code":"'use strict';\n\nconst processFn = (fn, options, proxy, unwrapped) => function (...arguments_) {\n  const P = options.promiseModule;\n  return new P((resolve, reject) => {\n    if (options.multiArgs) {\n      arguments_.push((...result) => {\n        if (options.errorFirst) {\n          if (result[0]) {\n            reject(result);\n          } else {\n            result.shift();\n            resolve(result);\n          }\n        } else {\n          resolve(result);\n        }\n      });\n    } else if (options.errorFirst) {\n      arguments_.push((error, result) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      });\n    } else {\n      arguments_.push(resolve);\n    }\n\n    const self = this === proxy ? unwrapped : this;\n    Reflect.apply(fn, self, arguments_);\n  });\n};\n\nconst filterCache = new WeakMap();\n\nmodule.exports = (input, options) => {\n  options = {\n    exclude: [/.+(?:Sync|Stream)$/],\n    errorFirst: true,\n    promiseModule: Promise,\n    ...options\n  };\n  const objectType = typeof input;\n\n  if (!(input !== null && (objectType === 'object' || objectType === 'function'))) {\n    throw new TypeError(`Expected \\`input\\` to be a \\`Function\\` or \\`Object\\`, got \\`${input === null ? 'null' : objectType}\\``);\n  }\n\n  const filter = (target, key) => {\n    let cached = filterCache.get(target);\n\n    if (!cached) {\n      cached = {};\n      filterCache.set(target, cached);\n    }\n\n    if (key in cached) {\n      return cached[key];\n    }\n\n    const match = pattern => typeof pattern === 'string' || typeof key === 'symbol' ? key === pattern : pattern.test(key);\n\n    const desc = Reflect.getOwnPropertyDescriptor(target, key);\n    const writableOrConfigurableOwn = desc === undefined || desc.writable || desc.configurable;\n    const included = options.include ? options.include.some(match) : !options.exclude.some(match);\n    const shouldFilter = included && writableOrConfigurableOwn;\n    cached[key] = shouldFilter;\n    return shouldFilter;\n  };\n\n  const cache = new WeakMap();\n  const proxy = new Proxy(input, {\n    apply(target, thisArg, args) {\n      const cached = cache.get(target);\n\n      if (cached) {\n        return Reflect.apply(cached, thisArg, args);\n      }\n\n      const pified = options.excludeMain ? target : processFn(target, options, proxy, target);\n      cache.set(target, pified);\n      return Reflect.apply(pified, thisArg, args);\n    },\n\n    get(target, key) {\n      const property = target[key]; // eslint-disable-next-line no-use-extend-native/no-use-extend-native\n\n      if (!filter(target, key) || property === Function.prototype[key]) {\n        return property;\n      }\n\n      const cached = cache.get(property);\n\n      if (cached) {\n        return cached;\n      }\n\n      if (typeof property === 'function') {\n        const pified = processFn(property, options, proxy, target);\n        cache.set(property, pified);\n        return pified;\n      }\n\n      return property;\n    }\n\n  });\n  return proxy;\n};","map":null,"metadata":{},"sourceType":"script"}