{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AttestationCrypto = exports.Pedestren_H = exports.Pedestren_G = void 0;\n\nconst interfaces_1 = require(\"./interfaces\");\n\nconst Point_1 = require(\"./Point\");\n\nconst utils_1 = require(\"./utils\");\n\nconst FullProofOfExponent_1 = require(\"./FullProofOfExponent\");\n\nconst config_1 = require(\"../config\");\n\nconst crypto = require('crypto');\n\nlet sha3 = require(\"js-sha3\"); // Generator for message part of Pedersen commitments generated deterministically from mapToInteger queried on 0 and mapped to the curve using try-and-increment\n\n\nexports.Pedestren_G = new Point_1.Point(21282764439311451829394129092047993080259557426320933158672611067687630484067n, 3813889942691430704369624600187664845713336792511424430006907067499686345744n, Point_1.CURVE_BN256);\nexports.Pedestren_H = new Point_1.Point(10844896013696871595893151490650636250667003995871483372134187278207473369077n, 9393217696329481319187854592386054938412168121447413803797200472841959383227n, Point_1.CURVE_BN256);\n\nclass AttestationCrypto {\n  constructor() {\n    this.curveOrderBitLength = 254n;\n    this.rand = this.makeSecret(); // if (mod(CURVE_BN256.P,4n) != 3n) {\n    //     throw new Error(\"The crypto will not work with this choice of curve\");\n    // }\n\n    if (!this.verifyCurveOrder(Point_1.CURVE_BN256.n)) {\n      throw new Error(\"Static values do not work with current implementation\");\n    }\n  }\n\n  verifyCurveOrder(curveOrder) {\n    // Verify that the curve order is less than 2^256 bits, which is required by mapToCurveMultiplier\n    // Specifically checking if it is larger than 2^curveOrderBitLength and that no bits at position curveOrderBitLength+1 or larger are set\n    let curveOrderBitLength = BigInt(curveOrder.toString(2).length);\n\n    if (curveOrder < 1n << curveOrderBitLength - 1n || curveOrder >> curveOrderBitLength > 0n) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Curve order is not 253 bits which is required by the current implementation\");\n      return false;\n    }\n\n    return true;\n  }\n\n  getType(type) {\n    switch (type.toLowerCase()) {\n      case \"mail\":\n        return interfaces_1.ATTESTATION_TYPE.mail;\n\n      case \"phone\":\n        return interfaces_1.ATTESTATION_TYPE.phone;\n\n      case \"inetpersona\":\n        return interfaces_1.ATTESTATION_TYPE.InetPersona;\n\n      default:\n        throw new Error(\"Wrong type of identifier\");\n    }\n  } // makeRiddle(identifier: string, type: number, secret: bigint): Uint8Array {\n  //     let hashedIdentifier = this.hashIdentifier(type, identifier);\n  //     return hashedIdentifier.multiplyDA(secret).getEncoded(false);\n  // }\n\n  /**\n   * Construct a Pedersen commitment to an identifier using a specific secret.\n   * @param identifier The common identifier\n   * @param type The type of identifier\n   * @param secret The secret randomness to be used in the commitment\n   * @return\n   */\n\n\n  makeCommitment(identifier, type, secret) {\n    let hashedIdentifier = this.mapToCurveMultiplier(type, identifier);\n    let commitment = exports.Pedestren_G.multiplyDA(hashedIdentifier).add(exports.Pedestren_H.multiplyDA(secret));\n    return commitment.getEncoded(false); // let hiding:Point = Pedestren_H.multiplyDA(secret);\n    // return this.makeCommitmentFromHiding(identifier, type, hiding);\n  }\n  /**\n   * Constructs a commitment to an identifier based on hidden randomization supplied from a user.\n   * This is used to construct an attestation.\n   * @param identifier The user's identifier.\n   * @param type The type of identifier.\n   * @param hiding The hiding the user has picked\n   * @return\n   */\n\n\n  makeCommitmentFromHiding(identifier, type, hiding) {\n    // let hashedIdentifier:bigint = this.mapToIntegerIntString(type, identifier);\n    let hashedIdentifier = this.mapToCurveMultiplier(type, identifier); // Construct Pedersen commitment\n\n    let commitment = exports.Pedestren_G.multiplyDA(hashedIdentifier).add(hiding);\n    return commitment.getEncoded(false);\n  } // TODO use type\n  // hashIdentifier(type: number , identifier: string): Point {\n  //     let idenNum = this.mapToInteger(type, Uint8Array.from(stringToArray(identifier.trim().toLowerCase())));\n  //     // logger(DEBUGLEVEL.HIGH, `idenNum(for base point) = ${idenNum}`);\n  //     return this.computePoint_bn256(idenNum);\n  // }\n\n\n  injectIdentifierType(type, arr) {\n    // add prefix [0,0,0,1] for email type\n    return (0, utils_1.uint8merge)([Uint8Array.from([0, 0, 0, type]), arr]);\n  }\n\n  mapToInteger(arr) {\n    return BigInt('0x' + sha3.keccak256(arr)) >> 256n - this.curveOrderBitLength;\n  }\n\n  mapToCurveMultiplier(type, identifier) {\n    let identifierBytes = Uint8Array.from((0, utils_1.stringToArray)(identifier.trim().toLowerCase()));\n    let uintArr = this.injectIdentifierType(type, identifierBytes);\n    let sampledVal = (0, utils_1.uint8ToBn)(uintArr);\n\n    do {\n      sampledVal = this.mapToInteger((0, utils_1.bnToUint8)(sampledVal));\n    } while (sampledVal >= Point_1.CURVE_BN256.n);\n\n    return sampledVal;\n  } // mapToIntegerFromUint8(arr: Uint8Array ):bigint {\n  //     let hash0: string = sha3.keccak256( uint8merge([Uint8Array.from([0]),arr]) );\n  //     let hash1: string = sha3.keccak256( uint8merge([Uint8Array.from([1]),arr]) );\n  //\n  //     return BigInt('0x' + hash0 + hash1);\n  // }\n  // computePoint_SECP256k1( x: bigint ): Point {\n  //     x = mod ( x );\n  //     let y = 0n, expected = 0n, ySquare = 0n;\n  //     let resPoint,referencePoint: Point;\n  //     let p = CURVE_SECP256k1.P;\n  //     let a = CURVE_SECP256k1.A;\n  //     let b = CURVE_SECP256k1.B;\n  //     do {\n  //         do {\n  //             x = mod(x + 1n);\n  //             ySquare = mod(BnPowMod(x, 3n, p) + a * x + b);\n  //             y = BnPowMod(ySquare, CURVE_SECP256k1.magicExp, p);\n  //             expected = mod(y * y);\n  //         } while (expected !== ySquare);\n  //         resPoint = new Point(x, y);\n  //         // TODO add Point.negate() and use following logic\n  //         // Ensure that we have a consistent choice of which \"sign\" of y we use. We always use the smallest possible value of y\n  //         if (resPoint.y > (p / 2n)) {\n  //             resPoint = new Point(x, p - y);\n  //         }\n  //         referencePoint = resPoint.multiplyDA(CURVE_SECP256k1.n - 1n);\n  //         if (referencePoint.y > (p / 2n)) {\n  //             referencePoint = new Point(referencePoint.x, p - referencePoint.y);\n  //         }\n  //     } while (!resPoint.equals(referencePoint))\n  //     return resPoint;\n  // }\n\n\n  computePoint_bn256(x) {\n    let fieldSize = Point_1.CURVE_BN256.P;\n    x = (0, utils_1.mod)(x, fieldSize);\n    let y = 0n,\n        ySquare = 0n;\n    let resPoint, referencePoint;\n    let quadraticResidue;\n    let magicExp = fieldSize + 1n >> 2n; // fieldSize + 1 / 4\n\n    let quadraticResidueExp = fieldSize - 1n >> 1n;\n\n    do {\n      do {\n        x = (0, utils_1.mod)(x + 1n);\n        ySquare = (0, utils_1.mod)((0, utils_1.BnPowMod)(x, 3n, fieldSize) + Point_1.CURVE_BN256.A * x + Point_1.CURVE_BN256.B);\n        quadraticResidue = (0, utils_1.BnPowMod)(ySquare, quadraticResidueExp, fieldSize);\n      } while (quadraticResidue !== 1n); // We use the Lagrange trick to compute the squareroot (since fieldSize mod 4=3)\n\n\n      y = (0, utils_1.BnPowMod)(ySquare, magicExp, fieldSize);\n      resPoint = new Point_1.Point(x, y, Point_1.CURVE_BN256); // Ensure that we have a consistent choice of which \"sign\" of y we use. We always use the smallest possible value of y\n\n      if (resPoint.x > fieldSize >> 1n) {\n        resPoint = new Point_1.Point(x, fieldSize - y, Point_1.CURVE_BN256);\n      }\n\n      referencePoint = resPoint.multiplyDA(Point_1.CURVE_BN256.n - 1n);\n\n      if (referencePoint.y > fieldSize >> 1n) {\n        referencePoint = new Point_1.Point(referencePoint.x, fieldSize - referencePoint.y, Point_1.CURVE_BN256);\n      } // Verify that the element is a member of the expected (subgroup) by ensuring that it has the right order, through Fermat's little theorem\n      // NOTE: this is ONLY needed if we DON'T use secp256k1, so currently it is superflous but we are keeping it this check is crucial for security on most other curves!\n\n    } while (!resPoint.equals(referencePoint) || resPoint.isInfinity());\n\n    return resPoint;\n  }\n\n  makeSecret(bytes = 48) {\n    return (0, utils_1.mod)(BigInt(AttestationCrypto.generateRandomHexString(bytes)), Point_1.CURVE_BN256.n);\n  }\n\n  static generateRandomHexString(len) {\n    var array = new Uint8Array(len);\n\n    if (window && window.crypto) {\n      window.crypto.getRandomValues(array);\n    } else {\n      array = new Uint8Array(crypto.randomBytes(len));\n    }\n\n    let output = '0x';\n\n    for (var i = 0; i < array.length; i++) {\n      output += array[i].toString(16).padStart(2, '0');\n    }\n\n    return output;\n  }\n  /**\n   * Computes a proof of knowledge of a random exponent\n   * This is used to convince the attestor that the user knows a secret which the attestor will\n   * then use to construct a Pedersen commitment to the user's identifier.\n   * @param randomness The randomness used in the commitment\n   * @return\n   */\n\n\n  computeAttestationProof(randomness, nonce = new Uint8Array([])) {\n    // Compute the random part of the commitment, i.e. H^randomness\n    let riddle = exports.Pedestren_H.multiplyDA(randomness);\n    let challengeList = [exports.Pedestren_H, riddle];\n    return this.constructSchnorrPOK(riddle, randomness, challengeList, nonce);\n  }\n  /**\n   * Compute a proof that commitment1 and commitment2 are Pedersen commitments to the same message and that the user\n   * knows randomness1-randomness2.\n   * NOTE: We are actually not proving that the user knows the message and randomness1 and randomness2.\n   * This is because we assume the user has already proven knowledge of his message (mail) and the\n   * randomness1 used in the attestation to the attestor. Because of this assumption it is enough to prove\n   * knowledge of randomness2 (equivalent to proving knowledge of randomness1-randomness2) and that the\n   * commitments are to the same message.\n   * The reason we do this is that this weaker proof is significantly cheaper to execute on the blockchain.\n   *\n   * In conclusion what this method actually proves is knowledge that randomness1-randomness2 is the\n   * discrete log of commitment1/commitment2.\n   * I.e. that commitment1/commitment2 =H^(randomness1-randomness2)\n   * @param commitment1 First Pedersen commitment to some message m\n   * @param commitment2 Second Pedersen commitment to some message m\n   * @param randomness1 The randomness used in commitment1\n   * @param randomness2 The randomness used in commitment2\n   * @return\n   */\n\n\n  computeEqualityProof(commitment1, commitment2, randomness1, randomness2, nonce = new Uint8Array([])) {\n    let comPoint1 = Point_1.Point.decodeFromHex(commitment1, Point_1.CURVE_BN256);\n    let comPoint2 = Point_1.Point.decodeFromHex(commitment2, Point_1.CURVE_BN256); // Compute H*(randomness1-randomness2=commitment1-commitment2=G*msg+H*randomness1-G*msg+H*randomness2\n\n    let riddle = comPoint1.subtract(comPoint2);\n    let exponent = (0, utils_1.mod)(randomness1 - randomness2, Point_1.CURVE_BN256.n);\n    let challengeList = [exports.Pedestren_H, comPoint1, comPoint2];\n    return this.constructSchnorrPOK(riddle, exponent, challengeList, nonce).getUsageProofOfExponent();\n  }\n  /**\n   * Constructs a Schnorr proof of knowledge of exponent of a riddle to base H.\n   * The challenge value used (c) is computed from the challengeList and the internal t value.\n   * The method uses rejection sampling to ensure that the t value is sampled s.t. the\n   * challenge will always be less than curveOrder.\n   */\n\n\n  constructSchnorrPOK(riddle, exponent, challengePoints, nonce) {\n    let t;\n    let hiding, c, d; // Use rejection sampling to sample a hiding value s.t. the random oracle challenge c computed from it is less than curveOrder\n\n    do {\n      hiding = this.makeSecret();\n      t = exports.Pedestren_H.multiplyDA(hiding); // c = this.mapToInteger(this.makeArray(challengeList.concat([t])));\n\n      c = this.computeChallenge(t, challengePoints, nonce);\n    } while (c >= Point_1.CURVE_BN256.n);\n\n    d = (0, utils_1.mod)(hiding + c * exponent, Point_1.CURVE_BN256.n);\n    return FullProofOfExponent_1.FullProofOfExponent.fromData(riddle, t, d, nonce);\n  }\n\n  computeChallenge(t, challengeList, nonce) {\n    let finalChallengeList = challengeList.concat(t);\n    let challengePointBytes = this.makeArray(finalChallengeList);\n    let challengeBytes = (0, utils_1.uint8merge)([challengePointBytes, nonce]);\n    return this.mapToInteger(challengeBytes);\n  }\n  /**\n   * Verifies a zero knowledge proof of knowledge of a riddle used in an attestation request\n   * @param pok The proof to verify\n   * @return True if the proof is OK and false otherwise\n   */\n\n\n  verifyFullProof(pok) {\n    // let c:bigint = this.mapToInteger(this.makeArray([Pedestren_H, pok.getRiddle(), pok.getPoint()]));\n    let c = this.computeChallenge(pok.getPoint(), [exports.Pedestren_H, pok.getRiddle()], pok.getNonce());\n    return this.verifyPok(pok, c);\n  }\n  /**\n   * Verifies a zero knowledge proof of knowledge of the two riddles used in two different\n   * commitments to the same message.\n   * This is used by the smart contract to verify that a request is ok where one commitment is the\n   * riddle for a cheque/ticket and the other is the riddle from an attesation.\n   * @param pok The proof to verify\n   * @return True if the proof is OK and false otherwise\n   */\n\n\n  verifyEqualityProof(commitment1, commitment2, pok) {\n    let comPoint1 = Point_1.Point.decodeFromUint8(commitment1, Point_1.CURVE_BN256);\n    let comPoint2 = Point_1.Point.decodeFromUint8(commitment2, Point_1.CURVE_BN256); // Compute the value the riddle should have\n\n    let riddle = comPoint1.subtract(comPoint2); // let c: bigint = this.mapToInteger(this.makeArray([Pedestren_H, comPoint1, comPoint2, pok.getPoint()]));\n\n    let c = this.computeChallenge(pok.getPoint(), [exports.Pedestren_H, comPoint1, comPoint2], pok.getNonce());\n    return this.verifyPok(FullProofOfExponent_1.FullProofOfExponent.fromData(riddle, pok.getPoint(), pok.getChallengeResponse(), pok.getNonce()), c);\n  }\n\n  verifyPok(pok, c) {\n    // Check that the c has been sampled correctly using rejection sampling\n    if (c >= Point_1.CURVE_BN256.n) {\n      return false;\n    }\n\n    let lhs = exports.Pedestren_H.multiplyDA(pok.getChallengeResponse());\n    let rhs = pok.getRiddle().multiplyDA(c).add(pok.getPoint());\n    return lhs.equals(rhs);\n  } // computeProof(base: Point, riddle: Point, exponent: bigint): ProofOfExponent{\n  //     let r: bigint = this.makeSecret();\n  //     let t: Point = base.multiplyDA(r);\n  //     // TODO ideally Bob's ethreum address should also be part of the challenge\n  //     let c: bigint = mod(this.mapToIntegerFromUint8(this.makeArray([base, riddle, t])), CURVE_BN256.n);\n  //     let d: bigint = mod(r + c * exponent, CURVE_BN256.n);\n  //     return  new ProofOfExponent(base, riddle, t, d);\n  // }\n\n\n  makeArray(pointArray) {\n    let output = new Uint8Array(0);\n    pointArray.forEach(item => {\n      output = new Uint8Array([...output, ...item.getEncoded(false)]);\n    });\n    return output;\n  } // verifyProof(pok: ProofOfExponent)  {\n  //     let c = mod(this.mapToIntegerFromUint8(this.makeArray([pok.getBase(), pok.getRiddle(), pok.getPoint()])), CURVE_BN256.n);\n  //     let lhs: Point = pok.getBase().multiplyDA(pok.getChallenge());\n  //     let rhs: Point = pok.getRiddle().multiplyDA(c).add(pok.getPoint());\n  //     return lhs.equals(rhs);\n  // }\n\n\n  static hashWithKeccak(data) {\n    return sha3.keccak256(data);\n  }\n\n}\n\nexports.AttestationCrypto = AttestationCrypto;\nAttestationCrypto.OID_SIGNATURE_ALG = \"1.2.840.10045.2.1\";\nAttestationCrypto.BYTES_IN_DIGEST = 256 / 8; //# sourceMappingURL=AttestationCrypto.js.map","map":null,"metadata":{},"sourceType":"script"}