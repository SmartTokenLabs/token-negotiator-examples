{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ecSignatureToSRVhex = exports.testsLogger = exports.logger = exports.isDomainValid = exports.formatGeneralizedDateTime = exports.ethAddressToUint8 = exports.hashUint8To32bytesUint8 = exports.hashStringTo32bytesUint8 = exports.getInt64Bytes = exports.uint8tohex = exports.BnPowMod = exports.stringToArray = exports.base64ToUint8array = exports.pemOrBase64Orbase64urlToString = exports.base64toBase64Url = exports.uint8arrayToBase64 = exports.uint8toString = exports.uint8merge = exports.bnToBuf = exports.bnToUint8 = exports.bufToBn = exports.uint8ToBn = exports.egcd = exports.invert = exports.mod = exports.hexStringToBase64Url = exports.hexStringToBase64 = exports.hexStringToUint8 = exports.hexStringToArray = exports.stringToHex = void 0;\n\nconst config_1 = require(\"../config\");\n\nconst Point_1 = require(\"./Point\");\n\nlet sha3 = require(\"js-sha3\");\n\nlet displayDebugLevel;\nlet testsDisplayDebugLevel; // process.env.DISPLAY_DEBUG_LEVEL used to set LOG level for NODE.JS\n// window.DISPLAY_DEBUG_LEVEL used to set LOG level for browser\n\nif (process && process.env && process.env.DISPLAY_DEBUG_LEVEL) {\n  displayDebugLevel = parseInt(process.env.DISPLAY_DEBUG_LEVEL);\n} else if (typeof window !== \"undefined\" && window.DISPLAY_DEBUG_LEVEL) {\n  displayDebugLevel = parseInt(window.DISPLAY_DEBUG_LEVEL);\n} // process.env.DISPLAY_DEBUG_LEVEL_TESTS used to set LOG level for NODE.JS jest tests\n\n\nif (process && process.env && process.env.DISPLAY_DEBUG_LEVEL_TESTS) {\n  testsDisplayDebugLevel = parseInt(process.env.DISPLAY_DEBUG_LEVEL_TESTS);\n}\n\nfunction stringToHex(str) {\n  var hex = '';\n\n  for (var i = 0; i < str.length; i++) {\n    hex += '' + str.charCodeAt(i).toString(16);\n  }\n\n  return hex;\n}\n\nexports.stringToHex = stringToHex;\n\nfunction hexStringToArray(str = '') {\n  if (str.substr(0, 2).toLowerCase() === \"0x\") {\n    str = str.substr(2);\n  }\n\n  let arr = [];\n  let strArr = [...str];\n  if (strArr.length % 2) strArr.unshift('0');\n  let tempStr = '';\n  if (!strArr || typeof strArr == \"undefined\" || !strArr.length) return [];\n  let tmpVal;\n\n  while (strArr.length) {\n    tempStr = ''; // @ts-ignore\n\n    tempStr += strArr.shift() + strArr.shift();\n    tmpVal = parseInt(tempStr, 16);\n\n    if (isNaN(tmpVal)) {\n      throw new Error(\"hexStringToArray input is not a hex string.\");\n    }\n\n    arr.push(tmpVal);\n  }\n\n  return arr;\n}\n\nexports.hexStringToArray = hexStringToArray;\n\nfunction hexStringToUint8(str = '') {\n  return Uint8Array.from(hexStringToArray(str));\n}\n\nexports.hexStringToUint8 = hexStringToUint8;\n\nfunction hexStringToBase64(str = '') {\n  return uint8arrayToBase64(hexStringToUint8(str));\n}\n\nexports.hexStringToBase64 = hexStringToBase64;\n\nfunction hexStringToBase64Url(str = '') {\n  return base64toBase64Url(uint8arrayToBase64(hexStringToUint8(str)));\n}\n\nexports.hexStringToBase64Url = hexStringToBase64Url;\n\nfunction mod(a, b = Point_1.CURVE_BN256.P) {\n  const result = a % b;\n  return result >= 0n ? result : b + result;\n}\n\nexports.mod = mod;\n\nfunction invert(number, modulo = Point_1.CURVE_BN256.P) {\n  if (number === 0n || modulo <= 0n) {\n    throw new Error('invert: expected positive integers');\n  }\n\n  let [gcd, x] = egcd(mod(number, modulo), modulo);\n\n  if (gcd !== 1n) {\n    throw new Error('invert: does not exist');\n  }\n\n  return mod(x, modulo);\n}\n\nexports.invert = invert; // Eucledian GCD\n// https://brilliant.org/wiki/extended-euclidean-algorithm/\n\nfunction egcd(a, b) {\n  let [x, y, u, v] = [0n, 1n, 1n, 0n];\n\n  while (a !== 0n) {\n    let [q, r] = [b / a, b % a];\n    let [m, n] = [x - u * q, y - v * q];\n    [b, a] = [a, r];\n    [x, y] = [u, v];\n    [u, v] = [m, n];\n  }\n\n  return [b, x, y];\n}\n\nexports.egcd = egcd;\n\nfunction uint8ToBn(uint8) {\n  return bufToBn(uint8);\n}\n\nexports.uint8ToBn = uint8ToBn;\n\nfunction bufToBn(buf) {\n  let hex = [];\n  let u8 = Uint8Array.from(buf);\n  u8.forEach(function (i) {\n    var h = i.toString(16);\n\n    if (h.length % 2) {\n      h = '0' + h;\n    }\n\n    hex.push(h);\n  });\n  return BigInt('0x' + hex.join(''));\n}\n\nexports.bufToBn = bufToBn;\n\nfunction bnToUint8(bn) {\n  return bnToBuf(bn);\n}\n\nexports.bnToUint8 = bnToUint8;\n\nfunction bnToBuf(bn, length = 0) {\n  var hex = BigInt(bn).toString(16).padStart(length * 2, '0');\n\n  if (hex.length % 2) {\n    hex = '0' + hex;\n  }\n\n  var len = hex.length / 2;\n  var u8 = new Uint8Array(len);\n  var i = 0;\n  var j = 0;\n\n  while (i < len) {\n    u8[i] = parseInt(hex.slice(j, j + 2), 16);\n    i += 1;\n    j += 2;\n  }\n\n  return u8;\n}\n\nexports.bnToBuf = bnToBuf;\n\nfunction uint8merge(list) {\n  if (list.length === 1) return list[0];\n  let out = Uint8Array.from([]);\n  if (list.length === 0) return out;\n\n  for (let i = 0; i < list.length; i++) {\n    if (typeof list[i] !== \"object\" || typeof list[i].length !== \"number\") {\n      throw new Error('wrong input values');\n    }\n\n    let toAdd = Uint8Array.from(list[i]);\n\n    if (!toAdd || !toAdd.length) {\n      continue;\n    }\n\n    let temp = new Uint8Array(out.length + toAdd.length);\n    temp.set(out);\n    temp.set(toAdd, out.length);\n    out = temp;\n  }\n\n  return out;\n}\n\nexports.uint8merge = uint8merge;\n\nfunction uint8toString(uint8) {\n  if (!uint8) return '';\n  let binary = '';\n  let len = uint8.byteLength;\n\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(uint8[i]);\n  }\n\n  return binary;\n}\n\nexports.uint8toString = uint8toString;\n\nfunction uint8arrayToBase64(bytes) {\n  let binary = uint8toString(bytes);\n\n  if (typeof window === 'undefined' || !window.btoa) {\n    let buff = new Buffer(bytes);\n    return buff.toString('base64');\n  } else {\n    return window.btoa(binary);\n  }\n}\n\nexports.uint8arrayToBase64 = uint8arrayToBase64;\n\nfunction base64toBase64Url(base64) {\n  return base64.split('/').join('_').split('+').join('-'); // .split('=').join('.');\n}\n\nexports.base64toBase64Url = base64toBase64Url;\n\nfunction pemOrBase64Orbase64urlToString(base64str) {\n  let base64StrArray = base64str.split(/\\r?\\n/); // maybe remove empty lines at the end of file\n\n  while (base64StrArray[base64StrArray.length - 1].trim() === \"\") {\n    base64StrArray.pop();\n  } // maybe remove first and last line and concat lines\n\n\n  if (base64str.slice(0, 3) === \"---\") {\n    base64StrArray.shift();\n    base64StrArray.pop();\n  }\n\n  base64str = base64StrArray.join(''); // maybe change base64url to base64\n\n  base64str = base64str.split('_').join('/').split('-').join('+').split('.').join('=');\n  return base64str;\n}\n\nexports.pemOrBase64Orbase64urlToString = pemOrBase64Orbase64urlToString;\n/*\nConvert pem/base64/base64url to Uint8Array\n */\n\nfunction base64ToUint8array(base64str) {\n  base64str = pemOrBase64Orbase64urlToString(base64str);\n  let res; // if (typeof Buffer !== 'undefined') {\n\n  if (typeof window === 'undefined' || !window.atob) {\n    res = Uint8Array.from(Buffer.from(base64str, 'base64'));\n  } else {\n    res = Uint8Array.from(atob(base64str), c => c.charCodeAt(0));\n  }\n\n  return res;\n}\n\nexports.base64ToUint8array = base64ToUint8array;\n\nfunction stringToArray(str) {\n  var arr = [];\n\n  for (var i = 0; i < str.length; i++) {\n    arr.push(str.charCodeAt(i));\n  }\n\n  return arr;\n}\n\nexports.stringToArray = stringToArray;\n\nfunction BnPowMod(base, n, mod) {\n  let res = 1n,\n      cur = base;\n\n  while (n > 0n) {\n    if (n & 1n) res = res * cur % mod;\n    cur = cur * cur % mod;\n    n >>= 1n;\n  }\n\n  return res;\n}\n\nexports.BnPowMod = BnPowMod;\n\nfunction uint8tohex(uint8) {\n  if (!uint8 || !uint8.length) return '';\n  return Array.from(uint8).map(i => ('0' + i.toString(16)).slice(-2)).join('');\n}\n\nexports.uint8tohex = uint8tohex; // TODO unit test it\n\nfunction getInt64Bytes(x) {\n  let y = Math.floor(x / 2 ** 32);\n  return new Uint8Array([y, y << 8, y << 16, y << 24, x, x << 8, x << 16, x << 24].map(z => z >>> 24));\n}\n\nexports.getInt64Bytes = getInt64Bytes;\n\nfunction hashStringTo32bytesUint8(str) {\n  return hashUint8To32bytesUint8(Uint8Array.from(stringToArray(str)));\n}\n\nexports.hashStringTo32bytesUint8 = hashStringTo32bytesUint8;\n\nfunction hashUint8To32bytesUint8(data) {\n  let arr = Array.from(data);\n  return uint8merge([new Uint8Array(32), new Uint8Array(hexStringToArray(sha3.keccak256(arr)))]).slice(-32);\n}\n\nexports.hashUint8To32bytesUint8 = hashUint8To32bytesUint8;\n\nfunction ethAddressToUint8(str) {\n  if (str.toLowerCase().match(/^0x[a-f0-9]{40}$/i) === null) {\n    throw new Error('Wrong Ethereum Address');\n  }\n\n  let addr = Uint8Array.from(hexStringToArray(str.substr(2)));\n  if (addr.length != 20) throw new Error('wrong address length');\n  return addr;\n}\n\nexports.ethAddressToUint8 = ethAddressToUint8;\n\nfunction formatGeneralizedDateTime(date) {\n  var d = new Date(date),\n      month = '' + (d.getUTCMonth() + 1),\n      day = '' + d.getUTCDate(),\n      year = d.getUTCFullYear();\n  let hour = '' + d.getUTCHours(),\n      min = '' + d.getUTCMinutes(),\n      sec = '' + d.getUTCSeconds();\n  if (month.length < 2) month = '0' + month;\n  if (day.length < 2) day = '0' + day;\n  if (hour.length < 2) hour = '0' + hour;\n  if (min.length < 2) min = '0' + min;\n  if (sec.length < 2) sec = '0' + sec;\n  return [year, month, day, hour, min, sec].join('') + 'Z';\n}\n\nexports.formatGeneralizedDateTime = formatGeneralizedDateTime;\n\nfunction isDomainValid(domain) {\n  try {\n    new URL(domain);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isDomainValid = isDomainValid;\n\nfunction logger(level, ...args) {\n  if (!displayDebugLevel || level > displayDebugLevel) return;\n  console.log(...args);\n}\n\nexports.logger = logger;\n\nfunction testsLogger(level, ...args) {\n  if (!testsDisplayDebugLevel || level > testsDisplayDebugLevel) return;\n  console.log(...args);\n}\n\nexports.testsLogger = testsLogger;\n\nfunction ecSignatureToSRVhex(signature, ecKey) {\n  try {\n    let r = signature.r.toString(16).padStart(64, \"0\");\n    let s_ = signature.s;\n    let v = signature.recoveryParam;\n    let half_curve = ecKey.ec.curve.n.shrn(1);\n\n    if (s_.cmp(half_curve) > 0) {\n      s_ = ecKey.ec.curve.n.sub(s_);\n      v = 1 - v;\n    }\n\n    let s = s_.toString(16).padStart(64, \"0\");\n    return r + s + (v == 1 ? \"1c\" : \"1b\");\n  } catch (e) {\n    logger(config_1.DEBUGLEVEL.LOW, e);\n    throw new Error(\"Signature format doesn't fit.\");\n  }\n}\n\nexports.ecSignatureToSRVhex = ecSignatureToSRVhex; //# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"script"}