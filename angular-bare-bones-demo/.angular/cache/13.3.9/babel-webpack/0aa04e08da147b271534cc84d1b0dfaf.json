{"ast":null,"code":"import _asyncToGenerator from \"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { isBrowser, getLocation, getQueryString, detectEnv, appendToQueryString } from \"@walletconnect/utils\";\nimport NetworkMonitor from \"./network\";\nconst WS = typeof global.WebSocket !== \"undefined\" ? global.WebSocket : require(\"ws\");\n\nclass SocketTransport {\n  constructor(opts) {\n    this.opts = opts;\n    this._queue = [];\n    this._events = [];\n    this._subscriptions = [];\n    this._protocol = opts.protocol;\n    this._version = opts.version;\n    this._url = \"\";\n    this._netMonitor = null;\n    this._socket = null;\n    this._nextSocket = null;\n    this._subscriptions = opts.subscriptions || [];\n    this._netMonitor = opts.netMonitor || new NetworkMonitor();\n\n    if (!opts.url || typeof opts.url !== \"string\") {\n      throw new Error(\"Missing or invalid WebSocket url\");\n    }\n\n    this._url = opts.url;\n\n    this._netMonitor.on(\"online\", () => this._socketCreate());\n  }\n\n  set readyState(value) {}\n\n  get readyState() {\n    return this._socket ? this._socket.readyState : -1;\n  }\n\n  set connecting(value) {}\n\n  get connecting() {\n    return this.readyState === 0;\n  }\n\n  set connected(value) {}\n\n  get connected() {\n    return this.readyState === 1;\n  }\n\n  set closing(value) {}\n\n  get closing() {\n    return this.readyState === 2;\n  }\n\n  set closed(value) {}\n\n  get closed() {\n    return this.readyState === 3;\n  }\n\n  open() {\n    this._socketCreate();\n  }\n\n  close() {\n    this._socketClose();\n  }\n\n  send(message, topic, silent) {\n    if (!topic || typeof topic !== \"string\") {\n      throw new Error(\"Missing or invalid topic field\");\n    }\n\n    this._socketSend({\n      topic: topic,\n      type: \"pub\",\n      payload: message,\n      silent: !!silent\n    });\n  }\n\n  subscribe(topic) {\n    this._socketSend({\n      topic: topic,\n      type: \"sub\",\n      payload: \"\",\n      silent: true\n    });\n  }\n\n  on(event, callback) {\n    this._events.push({\n      event,\n      callback\n    });\n  }\n\n  _socketCreate() {\n    if (this._nextSocket) {\n      return;\n    }\n\n    const url = getWebSocketUrl(this._url, this._protocol, this._version);\n    this._nextSocket = new WS(url);\n\n    if (!this._nextSocket) {\n      throw new Error(\"Failed to create socket\");\n    }\n\n    this._nextSocket.onmessage = event => this._socketReceive(event);\n\n    this._nextSocket.onopen = () => this._socketOpen();\n\n    this._nextSocket.onerror = event => this._socketError(event);\n\n    this._nextSocket.onclose = () => {\n      setTimeout(() => {\n        this._nextSocket = null;\n\n        this._socketCreate();\n      }, 1000);\n    };\n  }\n\n  _socketOpen() {\n    this._socketClose();\n\n    this._socket = this._nextSocket;\n    this._nextSocket = null;\n\n    this._queueSubscriptions();\n\n    this._pushQueue();\n  }\n\n  _socketClose() {\n    if (this._socket) {\n      this._socket.onclose = () => {};\n\n      this._socket.close();\n    }\n  }\n\n  _socketSend(socketMessage) {\n    const message = JSON.stringify(socketMessage);\n\n    if (this._socket && this._socket.readyState === 1) {\n      this._socket.send(message);\n    } else {\n      this._setToQueue(socketMessage);\n\n      this._socketCreate();\n    }\n  }\n\n  _socketReceive(event) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let socketMessage;\n\n      try {\n        socketMessage = JSON.parse(event.data);\n      } catch (error) {\n        return;\n      }\n\n      _this._socketSend({\n        topic: socketMessage.topic,\n        type: \"ack\",\n        payload: \"\",\n        silent: true\n      });\n\n      if (_this._socket && _this._socket.readyState === 1) {\n        const events = _this._events.filter(event => event.event === \"message\");\n\n        if (events && events.length) {\n          events.forEach(event => event.callback(socketMessage));\n        }\n      }\n    })();\n  }\n\n  _socketError(e) {\n    const events = this._events.filter(event => event.event === \"error\");\n\n    if (events && events.length) {\n      events.forEach(event => event.callback(e));\n    }\n  }\n\n  _queueSubscriptions() {\n    const subscriptions = this._subscriptions;\n    subscriptions.forEach(topic => this._queue.push({\n      topic: topic,\n      type: \"sub\",\n      payload: \"\",\n      silent: true\n    }));\n    this._subscriptions = this.opts.subscriptions || [];\n  }\n\n  _setToQueue(socketMessage) {\n    this._queue.push(socketMessage);\n  }\n\n  _pushQueue() {\n    const queue = this._queue;\n    queue.forEach(socketMessage => this._socketSend(socketMessage));\n    this._queue = [];\n  }\n\n}\n\nfunction getWebSocketUrl(_url, protocol, version) {\n  var _a, _b;\n\n  const url = _url.startsWith(\"https\") ? _url.replace(\"https\", \"wss\") : _url.startsWith(\"http\") ? _url.replace(\"http\", \"ws\") : _url;\n  const splitUrl = url.split(\"?\");\n  const params = isBrowser() ? {\n    protocol,\n    version,\n    env: \"browser\",\n    host: ((_a = getLocation()) === null || _a === void 0 ? void 0 : _a.host) || \"\"\n  } : {\n    protocol,\n    version,\n    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || \"\"\n  };\n  const queryString = appendToQueryString(getQueryString(splitUrl[1] || \"\"), params);\n  return splitUrl[0] + \"?\" + queryString;\n}\n\nexport default SocketTransport; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module"}