{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/nicktaras/Documents/github/token-negotiator-examples/angular-bare-bones-demo/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KeyPair = exports.subtle = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst DerUtility_1 = require(\"./DerUtility\");\n\nconst Point_1 = require(\"./Point\");\n\nconst asn1_schema_1 = require(\"@peculiar/asn1-schema\");\n\nconst AttestationFramework_1 = require(\"../asn1/shemas/AttestationFramework\");\n\nconst ethers_1 = require(\"ethers\");\n\nconst Signature_1 = require(\"../asn1/shemas/Signature\");\n\nconst config_1 = require(\"../config\");\n\nlet EC = require(\"elliptic\");\n\nif (typeof crypto === \"object\" && crypto.subtle) {\n  exports.subtle = crypto.subtle;\n} else {\n  let webcrypto = require('crypto').webcrypto;\n\n  if (webcrypto) {\n    exports.subtle = webcrypto.subtle;\n  } else {\n    (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, \"Webcrypto not accessible\");\n    throw new Error(\"webcrypto.subtle missing\");\n  }\n}\n\nlet ec = new EC.ec('secp256k1');\n\nlet sha3 = require(\"js-sha3\"); // keys = elliptic.js curves, value = browser subtle curve (also supported by node.js)\n// node.js supports 'P-256', 'P-384', 'P-521', 'NODE-ED25519', 'NODE-ED448', 'NODE-X25519', or 'NODE-X448'\n\n\nconst EC_CURVES_SUBTLE = {\n  p192: null,\n  p224: null,\n  p256: 'P-256',\n  p384: 'P-384',\n  p521: 'P-521',\n  curve25519: null,\n  ed25519: null,\n  secp256k1: null\n}; // G x, y values taken from official secp256k1 document\n\nconst G = new Point_1.Point(55066263022277343669578718895168534326250603453777594175500187360389116729240n, 32670510020758816978083085130507043184471273380659243275938904335757337482424n);\nconst DEFAULT_ALGORITHM = 'secp256k1';\n\nclass KeyPair {\n  constructor() {\n    this.ethereumPrefix = \"\\u0019Ethereum Signed Message:\\n\";\n    this.algorithmASNList = {\n      secp256k1: [\"3081ec06072a8648ce3d02013081e0020101302c06072a8648ce3d0101022100fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f3044042000000000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000000704410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8022100fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141020101\", \"06052b8104000a\"],\n      sect283k1: [\"3081f806072a8648ce3d02013081ec020101302506072a8648ce3d0102301a0202011b06092a8648ce3d01020303300902010502010702010c304c042400000000000000000000000000000000000000000000000000000000000000000000000004240000000000000000000000000000000000000000000000000000000000000000000000010449040503213f78ca44883f1a3b8162f188e553cd265f23c1567a16876913b0c2ac245849283601ccda380f1c9e318d90f95d07e5426fe87e45c0e8184698e45962364e34116177dd2259022401ffffffffffffffffffffffffffffffffffe9ae2ed07577265dff7f94451e061e163c61020104\"],\n      // NIST P-256, secp256r1, prime256v1\n      p256: [\"3081ec06072a8648ce3d02013081e0020101302c06072a8648ce3d0101022100ffffffff00000001000000000000000000000000ffffffffffffffffffffffff30440420ffffffff00000001000000000000000000000000fffffffffffffffffffffffc04205ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b0441046b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c2964fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5022100ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551020101\"]\n    };\n  }\n\n  getPrivateAsUint8() {\n    return this.privKey;\n  }\n\n  getPrivateAsHexString() {\n    return (0, utils_1.uint8tohex)(this.privKey);\n  }\n\n  getPrivateAsBigInt() {\n    return (0, utils_1.uint8ToBn)(this.privKey);\n  }\n\n  static privateFromBigInt(priv) {\n    let me = new this();\n    me.privKey = new Uint8Array((0, utils_1.hexStringToArray)(priv.toString(16).padStart(64, '0')));\n    return me;\n  } // hex string 129-130 symbols with leading 04 (it means uncompressed)\n\n\n  static fromPublicHex(publicHex) {\n    if (publicHex.toLowerCase().match(/^[a-f0-9]+$/i) === null) {\n      throw new Error('Wrong Hex string input');\n    }\n\n    if (publicHex.length < 129 || publicHex.length > 130) {\n      throw new Error('Wrong public hex length');\n    }\n\n    let me = new this();\n    me.pubKey = new Uint8Array((0, utils_1.hexStringToArray)(publicHex));\n    return me;\n  }\n\n  static fromPrivateUint8(privateUint, keyAlg = '') {\n    if (!privateUint || privateUint.length != 32) {\n      throw new Error('Wrong private key. Should be 32 bytes Uint8');\n    }\n\n    let me = new this();\n    me.privKey = privateUint;\n\n    if (keyAlg && Point_1.CURVES.hasOwnProperty(keyAlg)) {\n      me.algorithm = keyAlg;\n    } else {\n      throw new Error(`Algorithm ${keyAlg} not implemented.`);\n    }\n\n    return me;\n  }\n\n  static publicFromBase64orPEM(encoded) {\n    return KeyPair.publicFromPEM((0, utils_1.pemOrBase64Orbase64urlToString)(encoded));\n  }\n\n  static publicFromPEM(pem) {\n    const pubUint8 = (0, utils_1.base64ToUint8array)(pem);\n    let publicKeyObj = asn1_schema_1.AsnParser.parse(pubUint8, AttestationFramework_1.PublicKeyInfoValue);\n    return KeyPair.publicFromUint(new Uint8Array(publicKeyObj.publicKey));\n  }\n\n  static publicFromUint(key) {\n    let me = new this();\n\n    if (key.byteLength != 65) {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, 'Wrong public key length');\n      throw new Error('Wrong public key length');\n    }\n\n    me.pubKey = new Uint8Array(key);\n    return me;\n  }\n\n  static publicFromSubjectPublicKeyInfo(spki) {\n    let me = new this();\n    me.pubKey = new Uint8Array(spki.value.publicKey);\n    return me;\n  }\n\n  static publicFromSubjectPublicKeyValue(spki) {\n    let me = new this();\n    me.pubKey = new Uint8Array(spki.publicKey);\n    me.algorithm = me.getAlgorithNameFromASN1((0, utils_1.uint8tohex)(new Uint8Array(spki.algorithm)));\n    return me;\n  }\n\n  static privateFromKeyInfo(spki) {\n    let me = new this();\n    let privateKeyObj = asn1_schema_1.AsnParser.parse(spki.keysData, AttestationFramework_1.PrivateKeyData);\n    me.algorithm = me.getAlgorithNameFromASN1((0, utils_1.uint8tohex)(new Uint8Array(spki.algIdent)));\n    me.privKey = new Uint8Array(privateKeyObj.privateKey);\n    return me;\n  }\n\n  static privateFromKeyDataPEM(pem) {\n    const receiverPrivUint8 = (0, utils_1.base64ToUint8array)(pem);\n    let privateKeyObj = asn1_schema_1.AsnParser.parse(receiverPrivUint8, AttestationFramework_1.PrivateKeyData);\n    let me = new this(); // TODO detect and validate algorithm\n\n    me.algorithm = me.getAlgorithNameFromASN1((0, utils_1.uint8tohex)(new Uint8Array(privateKeyObj.algDescr)));\n    me.privKey = new Uint8Array(privateKeyObj.privateKey);\n    return me;\n  }\n\n  getAlgorithNameFromASN1(alg) {\n    let algEncodings = {};\n\n    for (const property in this.algorithmASNList) {\n      this.algorithmASNList[property].forEach(algAsn1 => {\n        algEncodings[algAsn1] = property;\n      });\n    }\n\n    if (algEncodings.hasOwnProperty(alg)) {\n      return algEncodings[alg];\n    } else {\n      let m = \"Unknown algorithm.\";\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, m);\n      throw new Error(m);\n    }\n  }\n\n  static privateFromPEM(pem) {\n    const receiverPrivUint8 = (0, utils_1.base64ToUint8array)(pem);\n    let privateKeyObj = asn1_schema_1.AsnParser.parse(receiverPrivUint8, AttestationFramework_1.PrivateKeyInfo);\n    return KeyPair.privateFromKeyInfo(privateKeyObj);\n  } // Generate a private key\n\n\n  static generateKeyAsync() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // using subtlecrypto to generate a key. note that we are using an AES key\n      // as an secp256k1 key here, since browsers don't support the latter;\n      // that means all the keys must be created exportable to work with.\n      const keyPair = yield crypto.subtle.generateKey({\n        name: 'AES-GCM',\n        length: 256\n      }, true, ['encrypt']);\n      let hex = ['0x'];\n      const exported = yield crypto.subtle.exportKey(\"raw\", keyPair);\n      new Uint8Array(exported).forEach(i => {\n        var h = i.toString(16);\n\n        if (h.length % 2) {\n          h = '0' + h;\n        }\n\n        hex.push(h);\n      }); // the next line works if AES key is always positive\n\n      return _this.privateFromBigInt(BigInt(hex.join('')) % Point_1.CURVE_SECP256k1.n);\n    })();\n  }\n\n  static createKeys() {\n    return this.privateFromBigInt(BigInt('0x' + (0, utils_1.uint8tohex)(crypto.getRandomValues(new Uint8Array(32)))) % Point_1.CURVE_SECP256k1.n);\n  }\n\n  getPublicKeyAsHexStr() {\n    if (this.pubKey) {\n      return (0, utils_1.uint8tohex)(this.pubKey);\n    } else {\n      // we can use it to count pubPoint without external lib, but it can not work for some curves, where we need to do BN reduction before compress point\n      // if (CURVES.hasOwnProperty(this.algorithm) && EC_CURVES.includes(this.algorithm)) {\n      //     let curve = CURVES[this.algorithm];\n      //     logger(DEBUGLEVEL.HIGH, 'lets generate public key for ' + this.algorithm);\n      //     let PointG = new Point(curve.GX, curve.GY, curve);\n      //     let pubPoint = PointG.multiplyDA(mod(this.getPrivateAsBigInt(),curve.n));\n      //     logger(DEBUGLEVEL.HIGH, 'point ' + pubPoint.useCurve);\n      //     // prefix 04 means it is uncompressed key\n      //     return '04' + pubPoint.x.toString(16).padStart(64, '0') + pubPoint.y.toString(16).padStart(64, '0')\n      if (Point_1.CURVES.hasOwnProperty(this.algorithm) && EC_CURVES_SUBTLE.hasOwnProperty(this.algorithm)) {\n        let curve = new EC.ec(this.algorithm);\n\n        if (!this.getPrivateAsHexString()) {\n          (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, this);\n          throw new Error(\"Cant sign. This is only public key.\");\n        }\n\n        let key = curve.keyFromPrivate(this.getPrivateAsHexString(), 'hex');\n        return key.getPublic('hex').toString();\n      } else {\n        let m = 'Private -> Public key not implemented for that aglorighm - \"' + this.algorithm + '\"';\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, m);\n        throw new Error(m);\n      }\n    }\n  }\n\n  getAsnDerPublic() {\n    var pubPoint = this.getPublicKeyAsHexStr(); // algorithm description hardcoded\n\n    let pubPointTypeDescrDER = '';\n\n    if (!this.algorithm) {\n      let m = 'algorithm undefined, lets use default.';\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.VERBOSE, m);\n      pubPointTypeDescrDER = this.algorithmASNList[DEFAULT_ALGORITHM][0];\n    } else if (!this.algorithmASNList.hasOwnProperty(this.algorithm)) {\n      let m = 'Fatal Error. Algorithm not implemented yet - ' + this.algorithm;\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, m);\n      throw new Error(m);\n    } else {\n      pubPointTypeDescrDER = this.algorithmASNList[this.algorithm][0];\n    }\n\n    return DerUtility_1.Asn1Der.encode('SEQUENCE_30', pubPointTypeDescrDER + DerUtility_1.Asn1Der.encode('BIT_STRING', pubPoint));\n  }\n\n  getAddress() {\n    var pubPoint = this.getPublicKeyAsHexStr();\n    pubPoint = pubPoint.substr(2);\n    let hash = sha3.keccak256((0, utils_1.hexStringToArray)(pubPoint));\n    return \"0x\" + hash.substr(-40).toUpperCase();\n  }\n\n  signBytes(bytes) {\n    if (!this.getPrivateAsHexString()) {\n      throw new Error(\"Cant sign. This is only public key.\");\n    }\n\n    let ecKey = ec.keyFromPrivate(this.getPrivateAsHexString(), 'hex');\n    let encodingHash = sha3.keccak256(bytes);\n    let signature = ecKey.sign(encodingHash);\n    return signature.toDER('hex');\n  }\n\n  signStringWithEthereum(message) {\n    if (!this.getPrivateAsHexString()) {\n      throw new Error(\"Cant sign. This is only public key.\");\n    }\n\n    let ecKey = ec.keyFromPrivate(this.getPrivateAsHexString(), 'hex');\n    let finalMsg = this.ethereumPrefix + message.length + message;\n    let encodingHash = sha3.keccak256((0, utils_1.stringToArray)(finalMsg));\n    let signature = ecKey.sign(encodingHash);\n    return signature.toDER('hex');\n  }\n\n  signHexStringWithEthereum(message) {\n    return this.signStringWithEthereum('0x' + message);\n  }\n\n  signBytesWithEthereum(bytes) {\n    let message = '0x' + (0, utils_1.uint8tohex)(new Uint8Array(bytes));\n    (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, \"message: \" + message);\n    return this.signStringWithEthereum(message);\n  }\n\n  signDeterministicSHA256(bytes) {\n    let sha256 = Array.from(ethers_1.ethers.utils.arrayify(ethers_1.ethers.utils.sha256(bytes)));\n    return this.signBytes(sha256);\n  }\n\n  verifyDeterministicSHA256(bytes, signature) {\n    let sha256 = ethers_1.ethers.utils.sha256(bytes).substr(2);\n    let key, sign;\n\n    if (Point_1.CURVES.hasOwnProperty(this.algorithm) && EC_CURVES_SUBTLE.hasOwnProperty(this.algorithm)) {\n      let curve = new EC.ec(this.algorithm);\n      key = curve.keyFromPublic(this.getPublicKeyAsHexStr(), 'hex');\n    } else {\n      let m = 'Elliptic.js curve not implemented for that aglorighm - \"' + this.algorithm + '\"';\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, m);\n      throw new Error(m);\n    }\n\n    if (signature.length == 128 || signature.length == 130) {\n      var m = signature.match(/([a-f\\d]{64})/gi);\n      sign = {\n        r: m[0],\n        s: m[1]\n      };\n    } else {\n      let signatureAsn1 = asn1_schema_1.AsnParser.parse((0, utils_1.hexStringToUint8)(signature), Signature_1.Signature);\n      sign = {\n        r: BigInt(signatureAsn1.r).toString(16).padStart(64, '0'),\n        s: BigInt(signatureAsn1.s).toString(16).padStart(64, '0')\n      };\n    }\n\n    return key.verify(sha256, sign);\n  }\n\n  verifyHexStringWithEthereum(message, signature) {\n    let finalMsg = '0x' + message;\n    let encodingHash = sha3.keccak256((0, utils_1.stringToArray)(this.ethereumPrefix + finalMsg.length + finalMsg));\n    let ecKey = ec.keyFromPublic(this.getPublicKeyAsHexStr(), 'hex');\n    var m = signature.match(/([a-f\\d]{64})/gi);\n    let sign = {\n      r: m[0],\n      s: m[1]\n    };\n    return ecKey.verify(encodingHash, sign);\n  }\n\n  signRawBytesWithEthereum(bytes) {\n    let encodingHash = ethers_1.ethers.utils.keccak256(bytes).substring(2);\n    (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, `signRawBytesWithEthereum: key: ${this.getAddress()}, hash: ${encodingHash}`);\n\n    if (!this.getPrivateAsHexString()) {\n      throw new Error(\"Cant sign. This is only public key.\");\n    }\n\n    let ecKey = ec.keyFromPrivate(this.getPrivateAsHexString(), 'hex');\n    let signatureInstance = ecKey.sign((0, utils_1.hexStringToUint8)(encodingHash));\n    return (0, utils_1.ecSignatureToSRVhex)(signatureInstance, ecKey);\n  }\n\n  verifyBytesWithEthereum(bytes, signature) {\n    if (!bytes || !bytes.length) {\n      throw new Error('Missing data to verify');\n    }\n\n    if (!signature) {\n      throw new Error('Missing signature to verify');\n    } // let encodingHash = sha3.keccak256(bytes);\n\n\n    let encodingHash = (0, utils_1.hexStringToArray)(ethers_1.ethers.utils.keccak256(bytes));\n    let ecKey = ec.keyFromPublic(this.getPublicKeyAsHexStr(), 'hex');\n    (0, utils_1.logger)(config_1.DEBUGLEVEL.HIGH, `verifyBytesWithEthereum: key: ${this.getAddress()}, hash: ${(0, utils_1.uint8tohex)(new Uint8Array(encodingHash))}`); // TODO add signature conversion\n\n    signature = (0, utils_1.uint8tohex)(KeyPair.anySignatureToRawUint8(signature));\n    var m = signature.match(/([a-f\\d]{64})/gi);\n    let sign = {\n      r: m[0],\n      s: m[1]\n    };\n    return ecKey.verify(encodingHash, sign); // return ecKey.verify(encodingHash, signature);\n  }\n\n  getJWTParams() {\n    let curve = EC_CURVES_SUBTLE[this.algorithm];\n\n    if (!curve) {\n      let m = `Cant create subtleCrypto key for curve '${this.algorithm}'`;\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, m);\n      throw new Error(m);\n    }\n\n    let pub = this.getPublicKeyAsHexStr();\n    return {\n      crv: curve,\n      d: (0, utils_1.uint8arrayToBase64)(this.getPrivateAsUint8()),\n      // ext: true,\n      key_ops: [\"sign\"],\n      kty: \"EC\",\n      x: (0, utils_1.uint8arrayToBase64)((0, utils_1.hexStringToUint8)(pub.substr(2, 64))),\n      y: (0, utils_1.uint8arrayToBase64)((0, utils_1.hexStringToUint8)(pub.substr(66, 64)))\n    };\n  }\n\n  getSubtlePrivateKey() {\n    let curve = EC_CURVES_SUBTLE[this.algorithm];\n    return exports.subtle.importKey(\"jwk\", this.getJWTParams(), {\n      name: \"ECDSA\",\n      namedCurve: curve\n    }, true, [\"sign\"]);\n  }\n\n  getSubtlePublicKey() {\n    let curve = EC_CURVES_SUBTLE[this.algorithm];\n    let params = this.getJWTParams();\n    delete params.d;\n    params.key_ops = ['verify'];\n    return exports.subtle.importKey(\"jwk\", params, {\n      name: \"ECDSA\",\n      namedCurve: curve\n    }, true, [\"verify\"]);\n  }\n\n  signStringWithSubtle(msg) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return yield exports.subtle.sign({\n        name: \"ECDSA\",\n        hash: {\n          name: \"SHA-256\"\n        }\n      }, yield _this2.getSubtlePrivateKey(), // ethers.utils.sha256(Uint8Array.from(stringToArray(msg)))\n      // subtle sign do the sha256 encoding internally\n      Uint8Array.from((0, utils_1.stringToArray)(msg)));\n    })();\n  }\n\n  verifyStringWithSubtle(signature, msg) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.VERBOSE, 'pubkey: ' + _this3.getPublicKeyAsHexStr() + ' msg:' + msg + ' signature:' + (0, utils_1.uint8tohex)(signature));\n      (0, utils_1.logger)(config_1.DEBUGLEVEL.VERBOSE, yield _this3.getSubtlePublicKey());\n      return yield exports.subtle.verify({\n        name: \"ECDSA\",\n        hash: {\n          name: \"SHA-256\"\n        }\n      }, yield _this3.getSubtlePublicKey(), signature, Uint8Array.from((0, utils_1.stringToArray)(msg)));\n    })();\n  }\n\n  verifyStringWithSubtleDerSignature(signature, msg) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      let signatureAsn1 = asn1_schema_1.AsnParser.parse(signature, Signature_1.Signature);\n      const javaSignatureHexRaw = BigInt(signatureAsn1.r).toString(16).padStart(64, '0') + BigInt(signatureAsn1.s).toString(16).padStart(64, '0');\n      return _this4.verifyStringWithSubtle((0, utils_1.hexStringToUint8)(javaSignatureHexRaw), msg);\n    })();\n  }\n\n  static anySignatureToRawUint8(derSignature) {\n    let signatureUint8;\n\n    if (typeof derSignature == \"string\") {\n      signatureUint8 = (0, utils_1.hexStringToUint8)(derSignature);\n    } else {\n      signatureUint8 = derSignature;\n    }\n\n    if (!signatureUint8 || !signatureUint8.length) {\n      throw new Error('Empty signature received');\n    }\n\n    let output;\n\n    switch (signatureUint8.length) {\n      case 64:\n        (0, utils_1.logger)(config_1.DEBUGLEVEL.LOW, `anySignatureToRawUint8 received 64 bytes signature (without v value) = ${(0, utils_1.uint8tohex)(signatureUint8)}`);\n\n      case 65:\n        output = signatureUint8;\n        break;\n      // remove last byte ( v ) value\n      // output = signatureUint8.slice(0,64);\n      // break;\n\n      case 66:\n        // remove 04 at start\n        if (signatureUint8[0] != 4) {\n          throw new Error(`Cant recognize signature: ${(0, utils_1.uint8tohex)(signatureUint8)}`);\n        }\n\n        output = signatureUint8.slice(1, 65);\n        break;\n\n      case 70:\n      case 71:\n      case 72:\n        let signatureAsn1 = asn1_schema_1.AsnParser.parse(signatureUint8, Signature_1.Signature);\n        output = (0, utils_1.hexStringToUint8)(BigInt(signatureAsn1.r).toString(16).padStart(64, '0') + BigInt(signatureAsn1.s).toString(16).padStart(64, '0'));\n        break;\n\n      default:\n        let m = 'wrong Signature: ' + (0, utils_1.uint8tohex)(signatureUint8);\n        throw new Error(m);\n    }\n\n    (0, utils_1.logger)(config_1.DEBUGLEVEL.VERBOSE, \"ready signature:\" + (0, utils_1.uint8tohex)(output));\n    return output;\n  }\n\n  static parseKeyArrayStrings(keys) {\n    for (let i in keys) {\n      if (typeof keys[i] === \"string\") keys[i] = KeyPair.publicFromBase64orPEM(keys[i]);\n    }\n\n    return keys;\n  }\n\n}\n\nexports.KeyPair = KeyPair; //# sourceMappingURL=KeyPair.js.map","map":null,"metadata":{},"sourceType":"script"}