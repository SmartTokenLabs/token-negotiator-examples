{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Asn1Der = exports.X500NamesLabels = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst config_1 = require(\"../config\");\n\nconst matchAll = require('string.prototype.matchall');\n\nconst Asn1DerTagByType = {\n  END_OF_CONTENT: 0,\n  BOOLEAN: 1,\n  INTEGER: 2,\n  BIT_STRING: 3,\n  OCTET_STRING: 4,\n  NULL_VALUE: 5,\n  OBJECT_ID: 6,\n  OBJECT_DESCRIPTOR: 7,\n  EXTERNAL: 8,\n  REAL: 9,\n  ENUMERATED: 10,\n  EMBEDDED_PDV: 11,\n  UTF8STRING: 12,\n  RELATIVE_OID: 13,\n  //reserved: 14,\n  //reserved: 15,\n  SEQUENCE_10: 16,\n  SET_OF: 17,\n  NUMERABLE_STRING: 18,\n  PRINTABLE_STRING: 19,\n  T61STRING: 20,\n  VIDEO_TEX_STRING: 21,\n  IA5STRING: 22,\n  UTC_TIME: 23,\n  GENERALIZED_TIME: 24,\n  // SimpleDateFormat dateF = new SimpleDateFormat(\"yyyyMMddHHmmss'Z'\", DateUtil.EN_Locale);\n  // dateF.setTimeZone(new SimpleTimeZone(0, \"Z\"));\n  // time = Strings.toByteArray(dateF.format(time));\n  GRAPHIC_STRING: 25,\n  VISIBLE_STRING: 26,\n  GENERAL_STRING: 27,\n  UNIVERSAL_STRING: 28,\n  CHARACTER_STRING: 29,\n  BMP_STRING: 30,\n  //long_form: 31,\n  SEQUENCE_30: 48,\n  SET: 49\n};\nconst Asn1DerTagById = {\n  0: \"END_OF_CONTENT\",\n  1: \"BOOLEAN\",\n  2: \"INTEGER\",\n  3: \"BIT_STRING\",\n  4: \"OCTET_STRING\",\n  5: \"NULL_VALUE\",\n  6: \"OBJECT_ID\",\n  7: \"OBJECT_DESCRIPTOR\",\n  8: \"EXTERNAL\",\n  9: \"REAL\",\n  10: \"ENUMERATED\",\n  11: \"EMBEDDED_PDV\",\n  12: \"UTF8STRING\",\n  13: \"RELATIVE_OID\",\n  16: \"SEQUENCE_10\",\n  19: \"PRINTABLE_STRING\",\n  22: \"IA5STRING\",\n  24: \"GENERALIZED_TIME\",\n  26: \"VISIBLE_STRING\",\n  48: \"SEQUENCE_30\",\n  49: \"SET\"\n};\nexports.X500NamesLabels = {\n  'CN': \"2.5.4.3\",\n  'C': \"2.5.4.6\",\n  'O': \"2.5.4.10\",\n  'OU': \"2.5.4.11\",\n  'L': \"2.5.4.7\",\n  'labeledURI': \"1.3.6.1.4.1.250.1.57\"\n};\n\nclass Asn1Der {\n  static encodeAsInteger(value) {\n    return this.encode('INTEGER', value);\n  }\n\n  static encodeObjectId(objectId) {\n    return Asn1Der.encode('SEQUENCE_30', Asn1Der.encode('OBJECT_ID', objectId));\n  }\n\n  static parseX500Names(str) {\n    let matches = str.matchAll(/(\\w+)=(\"[^\"]+\"|[\\w\\.]+)/g);\n    let alg = '';\n\n    if (!matches) {\n      throw new Error('wrong Name format');\n    }\n\n    let result = [];\n\n    for (const match of matches) {\n      let type = match[1];\n      let value = match[2]; // remove quotes if exists\n\n      if (value.substr(0, 1) == \"\\\"\" && value.substr(-1) == \"\\\"\") {\n        value = value.slice(1, value.length - 1);\n      }\n\n      ;\n      alg = exports.X500NamesLabels[type];\n      if (!alg) throw new Error('Type \"' + type + '\" not implemented yet');\n      result.push({\n        type,\n        value\n      });\n    }\n\n    return result;\n  }\n\n  static encodeName(str) {\n    let set = '';\n    let dataArr = Asn1Der.parseX500Names(str);\n    dataArr.forEach(item => {\n      let OID = exports.X500NamesLabels[item.type];\n\n      if (!OID) {\n        throw new Error(`X500 Name Object ID not implemented.(${item.value})`);\n      }\n\n      let itemData = Asn1Der.encode('OBJECT_ID', OID) + Asn1Der.encode('UTF8STRING', item.value);\n      set += Asn1Der.encode('SEQUENCE_30', itemData);\n    });\n    return Asn1Der.encode('SEQUENCE_30', Asn1Der.encode('SET', set));\n  }\n\n  static encode(type, value, id = 0) {\n    if (typeof value === \"undefined\") {\n      throw new Error('Missing value for Der encoding');\n    }\n\n    let encType = Asn1DerTagByType[type];\n    let encValue = '';\n\n    switch (type) {\n      case 'OBJECT_ID':\n        if (typeof value !== \"string\") {\n          throw new Error('OBJECT_ID value must be a string');\n        }\n\n        let valArr = value.split('.');\n        let v1 = valArr.shift();\n        let v2 = valArr.shift();\n        valArr.unshift((parseInt(v1) * 40 + parseInt(v2)).toString());\n        valArr.forEach(v => {\n          let num = parseInt(v);\n          let singleVal = '';\n          let firstByte = true;\n\n          do {\n            let tail127 = num & 127;\n            num = num >> 7;\n            tail127 += firstByte ? 0 : 128;\n            singleVal = tail127.toString(16).padStart(2, '0') + singleVal;\n            firstByte = false;\n          } while (num);\n\n          encValue += singleVal;\n        });\n        break;\n\n      case \"NULL_VALUE\":\n        encValue = '';\n        break;\n\n      case 'GENERALIZED_TIME':\n        encValue = (0, utils_1.stringToHex)((0, utils_1.formatGeneralizedDateTime)(value));\n        break;\n\n      case \"VISIBLE_STRING\":\n      case \"UTF8STRING\":\n        encValue = (0, utils_1.stringToHex)(value);\n        break;\n\n      case 'INTEGER':\n        encValue = BigInt(value).toString(16);\n        encValue = (encValue.length % 2 ? '0' : '') + encValue;\n\n        if (parseInt('0x' + encValue.slice(0, 1), 16) > 7) {\n          encValue = '00' + encValue;\n        }\n\n        break;\n\n      case 'TAG':\n        if (id > 15) {\n          throw new Error('DER TAG more than 15 is not implemented');\n        }\n\n        encType = parseInt('0xA' + id);\n\n      case \"SEQUENCE_30\":\n      case \"SET\":\n      case \"OCTET_STRING\":\n        if (typeof value == \"string\") {\n          // suppose that its already encoded\n          encValue = value;\n        } else if (value.constructor === Uint8Array) {\n          encValue = (0, utils_1.uint8tohex)(value);\n        } else {\n          throw new Error('Wrong data type for OCTET_STRING');\n        }\n\n        break;\n\n      case \"BIT_STRING\":\n        encValue = '00' + value;\n        break;\n\n      case \"BOOLEAN\":\n        encValue = parseInt(value).toString().padStart(2, '0');\n        break;\n\n      default:\n        throw new Error('Sorry, ' + type + ' not implemented.');\n    } // TODO maybe worth it to code indefinite form\n    // 8.1.3.6\tFor the indefinite form, the length octets indicate that the contents octets are terminated by end-of-contents octets (see 8.1.5), and shall consist of a single octet.\n    // 8.1.3.6.1\tThe single octet shall have bit 8 set to one, and bits 7 to 1 set to zero.\n    // 8.1.3.6.2\tIf this form of length is used, then end-of-contents octets (see 8.1.5) shall be present in the encoding following the contents octets.\n\n\n    let encLength = '';\n    let dataLength = Math.ceil(encValue.length / 2);\n    let dataLengthHex = dataLength.toString(16);\n    if (!dataLength) dataLengthHex = '00';\n    dataLengthHex = (dataLengthHex.length % 2 ? '0' : '') + dataLengthHex;\n\n    if (dataLength < 128) {\n      encLength = dataLengthHex;\n    } else {\n      encLength = (128 + Math.round(dataLengthHex.length / 2)).toString(16) + dataLengthHex;\n    }\n\n    encValue = (encValue.length % 2 ? '0' : '') + encValue;\n    return encType.toString(16).padStart(2, '0') + encLength + encValue;\n  }\n\n  decode(byteArray) {\n    let arr = Array.from(byteArray);\n    return this.read(arr);\n  }\n\n  lenEncoded(derArr) {\n    let b1 = derArr.shift();\n\n    if (b1 < 128) {\n      return b1;\n    } else if (b1 > 128) {\n      let extLength = 0;\n\n      for (let i = 0; i < b1 - 128; i++) {\n        extLength = (extLength << 8) + derArr.shift();\n      }\n\n      return extLength;\n    } else if (b1 == 128) {\n      throw new Error('have to code variable length');\n    }\n  }\n\n  readFromHexString(str) {\n    return this.read((0, utils_1.hexStringToArray)(str));\n  }\n\n  readFromUint8Array(u8) {\n    return this.read(Array.from(u8));\n  }\n\n  readFromBase64String(base64str) {\n    return this.readFromUint8Array((0, utils_1.base64ToUint8array)(base64str));\n  }\n\n  readFromUrlBase64String(urlBase64str) {\n    let base64str = urlBase64str.split('_').join('/').split('-').join('+').split('.').join('='); // .replace('.','');\n\n    return this.readFromBase64String(base64str);\n  }\n\n  read(derArr) {\n    let typeTag = derArr.shift();\n    let len = this.lenEncoded(derArr);\n    let typeTagName = Asn1DerTagById[typeTag];\n    (0, utils_1.logger)(config_1.DEBUGLEVEL.VERBOSE, \"Der utility typeTagName:\" + typeTagName);\n    let content = [];\n\n    for (let i = 0; i < len; i++) {\n      content.push(derArr.shift());\n    }\n\n    (0, utils_1.logger)(config_1.DEBUGLEVEL.VERBOSE, \"Der Utility content\");\n    (0, utils_1.logger)(config_1.DEBUGLEVEL.VERBOSE, content);\n    let outputStr = '';\n\n    switch (typeTagName) {\n      case \"SEQUENCE_30\":\n        return this.BodySequence(content);\n\n      case \"INTEGER\":\n      case \"BIT_STRING\":\n        let output = 0n;\n\n        while (content.length) {\n          output = output << 8n;\n          output += BigInt(content.shift());\n        }\n\n        return output;\n\n      case \"OCTET_STRING\":\n        while (content.length) {\n          outputStr += content.shift().toString(16).padStart(2, '0');\n        }\n\n        return outputStr;\n\n      case \"GENERALIZED_TIME\":\n      case \"VISIBLE_STRING\":\n        while (content.length) {\n          outputStr += String.fromCharCode(content.shift());\n        }\n\n        return outputStr;\n    }\n  }\n\n  BodySequence(derArr) {\n    let entries = [];\n\n    while (derArr.length) {\n      entries.push(this.read(derArr));\n    }\n\n    return entries;\n  }\n\n}\n\nexports.Asn1Der = Asn1Der; //# sourceMappingURL=DerUtility.js.map","map":null,"metadata":{},"sourceType":"script"}